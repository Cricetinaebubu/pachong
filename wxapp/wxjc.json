{"title": "微信小程序开发中 var that =this的用法 ", "author": "Rolan", "pub_time": "2020-2-6 00:52", "content": "在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量"}
{"title": "小程序canvas开发水果老虎机 ", "author": "Rolan", "pub_time": "2020-2-8 00:53", "content": "在这个超长假期中，无聊。。。，所以动手做一个早就计划要做的小玩意， 水果老虎机 ，嗯，这是一个小程序而不是小游戏...使用结构还是canvas？使用模板结构(view)生成水果盘的好处一是用户可自定义产出 n x n 的定制化老虎机，二是容易通过算法样式生成布局，三是通过 wx.selectQueryAll 的方法能够很方便的抓到定位数据。但，问题是动画性能过于孱弱，如图构建一个 7x7 的水果盘，动画性能估计会惨不忍睹，而且纯粹模板结构无论使用 animation 动画方法还是 css 的keyframe的动画方法得到的动画效果都非常差(测试过的结论)，还有是已知的动画方法可控性很差使用canvas来生成水果盘好处是动画性能很好(canvas2d)，但是定制性和扩展性比较差so综上考虑，使用模板(view)布局，使用canvas来实现动画。既保证了组件的性能，同时定制型，扩展性也很好准备计时器方法动画的生成离不开计时器方法，settimeout/setinterval这两兄弟真的不够看啊，问题还多，做过web开发的一定都知道 window.requestAnimationFrame ，这货在小程序的计时器方法中不存在，好在 canvas2d 中可以使用 Canvas.requestAnimationFrame(function callback) 方法来实现准备运动算法在水果老虎机中，激活状态会沿着四方的水果盘做非线性运动(easeInOut比较好用)，需要基础的运动算法来计算实际的运动距离。在 animation 动画方法中，我们可以使用 ease-in/ease-out 等缓动算法来实现动画效果，但在这里必须要借助 tween.js 中的缓动算法来实现运动效果(因为需要控制运动节点)。你会不会想到用css的keyframe动画来做这个运动效果，经过我的测试，css的动画和animation的动画会在每一条边上实现一次(ease)缓动运动(很奇怪的效果)推荐这篇文章使用其中一个，节省代码量/*\r\n * Tween.js\r\n * t: current time（当前时间）；\r\n * b: beginning value（初始值）；\r\n * c: change in value（变化量）；\r\n * d: duration（持续时间）。\r\n */\r\n// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n复制代码tween算法是以时间为基准(时间比率 = 距离比率)来计算单位时间的实际运动距离布局以上面的图为例，我们需要做一个 7 x 7 的水果盘，实际有效的奖品格子数为 7*4-4 共24个有效格子有效格子算法js// 0-6 第一行所有格子全部有效  \r\n// 21-27 最后一行所有格子全部有效  \r\n// 中间部分 i%7===0 和 i%7 === (7-1) 有效\r\n// 算法源码有点无聊，依据上述思路，即可遍历28个格子并标识奖品格子valide=true\r\n// 可以扩展想一想 6x6 5x5，思路是一样的\r\n复制代码wxml<view class=\"fruits-container\" >\r\n    <view class=\"fruits-table\" >\r\n        <block wx:for=\"{{ary}}\" wx:key=\"index\" >\r\n            <view wx:if=\"{{item.valide}}\" class=\"valide\">{{item.title}}</view>\r\n            <view wx:else class=\"in-valide\"></view>\r\n        </block>\r\n    </view>\r\n    <canvas type=\"2d\" .... />\r\n</view>\r\n复制代码样式只节选关键样式，目的是让canvas覆盖在水果盘上，长宽一致.fruits-container {\r\n    position: relative;\r\n    width: 400px;\r\n    height: 400px;\r\n    ...\r\n}\r\n\r\n.fruits-table {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n    ...\r\n}\r\n复制代码抓取位置信息canvas的绘制需要X轴, Y轴的精确信息，可以使用 wx.createSelectorQuery 方式抓取类名为‘valide’的 view (奖品格子)的位置信息let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    console.log(ret[0]) // top, left, right, bottom, width, height\r\n    console.log(ret[1]) // top, left, right, bottom, width, height\r\n    ...\r\n    ...\r\n    console.log(ret[23]) // top, left, right, bottom, width, height\r\n})\r\n复制代码得到每一个奖品格子的位置信息后，就可以使用canvas的 fillRect 方法来绘制激活状态了。绘制一个激活状态let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    let {top, left, right, bottom, width, height} = ret[0]\r\n    const canvasQuery = wx.createSelectorQuery()\r\n    canvasQuery.select('#fruit-canvas')\r\n    .fields({ node: true, size: true })\r\n    .exec((res) => {\r\n        const canvas = res[0].node\r\n        const ctx = canvas.getContext('2d') \r\n        let x = top\r\n        let y = left\r\n        let dx = width\r\n        let dy = height\r\n        ctx.shadowOffsetX = 2\r\n        ctx.shadowOffsetY = -2\r\n        ctx.shadowColor = 'red'\r\n        ctx.shadowBlur = 50\r\n        ctx.lineWidth = 5\r\n        ctx.strokeStyle = 'red'\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n        ctx.strokeRect(x, y, dx, dy)\r\n    })\r\n})\r\n复制代码跑起来已经绘制了一个激活状态，接下来使它能够简单动起来// 抽象激活方法  \r\nfuncton rect(point, canvas){\r\n    let {x, y, dx, dy} = getPosition(point)\r\n    ctx.shadowOffsetX = 2\r\n    ctx.shadowOffsetY = -2\r\n    ...\r\n    ...\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height) // 擦除整个水果盘\r\n    ctx.strokeRect(x, y, dx, dy) // 绘制激活区域\r\n}\r\n\r\nfunction run(){\r\n    setTimeout(()=>{\r\n        if (ret.length) {\r\n            let point = ret.shift()\r\n            rect(point, canvas)\r\n            run()\r\n        }\r\n    }, 100)\r\n}\r\n复制代码执行run方法后可以看到水果盘的激活状态一步一步的往前走(100毫秒)，拖拉机终于可以启动了配上运动算法经过上面的试验我们终于可以看到基本的运动效果了，接下来配上运动算法和计时器方法// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n\r\nlet start = 0  // 开始时间\r\nlet begin = 0  // 开始奖品位置\r\nlet end = 23  // 终点位置，这里跑一圈\r\nlet during = 5000 // 运动总时间\r\n\r\n// 1000/60 ≈ 17，\r\n// 17毫秒即表示屏幕60帧刷新率每秒 ≈ requestAnimationFrame计数频率(一般情况)  \r\nconst steper = () => {\r\n  // left为位移距离\r\n  // 老虎机的运动位移是节点位移，不是精确位移\r\n  // 所以这里用parseInt处理，只取整数部分\r\n  // 数据变化为 0,1,2,3,4,5...23\r\n  // 间隔时间/距离由easeInOutQuart算法计算\r\n  var left = easeInOutQuart(start, begin, end, during);\r\n  let idx = parseInt(left)\r\n  start = start + 17; \r\n  if (idx <= end) {\r\n    let point = this.ret[idx] // 取节点位置信息\r\n    this.rect(point) // 绘制\r\n  }\r\n  \r\n  // 时间递增\r\n  if (start <= during) {\r\n    this.ctx.requestAnimationFrame(steper); // 计时器\r\n  } else {\r\n    // 动画结束，这里可以插入回调...\r\n    // callback()...\r\n  }\r\n};\r\n\r\nsteper(); // 启动\r\n复制代码以上为我的小程序水果老虎机的基本开发思路"}
{"title": "小程序后端 egg 框架开发记录 ", "author": "Rolan", "pub_time": "2020-2-16 00:21", "content": "内置对象Request & Response可以在 Context 的实例上获取到当前请求的 Request(\tctx.request ) 和 Response(\tctx.response ) 实例。ctx.response.body= 和\tctx.body= 是等价的。[!] 需要注意的是，获取 POST 的 body 应该使用\tctx.request.body ，而不是\tctx.bodyController框架提供了一个 Controller 基类，并推荐所有的\tController 都继承于该基类实现。这个 Controller 基类有下列属性:ctx - 当前请求的\tContext 实例。app - 应用的\tApplication 实例。config - 应用的\t配置 。service - 应用所有的\tservice 。logger - 为当前 controller 封装的 logger 对象。Service框架提供了一个 Service 基类，并推荐所有的\tService 都继承于该基类实现。\tService 基类的属性和 Controller 基类属性一致，访问方式也类似中间件编写中间件一个中间件是一个放置在\tapp/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数：options: 中间件的配置项，框架会将\tapp.config[${middlewareName}] 传递进来。app: 当前应用 Application 的实例。// app/middleware/error_handler.js\r\nmodule.exports = () => {\r\n  return async function errorHandler(ctx, next) {\r\n    try {\r\n      await next();\r\n    } catch (err) {\r\n      // 所有的异常都在 app 上触发一个 error 事件，框架会记录一条错误日志\r\n      ctx.app.emit('error', err, ctx);\r\n\r\n      const status = err.status || 500;\r\n      // 生产环境时 500 错误的详细错误内容不返回给客户端，因为可能包含敏感信息\r\n      const error = status === 500 && ctx.app.config.env === 'prod'\r\n        ? 'Internal Server Error'\r\n        : err.message;\r\n      // 从 error 对象上读出各个属性，设置到响应中\r\n\r\n      if (status === 422) {\r\n        ctx.body = { \r\n          code: ctx.ERROR_CODE, \r\n          data: error,\r\n          msg: '参数错误'+status\r\n         };\r\n      }\r\n      if (status === 500) {\r\n        ctx.body = { \r\n          code: 500, \r\n          data: '',\r\n          msg: '服务端错误-----'+error\r\n         };\r\n      }\r\n      ctx.status = 200;\r\n    }\r\n  };\r\n};复制代码使用在应用中使用中间件在应用中，我们可以完全通过配置来加载自定义的中间件，并决定它们的顺序。如果我们需要加载上面的 gzip 中间件，在\tconfig.default.js 中加入下面的配置就完成了中间件的开启和配置：// 加载 errorHandler 中间件\r\n  config.middleware = ['errorHandler']复制代码"}
{"title": "小程序对文件及后缀名解析 ", "author": "Rolan", "pub_time": "2020-2-16 00:25", "content": "小程序对文件及后缀名解析引用微信开放平台文档1、后缀：1.1、WXSS：样式文件（类似CSS）WXSS 具有\tCSS 大部分的特性，小程序在\tWXSS 也做了一些扩充和修改。新增了尺寸单位。在写\tCSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。\tWXSS 在底层支持新的尺寸单位\trpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。提供了全局的样式和局部样式。和前边\tapp.json ,\tpage.json 的概念相同，你可以写一个\tapp.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式\tpage.wxss 仅对当前页面生效。此外\tWXSS 仅支持部分\tCSS 选择器更详细的文档可以参考\tWXSS 。1.2、WXML：模板文件（类似HTML）从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中\tHTML 是用来描述当前这个页面的结构，\tCSS 用来描述页面的样子，\tJS 通常是用来处理这个页面和用户的交互。和\tHTML 非常相似，\tWXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：1.2.1、标签名字有点不一样往往写 HTML 的时候，经常会用到的标签是\tdiv ,\tp ,\tspan ，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。从上边的例子可以看到，小程序的\tWXML 用的标签是\tview ,\tbutton ,\ttext 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。1.2.2、多了一些\twx:if 这样的属性以及 {{ }} 这样的表达式在网页的一般开发流程中，我们通常会通过\tJS 操作\tDOM (对应\tHTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，\tJS 会记录一些状态到\tJS 变量里边，同时通过\tDOM API 操控\tDOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让\tJS 直接操控\tDOM ，\tJS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路，如果你需要把一个\tHello World 的字符串显示在界面上。WXML 是这么写 :<text>{{msg}}</text>JS 只需要管理状态即可:this.setData({ msg: \"Hello World\" })通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要\tif /\telse ,\tfor 等控制能力，在小程序里边，这些控制能力都用\twx: 开头的属性来表达。文档：\tWXML1.3、JS：一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写\tJS （JavaScript）脚本文件来处理用户的操作。<view>{{ msg }}</view>\r\n<button bindtap=\"clickMe\">点击我</button>点击\tbutton 按钮的时候，我们希望把界面上\tmsg 显示成\t\"Hello World\" ，于是我们在\tbutton 上声明一个属性:\tbindtap ，在 JS 文件里边声明了\tclickMe 方法来响应这次点击操作Page({\r\n  clickMe: function() {\r\n    this.setData({ msg: \"Hello World\" })\r\n  }\r\n})响应用户的操作就是这么简单，更详细的事件可以参考文档\tWXML - 事件 。此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在\tpages/index/index.js 就调用了\twx.getUserInfo 获取微信用户的头像和昵称，最后通过\tsetData 把获取到的信息显示到界面上。更多 API 可以参考文档\t小程序的API 。1.4、json：json数据类型，用于静态配置2、文件：2.1、小程序配置app.json：是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的\tapp.json 配置内容app.json的字段：pages字段—— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。window字段—— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。2.2、工具配置project.config.json：通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个\tproject.config.json ，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项参考文档：\t文档2.3、页面配置 page.json这里的\tpage.json 其实用来表示 pages/logs 目录下的\tlogs.json 这类和小程序页面相关的配置。如果你整个小程序的风格是蓝色调，那么你可以在\tapp.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了\tpage.json ，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。参考文档：\t文档"}
{"title": "开发小程序折叠面板 ", "author": "Rolan", "pub_time": "2020-2-16 00:41", "content": "参考了一系列的小程序UI库。。。，最后参考了ant-design的折叠面板(collapse)组件设计，功能大致如下支持默认展开动态设置标签栏动态设置内容支持无效状态支持切换响应方法戳源码构思折叠面板组件由列表组件(ui-list)实现，列表项作为标签页，列表项子元素 content 作为弹出层，数据子项结构大致如下{\r\n    title: '标签标题',\r\n    content: '弹层内容'\r\n}\r\n复制代码列表组件构建一个动态组件 ui-list ，通过配置文件实现列表结构，将如下这段数据结构const mockData = [\r\n  {title: '列表项1', content: '弹层内容1'},\r\n  {title: '列表项2', content: '弹层内容2'},\r\n  {title: '列表项3', content: '弹层内容3'},\r\n]\r\n复制代码生成大致如下的wxml<view class=\"list-container\">\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项1</view>\r\n      <view class=\"content\">弹层内容1</view>\r\n    </view>\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项2</view>\r\n      <view class=\"content\">弹层内容2</view>\r\n    </view>\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项3</view>\r\n      <view class=\"content\">弹层内容3</view>\r\n    </view>\r\n</view>\r\n复制代码通过css样式，将弹层内容 <view class=\"content\"> 隐藏交互设计弹出设计<view class='title'> 作为展示标签，也作为点击事件的主体，当点击标签时为 <view class='item'> 的子容器添加 active 激活样式，此时弹层内容通过样式设计为 display: block 状态，即实现弹出显示<view class=\"item active\">\r\n  <view class=\"title\" bind:tap=\"change\">列表项1</view>\r\n  <view class=\"content\">弹层内容1</view> <!--css display block-->\r\n</view>\r\n复制代码更新设计为标签点击时提供 changeTitle，changeContent 方法，通过关键字段寻址，并更新数据，从而更新wxml结构，如下列的思路<view class=\"title\" bind:tap=\"change\" data-index=\"1\">列表项1</view>\r\n复制代码change(e){\r\n  const ds = e...dataset\r\n  this.toggleActive(e)\r\n  this.changeTitle(ds, ...) // 或者 this.changeContent(e, ...)\r\n}\r\nchangeTitle(ds, param) {\r\n  let index = ds.index\r\n  let $data = findIt(index)\r\n  $data.title = param\r\n  this.setData({config.data[index]: ....})\r\n}\r\nchangeContent(ds, param) {\r\n  // 思路同changeTitle\r\n}\r\n复制代码上面所述是简化逻辑，实现起来并不如此简单，尤其是寻址逻辑和更新逻辑实现及应用wxml<ui-list wx:if=\"{{collapsConfig}}\" list=\"{{collapsConfig}}\" />\r\n复制代码jslet config = {\r\n  listClass: 'collapse-pad',\r\n  data: [],\r\n  tap: function(param){ // 切换响应方法，样式操作封装在组件内部   \r\n    // this.title({...})  \r\n    // this.content({...}) \r\n    // this.disabled(true|false)\r\n  }  \r\n}\r\n\r\nPage({\r\n  data: {\r\n    collapsConfig: config \r\n  }\r\n})\r\n复制代码关于动态标签的一点想法动态标签的好处是可以将逻辑、寻址等在JS部分来实现，相较于 template 语法，动态标签的方式灵活太多了，能方便的实现组件化、模块化，规范化，和将公共部分抽离，且易于维护。当一个项目有多人维护时，碎片模板是一个地狱。"}
{"title": "Taro 小程序开发大型实战：尝鲜微信小程序云 ", "author": "Rolan", "pub_time": "2020-2-19 00:37", "content": "欢迎继续阅读《Taro 小程序开发大型实战》系列，前情回顾：熟悉的 React，熟悉的 Hooks ：我们用 React 和 Hooks 实现了一个非常简单的添加帖子的原型多页面跳转和 Taro UI 组件库 ：我们用 Taro 自带的路由功能实现了多页面跳转，并用 Taro UI 组件库升级了应用界面实现微信和支付宝多端登录 ：实现了微信、支付宝以及普通登录和退出登录Hooks + Redux 双剑合璧 ：使用了 Hooks 版的 Redux 来重构应用的状态管理使用 Hooks 版的 Redux 实现大型应用状态管理（上篇） ：使用 Hooks 版的 Redux 实现了 user 逻辑的状态管理重构使用 Hooks 版的 Redux 实现大型应用状态管理（下篇） ：使用 Hooks 版的 Redux 实现了 post 逻辑的状态管理重构Taro 小程序开发大型实战（六）：尝鲜微信小程序云（上篇） ： user 逻辑接入微信小程序云在上一篇文章中，我们将我们两大逻辑之一 User 部分接入了 Redux 异步处理流程，接着接入了微信小程序云，使得 User 逻辑可以在云端永久保存，好不自在：），两兄弟一个得了好处，另外一个不能干瞪眼对吧？在这一篇教程中，我们想办法把 User 另外一个兄弟 Post 捞上来，也把 Redux 异步流程和微信小程序给它整上，这样就齐活了:laughing:。我们首先来看一看最终的完成效果：如果你不熟悉 Redux，推荐阅读我们的《Redux 包教包会》系列教程：Redux 包教包会（一）：解救 React 状态危机Redux 包教包会（二）：趁热打铁，完全重构Redux 包教包会（三）：各司其职，重拾初心如果你希望直接从这一步开始，请运行以下命令：git clone -b miniprogram-start https://github.com/tuture-dev/ultra-club.git\r\ncd ultra-club\r\n复制代码本文所涉及的源代码都放在了 Github 上，如果您觉得我们写得还不错，希望您能给 :heart:这篇文章点赞+Github仓库加星❤ ️哦~此教程属于 React 前端工程师学习路线 的一部分，欢迎来 Star 一波，鼓励我们继续创作出更好的教程，持续更新中~“六脉神剑” 搞定 createPost 异步逻辑不知道看到这里的读者有没有发现上篇文章其实打造了一套讲解模式，即按照如下的 “六步流程” 来讲解，我们也称为 “六脉神剑” 讲解法：sagas\r\nsagas\r\nsagas\r\nreducers\r\n可以看到我们上面的讲解顺序实际上是按照前端数据流的流动来进行的，我们对标上面的讲解逻辑来看一下前端数据流是如何流动的：从组件中通过对应的常量发起异步请求sagas 监听到对应的异步请求，开始处理流程在 sagas 调用对应的前端 API 文件向微信小程序云发起请求微信小程序云函数处理对应的 API 请求，返回数据sagas 中获取到对应的数据， dispatch action 到对应的 reducers 处理逻辑reducers 接收数据，开始更新本地 Redux Store 中的 state组件中重新渲染好的，了解了讲解逻辑和对应前端数据流动逻辑之后，我们马上来实践这套逻辑，把 User 逻辑的好兄弟 Post 逻辑搞定。第一剑： PostForm 组件中发起异步请求首先从创建帖子逻辑动刀子，我们将创建帖子接入异步逻辑并接通小程序云，让文章上云。打开 src/components/PostForm/index.jsx ，对其中的内容作出对应的修改如下：import { useDispatch, useSelector } from '@tarojs/redux'\r\n\r\nimport './index.scss'\r\nimport { CREATE_POST } from '../../constants'\r\n\r\nexport default function PostForm() {\r\n  const [formTitle, setFormTitle] = useState('')\r\n  const [formContent, setFormContent] = useState('')\r\n\r\n  const userId = useSelector(state => state.user.userId)\r\n\r\n  const dispatch = useDispatch()\r\n...    }\r\n\r\n    dispatch({\r\n      type: CREATE_POST,\r\n      payload: {\r\n        postData: {\r\n          title: formTitle,\r\n          content: formContent,\r\n        },\r\n        userId,\r\n      },\r\n    })\r\n\r\n    setFormTitle('')\r\n    setFormContent('')\r\n  }\r\n\r\n  return (\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们现在是接收用户的文章输入数据然后向小程序云发起创建文章的请求，所以我们将之前的 dispatch SET_POSTS Action 改为 CREATE_POST Action，并且将之前的 action payload 简化为 postData 和 userId ，因为我们可以通过小程序云数据库查询 userId 得到创建文章的用户信息，所以不需要再携带用户的数据。接着，因为我们不再需要用户的 avatar 和 nickName 数据，所以我们删掉了对应的 useSelector 语句。接着，因为请求是异步的，所以需要等待请求完成之后再设置对应的发表文章的状态以及发表文章弹出层状态，所以我们删掉了对应的 dispatch SET_POST_FORM_IS_OPENED Action 逻辑以及 Taro.atMessage 逻辑。最后我们删掉不需要的常量 SET_POSTS 和 SET_POST_FORM_IS_OPENED ，然后导入异步创建文章的常量 CREATE_POST 。增加 Action 常量我们在上一步中使用到了 CREATE_POST 常量，打开 src/constants/post.js ，在其中增加 CREATE_POST 常量：export const CREATE_POST = 'CREATE_POST'\r\n复制代码到这里，我们的 “六步流程” 讲解法就走完了第一步，即从组件中发起对应的异步请求，这里我们是发出的 action.type 为 CREATE_POST 的异步请求。第二剑： 声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 CREATE_POST 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。在 src/sagas/ 文件夹下面创建 post.js 文件，并在其中编写如下创建文章的逻辑：import Taro from '@tarojs/taro'\r\nimport { call, put, take, fork } from 'redux-saga/effects'\r\n\r\nimport { postApi } from '../api'\r\nimport {\r\n  CREATE_POST,\r\n  POST_SUCCESS,\r\n  POST_ERROR,\r\n  SET_POSTS,\r\n  SET_POST_FORM_IS_OPENED,\r\n} from '../constants'\r\n\r\nfunction* createPost(postData, userId) {\r\n  try {\r\n    const post = yield call(postApi.createPost, postData, userId)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起发帖成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 关闭发帖框弹出层\r\n    yield put({ type: SET_POST_FORM_IS_OPENED, payload: { isOpened: false } })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POSTS,\r\n      payload: {\r\n        posts: [post],\r\n      },\r\n    })\r\n\r\n    // 提示发帖成功\r\n    Taro.atMessage({\r\n      message: '发表文章成功',\r\n      type: 'success',\r\n    })\r\n  } catch (err) {\r\n    console.log('createPost ERR: ', err)\r\n\r\n    // 发帖失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n\r\n    // 提示发帖失败\r\n    Taro.atMessage({\r\n      message: '发表文章失败',\r\n      type: 'error',\r\n    })\r\n  }\r\n}\r\n\r\nfunction* watchCreatePost() {\r\n  while (true) {\r\n    const { payload } = yield take(CREATE_POST)\r\n\r\n    console.log('payload', payload)\r\n\r\n    yield fork(createPost, payload.postData, payload.userId)\r\n  }\r\n}\r\n\r\nexport { watchCreatePost }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchCreatePost ，它用来监听 action.type 为 CREATE_POST 的 action，并且当监听到 CREATE_POST action 之后，从这个 action 中获取必要的 postData 和 userId 数据，然后激活 handlerSaga ： createPost 去处理对应的创建帖子的逻辑。这里的 watcherSaga ： watchCreatePost 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 CREATE_POST action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 CREATE_POST action，获取 action 中携带的数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： createPost ，并将 payload.postData 和 payload.userId 作为参数传给 createPost 。创建 handlerSaga我们创建了创建帖子的 handlerSaga ： createPost ，它用来处理创建逻辑。createPost 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理创建帖子请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi.createPost ，并把 postData 和 userId 作为参数传给这个 API。如果创建帖子成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put类似之前在 view 中的 dispatch 操作，，来 dispatch 了三个 action： POST_SUCCESS ， SET_POST_FORM_IS_OPENED ， SET_POSTS ，代表更新创建帖子成功的状态，关闭发帖框，设置最新创建的帖子信息到 Redux Store 中。最后我们使用了 Taro UI 提供给我们的消息框，来显示一个 success 消息。如果发帖失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新创建帖子失败的信息到 Redux Store，接着使用了 Taro UI 提供给我们的消息框，来显示一个 error 消息。一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：POST_SUCCESS\r\nPOST_ERROR\r\nSET_POSTS\r\nCREATE_POST\r\nSET_POST_FORM_IS_OPENED\r\n这里的 POST_SUCCESS 和 POST_ERROR 我们还没有创建，我们将马上在 “下一剑” 中创建它。以及一些 redux-saga/effects 相关的 helper 函数，我们已经在之前的内容中详细讲过了，这里就不再赘述了。加入 saga 中心调度文件我们像之前将 watchLogin 等加入到 sagas 中心调度文件一样，将我们创建好的 watchCreatePost 也加入进去：// ...之前的逻辑\r\nimport { watchCreatePost } from './post'\r\nexport default function* rootSaga() {\r\n  yield all([\r\n   // ... 之前的逻辑\r\n    fork(watchCreatePost)\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件如下：export const POST_SUCCESS = 'POST_SUCCESS'\r\nexport const POST_ERROR = 'POST_ERROR'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi ，它里面封装了用于向后端（这里我们是小程序云）发起和帖子有关请求的逻辑，让我们马上来实现它吧。在 src/api/ 文件夹下添加 post.js 文件，并在文件中编写内容如下：import Taro from '@tarojs/taro'\r\n\r\nasync function createPost(postData, userId) {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  console.log('postData', postData, userId)\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'createPost',\r\n        data: {\r\n          postData,\r\n          userId,\r\n        },\r\n      })\r\n\r\n      return result.post\r\n    }\r\n  } catch (err) {\r\n    console.error('createPost ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  createPost,\r\n}\r\nexport default postApi;\r\n复制代码在上面的代码中，我们定义了 createPost 函数，它是一个 async 函数，用来处理异步逻辑，在 createPost 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行创建帖子的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 createPost 云函数，并将 postData 和 userId 作为参数传给云函数，用于在云函数中使用用户 Id 和帖子数据来创建一个属于此用户的帖子并保存到数据库，我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.post 数据。如果调用失败，则打印错误。最后我们定义了一个 postApi 对象，用于存放所有和用户逻辑有个的函数，并添加 createPost API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi.createPost 的方式来调用 createPost API 处理创建帖子的逻辑了。在 API 默认文件统一导出在 src/api/index.js 文件中导入上面创建的 postApi 并进行统一导出如下：import postApi from './post'\r\nexport { postApi }\r\n复制代码第五剑：创建对应的微信小程序云函数创建 createPost 云函数按照和之前创建 login 云函数类似，我们创建 createPost 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/createPost/package.json 文件，它和之前的类似。{\r\n  \"name\": \"createPost\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/createPost/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/createPost 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 createPost 云函数打开 functions/createPost/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const { postData, userId } = event\r\n\r\n  console.log('event', event)\r\n\r\n  try {\r\n    const user = await db\r\n      .collection('user')\r\n      .doc(userId)\r\n      .get()\r\n    const { _id } = await db.collection('post').add({\r\n      data: {\r\n        ...postData,\r\n        user: user.data,\r\n        createdAt: db.serverDate(),\r\n        updatedAt: db.serverDate(),\r\n      },\r\n    })\r\n\r\n    const newPost = await db\r\n      .collection('post')\r\n      .doc(_id)\r\n      .get()\r\n\r\n    return {\r\n      post: { ...newPost.data },\r\n    }\r\n  } catch (err) {\r\n    console.error(`createUser ERR: ${err}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下七处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，我们首先从 event 对象中取到了在小程序的调用 Taro.cloud.callFunction 传过来的 postData 和 userId 数据。然后，跟着取数据的是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们使用 db 的查询操作： db.collection('user').doc(userId).get() ，表示查询 id 为 userId 的 user 表数据，它查出来应该是个唯一值，如果不存在满足 where 条件的，那么是一个 null值，如果存在满足 条件的，那么返回一个 user 对象。接着，我们使用的 db.collection('post').add() 添加一个 post 数据，然后在 add 方法中传入 data 字段，这里我们不仅传入了 postData ，还将 user 也一同传入了，原因我们将在之后来讲解。除此之外，这里我们额外使用了 db.serverDate() 用于记录创建此帖子的时间和更新此帖子的时间，方便之后做条件查询。接着，因为向数据库添加一个记录之后只会返回此记录的 _id ，所以我们需要一个额外的操作 db.collection('post').doc() 来获取此条记录，这个 doc 用于获取指定的记录引用，返回的是这条数据，而不是一个数组。最后我们返回新创建的 post 。提示我们在上面创建 post 的时候，将 user 对象也添加到了 post 数据中，这里是因为小程序云数据库是 JSON 数据库,所以没有关系数据库的外键概念,导致建关系困难,所以为了之后查询 post 的时候方便展示 user 数据，我们才这样保存的. 当然更加科学的做法是在 post 里面保存 userId ，这样能减少数据冗余，但是因为做教学用，所以这些我们偷了一点懒。所以我们这里强烈建议,在正规的环境下，关系型数据库应该建外键，JSON 数据库也至少应该保存 userId 。:第六剑： 定义对应的 reducers 文件我们在前面处理创建帖子时，在组件内部 dispatch 了 CREATE_POST action，在处理异步 action 的 saga 函数中，使用 put 发起了一系列更新 store 中帖子状态的 action，现在我们马上来实现响应这些 action 的 reducers ，打开 src/reducers/post.js ，对其中的代码做出对应的修改如下：import {\r\n  SET_POST,\r\n  SET_POSTS,\r\n  SET_POST_FORM_IS_OPENED,\r\n  POST_ERROR,\r\n  CREATE_POST,\r\n  POST_NORMAL,\r\n  POST_SUCCESS,\r\n} from '../constants/'\r\n\r\nimport avatar from '../images/avatar.png'\r\n\r\nconst INITIAL_STATE = {\r\n  posts: [],\r\n  post: {},\r\n  isOpened: false,\r\n  isPost: false,\r\n  postStatus: POST_NORMAL,\r\n}\r\n\r\nexport default function post(state = INITIAL_STATE, action) {\r\n  switch (action.type) {\r\n    case SET_POST: {\r\n      const { post } = action.payload\r\n      return { ...state, post }\r\n    }\r\n\r\n    case SET_POSTS: {\r\n      const { posts } = action.payload\r\n      return { ...state, posts: state.posts.concat(...posts) }\r\n    }\r\n\r\n    case SET_POST_FORM_IS_OPENED: {...      return { ...state, isOpened }\r\n    }\r\n\r\n    case CREATE_POST: {\r\n      return { ...state, postStatus: CREATE_POST, isPost: true }\r\n    }\r\n\r\n    case POST_SUCCESS: {\r\n      return { ...state, postStatus: POST_SUCCESS, isPost: false }\r\n    }\r\n\r\n    case POST_ERROR: {\r\n      return { ...state, postStatus: POST_ERROR, isPost: false }\r\n    }\r\n\r\n    default:\r\n      return state\r\n  }\r\n复制代码看一看到上面的代码主要有三处改动：首先我们导入了必要的 action 常量接着我们给 INITIAL_STATE 增加了几个字段：posts\r\npost\r\nisPost ：用于标志帖子逻辑过程中是否在执行创帖逻辑， true 表示正在执行创帖中， false 表示登录逻辑执行完毕postStatus ：用于标志创帖过程中的状态：开始创帖（ CREATE_POST ）、创帖成功（ POST_SUCCESS ）、登录失败（ POST_ERROR ）最后就是 switch 语句中响应 action，更新相应的状态。“六脉神剑” 搞定 getPosts 异步逻辑在上一 “大” 节中，我们使用了图雀社区不传之术：“六脉神剑” 搞定了 createPost 的异步逻辑，现在我们马上趁热打铁来巩固我们的武功，搞定 getPosts 异步逻辑，它对应着我们小程序底部两个 tab 栏的第一个，也就是我们打开小程序的首屏渲染逻辑，也就是一个帖子列表。第一剑： index 组件中发起异步请求打开 src/pages/index/index.jsx 文件，对其中的内容作出对应的修改如下：import { PostCard, PostForm } from '../../components'\r\nimport './index.scss'\r\nimport {\r\n  SET_POST_FORM_IS_OPENED,\r\n  SET_LOGIN_INFO,\r\n  GET_POSTS,\r\n} from '../../constants'\r\n\r\nexport default function Index() {\r\n  const posts = useSelector(state => state.post.posts) || []...  const dispatch = useDispatch()\r\n\r\n  useEffect(() => {\r\n    const WeappEnv = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n\r\n    if (WeappEnv) {\r\n      Taro.cloud.init()\r\n    }\r\n\r\n    async function getStorage() {\r\n      try {\r\n        const { data } = await Taro.getStorage({ key: 'userInfo' })\r\n\r\n        const { nickName, avatar, _id } = data\r\n\r\n        // 更新 Redux Store 数据\r\n        dispatch({\r\n          type: SET_LOGIN_INFO,\r\n          payload: { nickName, avatar, userId: _id },\r\n        })\r\n      } catch (err) {\r\n        console.log('getStorage ERR: ', err)\r\n      }\r\n    }\r\n\r\n    if (!isLogged) {\r\n      getStorage()\r\n    }\r\n\r\n    async function getPosts() {\r\n      try {\r\n        // 更新 Redux Store 数据\r\n        dispatch({\r\n          type: GET_POSTS,\r\n        })\r\n      } catch (err) {\r\n        console.log('getPosts ERR: ', err)\r\n      }\r\n    }\r\n\r\n    if (!posts.length) {\r\n      getPosts()\r\n    }\r\n  }, [])\r\n\r\n  function setIsOpened(isOpened) {\r\n    dispatch({ type: SET_POST_FORM_IS_OPENED, payload: { isOpened } })...  return (\r\n    <View className=\"index\">\r\n      <AtMessage />\r\n      {posts.map(post => (\r\n        <PostCard key={post._id} postId={post._id} post={post} isList />\r\n      ))}\r\n      <AtFloatLayout\r\n        isOpened={isOpened}\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们对当前的开发环境做了判断，如果是微信小程序环境，我们就使用 Taro.cloud.init() 进行小程序环境的初始化。接着，我们在 useEffects Hooks 里面定义了 getPosts 函数，它是一个异步函数，用于 dispatch GET_POSTS 的异步请求，并且我们进行了判断，当此时 Redux Store 内部没有文章时，才进行数据的获取。接着，我们改进了 getStorage 获取缓存的函数，将其移动到 useEffects Hooks 里面，并额外增加了 _id 属性，它被赋值给 userId 一起设置 Redux Store 中关于用户的属性，这样做的目的主要是为了之后发帖标志用户，或者获取用户的个人信息用。并且，加了一层 if 判断，只有当没有登录时，即 isLogged 为 false 的时候，才进行获取缓存操作。最后我们导入了必要的 GET_POSTS 常量，并且将 return 语句里的 PostCard 接收的 key 和 postId 属性变成了真实的帖子 _id 。这样我们在帖子详情时可以直接拿 postId 向小程序云发起异步请求。注意在上一篇教程中，有同学提到没有使用 Taro.cloud.init() 初始化的问题，是因为分成了两篇文章，在这篇文章才初始化。要使用小程序云，初始化环境是必要的。第二剑：声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 GET_POSTS 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。打开 src/sagas/post.js 文件，在其中定义 getPosts sagas 逻辑如下：import {\r\n  GET_POSTS,\r\n} from '../constants'\r\n\r\nfunction* getPosts() {\r\n  try {\r\n    const posts = yield call(postApi.getPosts)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起获取帖子成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POSTS,\r\n      payload: {\r\n        posts,\r\n      },\r\n    })\r\n  } catch (err) {\r\n    console.log('getPosts ERR: ', err)\r\n\r\n    // 获取帖子失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n  }\r\n}\r\nfunction* watchGetPosts() {\r\n  while (true) {\r\n    yield take(GET_POSTS)\r\n\r\n    yield fork(getPosts)\r\n  }\r\n}\r\n\r\nexport { watchGetPosts }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchGetPosts ，它用来监听 action.type 为 GET_POSTS的 action，并且当监听到 GET_POSTS action 之后，然后激活 handlerSaga ： getPosts 去处理对应的获取帖子列表的逻辑。这里的 watcherSaga ： watchGetPosts 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 GET_POSTS action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 GET_POSTS action，获取 action 中携带的数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： getPosts ，因为这里获取帖子列表不需要传数据，所以这里没有额外的数据传递逻辑。创建 handlerSaga我们创建了创建帖子的 handlerSaga ： getPosts ，它用来处理创建逻辑。getPosts 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理获取帖子列表请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi. getPosts 。如果获取帖子列表成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put 类似之前在 view 中的 dispatch 操作，，来 dispatch 了两个 action： POST_SUCCESS ， SET_POSTS ，代表更新获取帖子列表成功的状态，设置最新获取的帖子列表到 Redux Store 中。如果获取帖子列表失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新获取帖子列表失败的信息到 Redux Store一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi. getPosts ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：GET_POSTS ：响应获取帖子列表的 ACTION 常量，我们将在 “第三剑” 中创建它。加入 saga 中心调度文件我们像之前将 watchCreatePost 等加入到 sagas 中心调度文件一样，将我们创建好的 watchGetPosts 也加入进去：// ...之前的逻辑\r\nimport { watchGetPosts } from './post'\r\nexport default function* rootSaga() {\r\n  yield all([\r\n   // ... 之前的逻辑\r\n    fork(watchGetPosts)\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件如下：export const GET_POSTS = 'GET_POSTS'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi.getPosts ，它里面封装了用于向后端（这里我们是小程序云）发起和获取帖子列表有关请求的逻辑，让我们马上来实现它吧。打开 src/api/post.js 文件，并在其中编写内容如下：// ... 其余逻辑一样\r\nasync function getPosts() {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'getPosts',\r\n      })\r\n\r\n      return result.posts\r\n    }\r\n  } catch (err) {\r\n    console.error('getPosts ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  // ... 之前的 API\r\n  getPosts,\r\n}\r\n\r\n// ... 其余逻辑一样\r\n复制代码在上面的代码中，我们定义了 getPosts 函数，它是一个 async 函数，用来处理异步逻辑，在 getPosts 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行获取帖子列表的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 getPosts 云函数，我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.posts数据，即从小程序云返回的帖子列表。如果调用失败，则打印错误。最后我们在已经定义好的 postApi 对象里，添加 getPosts API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi. getPosts 的方式来调用 getPosts API 处理获取帖子列表的逻辑了。第五剑：创建对应的微信小程序云函数创建 getPosts 云函数按照和之前创建 createPost 云函数类似，我们创建 getPosts 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/getPosts/package.json 文件，它和之前的类似。{\r\n  \"name\": \"getPosts\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/getPosts/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/getPosts 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 getPosts 云函数打开 functions/getPosts/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\nconst _ = db.command\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  try {\r\n    const { data } = await db.collection('post').get()\r\n\r\n    return {\r\n      posts: data,\r\n    }\r\n  } catch (e) {\r\n    console.error(`getPosts ERR: ${e}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，里面是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们使用 db 的查询操作： db.collection('post').get() ，表示查询所有的 post 数据。最后我们返回查询到的 posts 数据。第六剑： 定义对应的 reducers 文件因为这里 SET_POSTS 的 Action 我们在上一 “大” 节中创建帖子时已经定义了，所有在 “这一剑” 中我们无需添加额外的代码，复用之前的逻辑就好。“六脉神剑” 搞定 getPost 异步逻辑在上面两 “大” 节中，我们连续用了两次 “六脉神剑”，相信跟到这里的同学应该对我们接下来要做的事情已经轻车熟路了吧:grin:。接下来，我们将收尾 Post 逻辑的最后一公里，即帖子详情的异步逻辑 “getPost” 接入，话不多说就是干！第一剑： post 组件中发起异步请求打开 src/pages/post/post.jsx 文件，对其中的内容作出对应的修改如下：import Taro, { useRouter, useEffect } from '@tarojs/taro'\r\nimport { View } from '@tarojs/components'\r\nimport { useDispatch, useSelector } from '@tarojs/redux'\r\n\r\nimport { PostCard } from '../../components'\r\nimport './post.scss'\r\nimport { GET_POST, SET_POST } from '../../constants'\r\n\r\nexport default function Post() {\r\n  const router = useRouter()\r\n  const { postId } = router.params\r\n\r\n  const dispatch = useDispatch()\r\n  const post = useSelector(state => state.post.post)\r\n\r\n  useEffect(() => {\r\n    dispatch({\r\n      type: GET_POST,\r\n      payload: {\r\n        postId,\r\n      },\r\n    })\r\n\r\n    return () => {\r\n      dispatch({ type: SET_POST, payload: { post: {} } })\r\n    }\r\n  }, [])\r\n\r\n  return (\r\n    <View className=\"post\">\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们使用 useDispatch Hooks 获取到了 dispatch 函数。接着，在 useEffects Hooks 里面定义了 dispatch 了 action.type 为 GET_POST 的 action，它是一个异步 Action，并且我们在 Hooks 最后返回了一个函数，其中的内容为将 post 设置为空对象，这里用到的 SET_POST 常量我们将在后面定义它。这个返回函数主要用于 post 组件卸载之后，Redux Store 数据的重置，避免下次打开帖子详情还会渲染之前获取到的帖子数据。接着，我们使用 useSelector Hooks 来获取异步请求到的 post 数据，并用于 return 语句中的数据渲染。最后我们删除了不必要的获取 posts 数据的 useSelector Hooks，以及删掉了不必要的调试 console.log 语句。第二剑： 声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 GET_POST 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。打开 src/sagas/post.js 文件，在其中定义 getPosts sagas 逻辑如下：// ... 和之前的逻辑一样\r\nimport {\r\n  // ... 和之前的逻辑一样\r\n  SET_POST,\r\n} from '../constants';\r\n\r\n  // ... 和之前的逻辑一样\r\n\r\nfunction* getPost(postId) {\r\n  try {\r\n    const post = yield call(postApi.getPost, postId)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起获取帖子成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POST,\r\n      payload: {\r\n        post,\r\n      },\r\n    })\r\n  } catch (err) {\r\n    console.log('getPost ERR: ', err)\r\n\r\n    // 获取帖子失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n  }\r\n}\r\nfunction* watchGetPost() {\r\n  while (true) {\r\n    const { payload } = yield take(GET_POST)\r\n\r\n    yield fork(getPost, payload.postId)\r\n  }\r\n}\r\n\r\nexport { watchGetPost }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchGetPost ，它用来监听 action.type 为 GET_POST的 action，并且当监听到 GET_POST action 之后，然后激活 handlerSaga ： getPost 去处理对应的获取单个帖子的逻辑。这里的 watcherSaga ： watchGetPost 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 GET_POST action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 GET_POST action，获取 action 中携带的数据，这里我们拿到了传过来的 payload 数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： getPost ，并传入了获取到 payload.postId 参数。创建 handlerSaga我们创建了获取单个帖子的 handlerSaga ： getPost ，它用来处理获取帖子逻辑。getPost 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理获取单个帖子请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi. getPost 。如果获取单个帖子成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put 类似之前在 view 中的 dispatch 操作，，来 dispatch 了两个 action： POST_SUCCESS ， SET_POSTS ，代表更新获取单个帖子成功的状态，设置最新获取的帖子到 Redux Store 中。如果获取单个帖子失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新获取单个帖子失败的信息到 Redux Store一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi.getPost ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：SET_POST ：响应获取帖子列表的 ACTION 常量，我们将在 “第三剑” 中创建它加入 saga 中心调度文件我们像之前将 watchGetPosts 等加入到 sagas 中心调度文件一样，将我们创建好的 watchGetPost 也加入进去：打开 src/sagas/index.js 文件，对其中的内容作出如下的修改：import { fork, all } from 'redux-saga/effects'\r\n\r\nimport { watchLogin } from './user'\r\nimport { watchCreatePost, watchGetPosts, watchGetPost } from './post'\r\n\r\nexport default function* rootSaga() {\r\n  yield all([\r\n    fork(watchLogin),\r\n    fork(watchCreatePost),\r\n    fork(watchGetPosts),\r\n    fork(watchGetPost),\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件 GET_POST ：export const SET_POST = 'SET_POST'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi.getPost ，它里面封装了用于向后端（这里我们是小程序云）发起和获取单个帖子有关请求的逻辑，让我们马上来实现它吧。打开 src/api/post.js 文件，并在其中编写内容如下：// ... 其他内容和之前一致\r\nasync function getPost(postId) {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'getPost',\r\n        data: {\r\n          postId,\r\n        },\r\n      })\r\n\r\n      return result.post\r\n    }\r\n  } catch (err) {\r\n    console.error('getPost ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  getPost,\r\n}\r\nexport default postApi\r\n复制代码可以看到上面的代码有如下六处改动：在上面的代码中，我们定义了 getPost 函数，它是一个 async 函数，用来处理异步逻辑，在 getPost 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行获取单个帖子的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 getPost 云函数，并给它传递了对应要获取的帖子的 postId 我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.post数据，即从小程序云返回的单个帖子。如果调用失败，则打印错误。最后我们在已经定义好的 postApi 对象里，添加 getPost API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi. getPost 的方式来调用 getPostAPI 处理获取单个帖子的逻辑了。第五剑：创建对应的微信小程序云函数创建 getPost 云函数按照和之前创建 getPosts 云函数类似，我们创建 getPost 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/getPost/package.json 文件，它和之前的类似。{\r\n  \"name\": \"getPost\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/getPost/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/getPost 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 getPost 云函数打开 functions/getPost/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const { postId } = event\r\n\r\n  try {\r\n    const { data } = await db\r\n      .collection('post')\r\n      .doc(postId)\r\n      .get()\r\n\r\n    return {\r\n      post: data,\r\n    }\r\n  } catch (e) {\r\n    console.error(`getPost ERR: ${e}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，里面是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们首先从 event 对象里面获取到了 postId ，接着我们使用 db 的查询操作： db.collection('post').doc(postId).get() ，表示查询所有的对应 _id 为 postId 的单个帖子数据最后我们返回查询到的 post 数据。第六剑： 定义对应的 reducers 文件因为这里 SET_POST 的 Action 我们在上上 “大” 节中创建帖子时已经定义了，所有在 “这一剑” 中我们无需添加额外的代码，复用之前的逻辑就好。小结在这篇教程中，我们连续使用了三次 “六脉神剑” 讲完了我们的 Post 逻辑的异步流程，让我们再来复习一下我们开头提到的 “六脉神剑”：sagas\r\nsagas\r\nsagas\r\nreducers\r\n这是一套讲解模式，也是一套写代码的最佳实践方式之一，希望你能受用。"}
{"title": "小白如何自己亲手制作一个防疫地图？ ", "author": "Rolan", "pub_time": "2020-2-20 00:22", "content": "最近出了好几个小程序可以查看你周边地区当前疫情确诊人数的情况，就比如下面这种的：这张图对于身为小白的我们可不可以自己做一个呢？答案当然是肯定的，这里面涉及到的技术点就是地图上的那些点是如何标记出来的。这里的地图我们使用腾讯地图来实现，首先进入到腾讯位置服务的首页（ https://lbs.qq.com/index.html ），进行登录操作，用 QQ 也好微信也好，反正先登录上去。然后在控制台中新建一个 key ，这个 key 是专属于你一个人使用的，所以千万不要外传哦~~~这里我们新建一个专门用于本次疫情地图的 key ，名称输入完成后，再输入验证码点击提交即可，这时会弹出来了一个让你去设置 key 的提示。这里我们就获得了自己的 key （小编已删除此 key ，请不要直接使用小编所创建的 key），点击设置进入设置页面：可以看到，这里可以设置这个 key 所应用的茶品，默认是 JavaScriptAPI ，我们还可以在微信小程序、APP、或者 WebServiceAPI（服务器调用） 中使用。这里其实不需要多余的设置，直接点击保存即可。我们本次示例所使用到的功能都是最基础的功能。key 设置完成后我们看一下腾讯地图的 API ，这里主要是看 JavaScript API ，链接：https://lbs.qq.com/javascript_v2/index.html 。我们本次要用到的功能是覆盖物，其他的感兴趣的同学可以看一看，不感兴趣的同学可以直接略过，点开覆盖物查看今天的正题。直接看代码好没意思，点击查看示例，可以一边看示例，一边看代码，顺手改改，看看能不能正常运行。点击查看示例以后，就变成下面这个样子了：这里可以看到他的中心点是在北京，实际上是由这段代码来指定的：    var center = new qq.maps.LatLng(39.916527,116.397128);\r\n    var map = new qq.maps.Map(document.getElementById('container'),{\r\n        center: center,\r\n        zoom: 13\r\n    });如果小编这里要改成上海的话只需要修改这里的坐标值即可，那么上海的坐标值我能去哪里查找呢？别急，这里就要说到今天会用到的另一个功能点，坐标拾取器，腾讯也提供了这样的服务，链接为：https://lbs.qq.com/tool/getpoint/index.html ，他是长这个样子的：比如小编这里将地图的中心点改成人民广场地铁站，那么直接将上面的坐标 Copy 出来，放在刚才的代码中再执行一下，就可以看到当前的地图中心点编程了人民广场。那么，接下来的事情就好办了，我们只需要知道附近的疫情的数据，将这些有疫情的区域全都标记在地图上就好了，小编这里就不查真实的疫情情况了，随便在地图上取几个点做演示。结果就变成了这样：接下来问题来了，我们看到的地图上的标记好像图形和这个不一样嘛，这个长得也有点忒丑了点，当然，腾讯地图给我们提供的 API 同样支持自定义的 icon ，示例如下：emmmmmmmmmmm，手头没有找到好看一点的 icon ，随便找了一张代替，大家理解到位就好。只要我们替换上合适的 icon ，就可以做出和文章最前面那个小程序一样漂亮的疫情地图了。最后的没有替换 icon 的代码小编还是顺手贴一下吧：<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"/>\r\n<title>疫情地图</title>\r\n<script charset=\"utf-8\" src=\"https://map.qq.com/api/js?v=2.exp&key=你的key\"></script>\r\n<style type=\"text/css\">\r\n*{\r\n    margin:0px;\r\n    padding:0px;\r\n}\r\nbody, button, input, select, textarea {\r\n    font: 12px/16px Verdana, Helvetica, Arial, sans-serif;\r\n}\r\n#info{\r\n    width:603px;\r\n    padding-top:3px;\r\n    overflow:hidden;\r\n}\r\n.btn{\r\n    width:112px;\r\n}\r\n#container{\r\n    min-width:600px;\r\n    min-height:767px;\r\n}\r\n</style>\r\n<script>\r\nvar init = function() {\r\n    var center = new qq.maps.LatLng(31.232708,121.475537);\r\n    var map = new qq.maps.Map(document.getElementById('container'),{\r\n        center: center,\r\n        zoom: 13\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.232105,121.481667),\r\n        map: map\r\n    });\r\n    \r\n  \r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.235114,121.471281),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.227261,121.480465),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.226821,121.471796),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.216545,121.467419),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.216839,121.480808),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.218454,121.492825),\r\n        map: map\r\n    });\r\n    \r\n}\r\n</script>\r\n</head>\r\n<body onload=\"init()\">\r\n<div id=\"container\"></div>\r\n</body>\r\n</html>\r\n这里只需要替换一个可用的 key 即可使用。到这里，你可以把所有已经有确诊患者小区的经纬度获取到，然后全部标注到地图上，每天对标注进行实时更新，这样就制作成了一张防疫地图了，有兴趣的同学可以自己去尝试尝试。实际上腾讯地图上还有很多很好玩的同时也很炫酷的功能，如以下图形：大家可以自己去探索。"}
{"title": "小程序摸爬滚打之路 ", "author": "Rolan", "pub_time": "2020-1-10 00:12", "content": "上面这张图相信接触过小程序的开发者多多少少都有看到过，小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。那么为什么要这样设计呢，为了管控和安全，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。2.双线程之间的通信既然小程序的模型是双线程模型，那么是如何实现双线程之间的通信呢，由上图可以看出，逻辑层和视图层是通过Native层来进行转发的，这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现，类似于虚拟DOM的实现，用JS对象模拟DOM树，然后进行diff,然后把差异在视图层进行渲染，这一系列在Native之间的转化则由小程序的基础库来完成。3.组件系统--Exparser框架Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。当前Web Component已经支持局部作用域、slot插槽等等现有框架所提供的组件化方法，学习Web Component也是我接下来自己学习的目标之一 Orz 。4.setData干了些什么小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。5.运行机制小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。小程序开发日常问题1.wx.request()的promise化小程序框架自带的网络请求和Ajax请求非常相似都是异步请求，请求参数中需要送入url、method、data、header等参数，还要设置success成功的回调函数和fail失败的回调函数，如下图所示通过回调函数处理就很容易造成回调地狱，所以Promise化还是很有必要的class request {\r\n  constructor() {\r\n    this._baseUrl = 'https://xxx.com/api';\r\n    this._token = wx.getStorageSync('token');\r\n    this._header = {}\r\n  }\r\n\r\n  /**\r\n   * GET类型的网络请求\r\n   */\r\n  getRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'GET')\r\n  }\r\n\r\n  /**\r\n   * DELETE类型的网络请求\r\n   */\r\n  deleteRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'DELETE')\r\n  }\r\n\r\n  /**\r\n   * PUT类型的网络请求\r\n   */\r\n  putRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'PUT')\r\n  }\r\n\r\n  /**\r\n   * POST类型的网络请求\r\n   */\r\n  postRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'POST')\r\n  }\r\n  \r\n  requestAll(url, data, header, method) {\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: this._baseUrl + url,\r\n        data: data,\r\n        header: header,\r\n        method: method,\r\n        success: (res => {\r\n          if (res.statusCode === 200) {\r\n            resolve(res)\r\n          } else {\r\n            //其它错误，提示用户错误信息\r\n            reject(res)\r\n          }\r\n        }),\r\n        fail: (res => {\r\n          reject(res)\r\n        })\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\nexport default request\r\n复制代码2.小程序的WXS在小程序的日常开发中大家肯定会遇到需要对数据进行过滤转义的场景，而微信小程序没有像Vue一样的filter过滤器功能，大多数人会在渲染之前对数据进行一次清洗，而WXS就是为了解决这一痛点什么是WXS是小程序出的一套脚本语言，用于 wxml 模板文件中，在模板文件中可以完成页面的结构。不依赖于运行时的基础库脚本，可以在所有版本的小程序中运行。WXS 中不能调用 javascript 中定义的函数或者变量，也不能调用小程序提供的 API，他的运行环境和 javascript 是隔离的。小程序的条件渲染和循环渲染对 WXS 是无效的，就是说如果 WXS 代码包裹在未渲染的代码中，只要渲染的 wxml 部分调用了此模块，此段 WXS 代码依然会被加载。由于运行环境的差异，在 ios 设备上小程序的 WXS 会比 javascript 快 2~20 倍，在 android 设备上运行效率无异。模块想要暴露自己的私有变量和方法，只能通过 module.exports 实现。 若在模块中想要引用其他模块，只能通过 require 实现。只能使用 var 来定义变量，表现形式和 javascript 一样，会有变量提升。WXS 模块只能在定义模块的 wxml 文件中被访问到，使用 或 时，WXS 模块不会被引入到对应的 wxml 文件中。不能使用 new Date() 应该使用 getDate() 。WXS最常见的用处可能就是实现一个过滤器，如下所示<wxs module=\"filter\">\r\n    function getFullPath(url) {\r\n        return \"https://shiyuanjieyi.cn\" + url\r\n    }\r\n    module.exports.getFullPath = getFullPath\r\n</wxs>\r\n<image src=\"{{filter.getFullPath(url)}}\"></image>\r\n复制代码"}
{"title": "如何处理小程序独立分包的数据共享问题 ", "author": "Rolan", "pub_time": "2020-1-10 00:55", "content": "小程序2.3.0版本开始支持独立分包。对于短期的活动落地页，我们会选择使用独立分包，这可以大大提升活动落地页的加载速度。\r\n但与此同时，由于独立分包中不能依赖主包和其他分包中的内容，独立分包的使用也带来了一些数据共享问题。\r\n遇到的问题\r\n公用数据处理复杂\r\n对于页面间的公用数据，我们原本的处理方式是将数据挂在App对象上。但引入了独立分包后，判断的逻辑就变得复杂了。\r\n例如，我们想设计一个计数器counter，能够在小程序的各个地方调用。我们将结果记录在app.globalData.count，这时候需要分三种场景考虑：\r\n\r\n主包和普通分包页面中，通过getApp()来获取App对象;\r\n在App对象中，通过this来获取App对象;\r\n在独立分包或App对象注册前，通过getApp({ allowDefault: true })来获取App对象（新的逻辑）;\r\n\r\n另外，对于3的情况，由于App对象可能未初始化，还要判断globalData、count属性是否存在。\r\n事件被重复绑定\r\n通过wx.onError、wx.onPageNotFound等方法可以监控小程序的运行情况，我们把这些能力封装在npm包中。\r\nexport function report() {\r\n  // 各种处理逻辑\r\n  // ....\r\n}\r\n\r\nwx.onError(report);\r\n复制代码当独立分包和主包都引入了这个npm包，而npm包中调用wx.onXXXX方法进行了绑定，我们可以想到，当用户在独立分包和主包页面之间跳转时，事件的处理函数会被绑定不止一次（主包一次，每个独立分包一次）。\r\n解决思路\r\n\r\n\r\n对于需要在主包、独立分包公用数据的情况，我们考虑将不同场景下读写app对象的能力封装起来，这类似于一个SessionStorage，我们可以在任意场景操作SessionStorage里的公用数据，而数据会在小程序从冷启动到销毁的运行过程中一直保留。\r\n\r\n\r\n对于事件重复绑定的问题，我们使用sessionStorage中的一个key来加锁。实现一个once方法，保证同一个key的逻辑只执行一次，通过如下的方式来调用\r\nexport function report() {\r\n  // 各种处理逻辑\r\n  // ....\r\n}\r\n\r\nonce('_wx_onerror_key_', () => { wx.onError(report); });\r\n复制代码\r\n\r\n具体实现\r\n\r\n为了不与原有的globalData冲突，我们使用一个新的BASIC_KEY，作为App对象上的属性名，来存储sessionStorage的内容。\r\n默认以getApp({ allowDefault: true })获取App对象，为了满足在App()内调用时也能取到正确的App对象，我们可以在App.onLaunch方法时将this传入sessionStorage.setApp(this)。\r\n暴露的api对齐浏览器的sessionStorage，实现如下：\r\n\r\nconst BASIC_KEY = '_imwxutils_sessionStorageData_';\r\nlet app = getApp({ allowDefault: true }) || {};\r\napp[BASIC_KEY] = app[BASIC_KEY] || {};\r\n\r\nexport function setApp(customApp) {\r\n  customApp[BASIC_KEY] = customApp[BASIC_KEY] || app[BASIC_KEY] || {};\r\n  app = customApp;\r\n}\r\n\r\nexport function setItem(key, value) {\r\n  app[BASIC_KEY][key] = value;\r\n}\r\n\r\nexport function getItem(key) {\r\n  return app[BASIC_KEY][key];\r\n}\r\n\r\nexport function removeItem(key) {\r\n  app[BASIC_KEY][key] = null;\r\n}\r\n\r\nexport function clear() {\r\n  app[BASIC_KEY] = {};\r\n}\r\n\r\n复制代码基于sessionStorage我们又可以实现once方法：\r\nimport * as sessionStorage from './session-storage';\r\n\r\nconst ONCE_BASIC_KEY = '_imwxutils_once_record_';\r\n/**\r\n * 全局只执行一次的方法\r\n */\r\nfunction once(key, func) {\r\n  if (!key) {\r\n    return;\r\n  }\r\n  const record = sessionStorage.getItem(ONCE_BASIC_KEY) || {};\r\n\r\n  if (record[key]) { // 之前执行过了\r\n    return;\r\n  }\r\n  record[key] = true;\r\n  sessionStorage.setItem(ONCE_BASIC_KEY, record);\r\n  func();\r\n}\r\n复制代码\r\n以上，通过实现sessionStorage和once方法，我们解决了独立分包与主包之间数据共享以及事件绑重复定的问题。\r\n欢迎交流"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "小程序 - 自定义导航栏重要步骤 ", "author": "Rolan", "pub_time": "2019-10-21 00:09", "content": "几个要点：statusBarHeight ，用来获取手机状态栏的高度()，调用 wx.getSystemInfo 获取还有注意的，在写样式距离和大小时建议都用px，因小程序右边的胶囊也是用的px，不是rpx。wx.getMenuButtonBoundingClientRect() 获取胶囊信息，用来计算 导航栏高度单个页面配置自定义导航，记得把基础库 调节到 2.8.0 之上, 仅支持 微信客户端7.0.0 向上官方链接：自定义导航页面配置：navigationStyle状态栏高度 wx.getSystemInfo()胶囊 wx.getMenuButtonBoundingClientRect()根据需求来设计（可以计算各种高度）wx.getSystemInfo --> res.statusBarHeight\r\n胶囊高度 + ( 胶囊距离顶部距离 - 状态栏高度) * 2\r\ndata：{\r\n        statusHeight: 0,  //状态栏高度\r\n        navHeight: 0      //导航栏高度\r\n    }\r\n    /**\r\n     * 获取状态栏|导航栏高度,\r\n     */\r\n    getStatusBarHeight: function(){\r\n        let capsule = wx.getMenuButtonBoundingClientRect() ; //胶囊信息\r\n        wx.getSystemInfo({\r\n            success(res) {\r\n                that.setData({\r\n                    statusHeight: res.statusBarHeight,\r\n                    navHeight: capsule.height + (capsule.top - res.statusBarHeight) * 2\r\n                })\r\n            }\r\n        })\r\n      \r\n    },\r\n复制代码<view class=\"status-height\" style=\"height:{{ statusHeight }}px\">  //状态栏\r\n    cc\r\n</view>\r\n<view class=\"nav-height\"  style=\"height:{{ navHeight }}px\">       //导航栏\r\n    bb\r\n</view>\r\n    \r\n复制代码"}
{"title": "小程序识别身份证，银行卡，营业执照，驾照 ", "author": "Rolan", "pub_time": "2019-10-31 00:32", "content": "最近老是有同学问我小程序ocr识别的问题，就趁机研究了下，实现了小程序识别身份证，银行卡，驾照，营业执照，图片文字的功能。今天来给大家讲讲详细的实现流程。先画一张流程图出来第一次看到这个流程图，可能有点萌，什么云开发，云函数。。。。 不要着急，我们接下来会一步步带大家实现。先看下我们的页面和效果图。功能其实很简单，就是我们点对应的按钮后，去拍照或者去相册选择对应的图片。然后把图片上传到云存储，会有一个对应的图片url，然后把这个图片url传递到云函数，然后云函数里使用小程序的开发ocr能力，来识别图片，返回对应的信息回来。如下图所示，我们识别银行卡（身份证什么的就不演示了，涉及到石头哥个人隐私）接下来就是代码的实现了。一，首先要创建一个云开发的小程序项目这里我前面文章有讲解过，就不再细说了，不会的同学去翻看下我之前的文章。或者看下我录制的 讲解视频 这里有一点需要注意的给大家说下二，创建一个简单的小程序页面1，index.wxml如下2，index.js完整代码如下Page({  //身份证  shenfenzheng() {    this.photo(\"shenfenzheng\")  },  //银行卡  yinhangka() {    this.photo(\"yinhangka\")  },  //行驶证  xingshizheng() {    this.photo(\"xingshizheng\")  },  //拍照或者从相册选择要识别的照片  photo(type) {    let that = this    wx.chooseImage({      count: 1,      sizeType: ['original', 'compressed'],      sourceType: ['album', 'camera'],      success(res) {        // tempFilePath可以作为img标签的src属性显示图片        let imgUrl = res.tempFilePaths[0];        that.uploadImg(type, imgUrl)      }    })  },  // 上传图片到云存储  uploadImg(type, imgUrl) {    let that = this    wx.cloud.uploadFile({      cloudPath: 'ocr/' + type + '.png',      filePath: imgUrl, // 文件路径      success: res => {        console.log(\"上传成功\", res.fileID)        that.getImgUrl(type, res.fileID)      },      fail: err => {        console.log(\"上传失败\", err)      }    })  },  //获取云存储里的图片url  getImgUrl(type, imgUrl) {    let that = this    wx.cloud.getTempFileURL({      fileList: [imgUrl],      success: res => {        let imgUrl = res.fileList[0].tempFileURL        console.log(\"获取图片url成功\", imgUrl)        that.shibie(type, imgUrl)      },      fail: err => {        console.log(\"获取图片url失败\", err)      }    })  },  //调用云函数，实现OCR识别  shibie(type, imgUrl) {    wx.cloud.callFunction({      name: \"ocr\",      data: {        type: type,        imgUrl: imgUrl      },      success(res) {        console.log(\"识别成功\", res)      },      fail(res) {        console.log(\"识别失败\", res)      }    })  }})上面代码注释讲解的很清楚了，再结合我们的流程图，相信你可以看明白。三，重头戏来了，识别的核心代码是下面这个云函数云函数的完整代码也给大家贴出来// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init()// 云函数入口函数exports.main = async(event, context) => {  let {    type,    imgUrl  } = event  switch (type) {    case 'shenfenzheng':      {        // 识别身份证        return shenfenzheng(imgUrl)      }    case 'yinhangka':      {        // 识别银行卡        return yinhangka(imgUrl)      }    case 'xingshizheng':      {        // 识别行驶证        return xingshizheng(imgUrl)      }    default:      {        return      }  }}//识别身份证async function shenfenzheng(imgUrl) {  try {    const result = await cloud.openapi.ocr.idcard({      type: 'photo',      imgUrl: imgUrl    })    return result  } catch (err) {    console.log(err)    return err  }}//识别银行卡async function yinhangka(imgUrl) {  try {    const result = await cloud.openapi.ocr.bankcard({      type: 'photo',      imgUrl: imgUrl    })    return result  } catch (err) {    console.log(err)    return err  }}//识别行驶证async function xingshizheng(imgUrl) {  try {    const result = await cloud.openapi.ocr.vehicleLicense({      type: 'photo',      imgUrl: imgUrl    })    return result  } catch (err) {    console.log(err)    return err  }}其实没什么特别的，就是用一个switch方法，根据用户传入的不同的type值，来实现不同的识别效果。 如用传入的type是‘ yinhangka’，我们就调用银行卡识别try {    const result = await cloud.openapi.ocr.bankcard({      type: 'photo',      imgUrl: imgUrl    })    return result  } catch (err) {    console.log(err)    return err  }进而把识别的结果返回给小程序端，如下图到这里我们就完整的实现了，小程序识别身份证，银行卡，行驶证的功能。至于别的更多的ocr识别，可以去看小程序官方文档，结合着我的这篇文章，相信你也可以轻松实现更多的图片识别。源码其实在上面都已经贴给大家了，如果你觉得不完整，想要完整的源码可以在文章底部留言或者私信我。"}
{"title": "小程序入门看这篇就够了 ", "author": "Rolan", "pub_time": "2019-11-7 00:10", "content": "文章为实战中踩坑经历，以及解决方案。同时是自己的一个项目回顾，在这里分享给大家，希望能帮助到大家，如果觉得文章对你有用，请点个赞:+1:，谢谢！原谅我也是个标题党：）登录授权授权（基本信息，手机号码 ）必须使用小程序原生的的button组件，然后指定open-type 后通过回调才能拿到用户信息。代码入下：index.wxml\r\n<view class=\"authorization\" wx:if=\"{{!getUserInfo}}\">\r\n       <view class=\"clue\">你还未登录，请先授权登录</view>\r\n            <button open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"bindGetUserInfo\">\r\n                授权登录\r\n            </button>\r\n        </view>\r\n        <view class=\"authorization\" wx:if=\"{{getUserInfo && !getPhone}}\">\r\n            <view class=\"clue\">你还未绑定手机号，请先去绑定</view>\r\n            <button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\">\r\n                立即绑定\r\n            </button>\r\n</view>\r\nindex.js\r\npage({\r\n    // ... \r\n    data: {\r\n        hasUserInfo: false,\r\n        canIUse: wx.canIUse('button.open-type.getUserInfo'),\r\n        userInfo: {},\r\n        getUserInfo: false,\r\n        getPhone: false,\r\n        hasAuth: false\r\n    },\r\n    onLoad: async function () {\r\n        var that = this;\r\n        // 查看是否授权\r\n        wx.getSetting({\r\n            success: function (res) {\r\n                if (res.authSetting['scope.userInfo']) {\r\n                    wx.login({\r\n                        success: loginRes => {\r\n                            // 获取到用户的 code 之后：loginRes.code\r\n                            wx.getUserInfo({\r\n                                success: async function (res) {\r\n                                    // 这里处理业务逻辑\r\n                                }\r\n                            })\r\n                        }\r\n                    })\r\n                } else {\r\n                    // 用户没有授权\r\n                }\r\n            }\r\n        });\r\n    },\r\n    bindGetUserInfo: function (e) {\r\n        // 需要什么信息都从e中拿到 以下部分业务逻辑\r\n        if (e.detail.userInfo) {\r\n            //用户按了允许授权按钮\r\n            var that = this;\r\n            // 获取到用户的信息\r\n            wx.login({\r\n                success: async res => {\r\n                    const aUserModel = new UserModel();\r\n                    const params = {\r\n                        code: res.code,\r\n                        encryptedData: e.detail.encryptedData,\r\n                        iv: e.detail.iv\r\n                    }\r\n                    const { data } = await aUserModel.login({ ...params })\r\n                    if(data.roles){\r\n                        // do ...\r\n                    }\r\n                    if (data.mobile) {\r\n                        // do ...\r\n                    }\r\n                }\r\n            });\r\n            //授权成功后,通过改变 isHide 的值，让实现页面显示出来，把授权页面隐藏起来\r\n            that.setData({\r\n                isHide: false\r\n            });\r\n        } else {\r\n            //用户按了拒绝按钮\r\n            wx.showModal({\r\n                title: '警告',\r\n                content: '拒绝授权，您将无法使用小程序',\r\n                showCancel: false\r\n            });\r\n        }\r\n    },\r\n    getPhoneNumber: async function (e) {\r\n        if (e.detail.encryptedData) {\r\n            //用户按了允许授权按钮\r\n            const aUserModel = new UserModel();\r\n            const params = {\r\n                userId: userInfo.id,\r\n                encryptedData: e.detail.encryptedData,\r\n                iv: e.detail.iv\r\n            }\r\n            // do ...\r\n        } else {\r\n            //用户按了拒绝按钮\r\n            wx.showModal({\r\n                title: '警告',\r\n                content: '拒绝授权，您将无法使用小程序',\r\n                showCancel: false\r\n            })\r\n        }\r\n    },\r\n    // ...\r\n})\r\n复制代码路由路由跳转的各个方法可以去官网学习，这里提遇到的坑，navigateTo路由跳转最多只能10层，所以使用的时候需要考虑是不是确定需要历史记录。为什么要这么说呢。 场景：一个列表页面（如下图），用户的档案是可以修改的，如果用navigateTo跳转（/page/archivesEdit?id=1923XXXX）,修改保存用navigateTo（/page/archivesList），这样来回编辑跳转10次就不让点击跳转了。解决：思考那我用2个redirectTo 行不行？redirectTo是关闭当前历史记录跳转到下一页面。造成了我跳转到修改页面点击微信自带的返回是直接跳过列表页面跳转到首页。这个时候测试小姐姐就又要提bug单了。。。完美姿势： 就是用navigateTo和navigateBack。我再编辑保存的时候返回用navigateBack返回。这样小程序的路由栈就一会在2-3层之间。当然有时候在列表页面会遇到要重新条用接口，这时候路由跳转提供了几个重要的钩子函数onShow，onHide，我们可以在onShow的时候可以条用一下列表的接口。这2个钩子函数足够我们简单的跳转，更复杂的场景下可以通过存Storage这种存取参数来返回到上一个页面进行操作，感觉不是优雅，但是没有好的办法解决了。Storage场景：storage有2种方式获取，当你直接wx.getStorageSync('xxx')获取一个id，去请求接口的可能是获取不到就已经发送请求了，导致出现bug。因为wx.getStorageSync('xxx')是异步的 我们可以利用 async/await去方便的使用onLoad: async function (options) {\r\n        const editListParams = await wx.getStorageSync('editListParams')\r\n        this.findReportDetails(editListParams)\r\n}\r\n复制代码webViewwebview不是在某个页面使用的，当时我以为是类似iframe这种东西嵌入到页面。正确的使用态度是新建一个page页面，然后跳转到这个page去使用。例如跳转到小程序关联的公众号文章：other.wxml\r\n<navigator url=\"/pages/webView/webView\"  hover-class=\"none\">跳转到webView</navigator>\r\nwebView.wxml\r\n<web-view src=\"https://mp.weixin.qq.com/s/xxxx\"></web-view>\r\n复制代码request微信自带的网络下的request，虽然能拿来就用，如果不封装就会造成代码冗余。大家可自行参考如下封装ajax.js\r\n\r\nimport { baseURL } from '../config/interfaceURL' // baseUrl\r\n\r\nclass AJAX {\r\n    AJAX ({ url, methods = 'GET', data = {} }) {\r\n        return new Promise((resolve, reject) => {\r\n            this.request(url, resolve, reject, methods, data)\r\n        })\r\n    }\r\n    request (url, resolve, reject, methods, data) {\r\n        wx.request({\r\n            url: baseURL + url,\r\n            method: methods,\r\n            data: data,\r\n            header: {\r\n                'content-type': 'application/json'\r\n            },\r\n            success: res => {\r\n                const code = res.statusCode.toString()\r\n                if (code.startsWith('2')) {\r\n                    resolve(res)\r\n                } else {\r\n                    reject()\r\n                    const errorMessage = res.data.message\r\n                    AJAX.showError(errorMessage)\r\n                }\r\n            },\r\n            fail: err => {\r\n                reject()\r\n                AJAX.showError(\"网络异常，请稍后重试！\")\r\n            }\r\n        })\r\n    }\r\n    static showError (errorMessage) {\r\n        wx.showToast({\r\n            title: errorMessage,\r\n            icon: 'error',\r\n            duration: 2000\r\n        })\r\n    }\r\n    static serializeLink (obj) { // 序列化get请求\r\n        let temp = '?'\r\n        for (let index in obj) {\r\n            if(obj.hasOwnProperty(index)){\r\n                temp += (index + '=' + obj[index] + '&')\r\n            }\r\n        }\r\n        return temp.substr(0, temp.length - 1)\r\n    }\r\n}\r\nexport default AJAX\r\n\r\n// model层调用\r\nUserModel.js\r\nimport AJAX from '../utils/AJAX'\r\n\r\nexport class UserModel extends AJAX {\r\n    // 小程序授权登陆\r\n    login (params) {\r\n        return this.AJAX({\r\n            url: `/service/api/users/applet/login`,\r\n            data: params,\r\n            methods: 'POST'\r\n        })\r\n    }\r\n}\r\n// control调用\r\nindex.js\r\nasync onLoad (options){\r\n    const aUserModel = new UserModel()\r\n    const params = {\r\n        code: loginRes.code,\r\n        encryptedData: res.encryptedData,\r\n        iv: res.iv\r\n    }\r\n    const { data } = await aUserModel.login({ ...params })\r\n    // 其他\r\n}\r\n\r\n复制代码npm生态以及第三方ui框架直接通过初始化的微信小程序项目里面没有package.json文件。所以在使用npm install xxx 是没有卵用。所以我们要自己在文件夹根目录下执行npm init 。这时候才能通过微信开发者工具构建npm，构建成功会生成一个目录。推荐用有赞的vant小程序版,社区较活跃，使用起来不会有很多坑。双向绑定对于习惯使用vue的开发者来说，少了这个v-model语法糖。在处理表单的双向绑定会显得比较蛋疼。所以还是有必要说下小程序里面的双向绑定是怎么样的。file:index.js\r\n\r\nPage({\r\n    data: {\r\n       list: []\r\n    },\r\n    onLoad: function (options) {\r\n      // do ...\r\n    },\r\n    onInput (e) {\r\n        let value = e.detail.value\r\n        let temp = e.target.dataset.name.split(',')\r\n        let tempKey = temp[1]\r\n        let tempIndex = temp[0]\r\n        let tempSubIndex = temp[2]\r\n        let targetKey = `list[${tempIndex}].children[${tempSubIndex}].${tempKey}`\r\n        this.setData({\r\n            [targetKey]: value\r\n        })\r\n    }\r\n})\r\n\r\nfile:index.wxml\r\n<block  wx:for=\"{{item.children}}\"  wx:for-item=\"subItem\"  wx:key=\"{{index}}\">\r\n    <view class=\"td\" style=\"height: {{ 100 / item.children.length}}%;\">\r\n      <input placeholder-style=\"color:#ccccccc;\"  type=\"text\" placeholder=\"未填写\" value=\"{{subItem.testResult}}\" data-name=\"{{idx}},testResult,{{index}}\"  bindinput=\"onInput\"/>\r\n    </view>\r\n</block>\r\n\r\n复制代码下载图片和下载图片授权这里场景是下载一个固定的静态资源图片，网络图片需先配置download域名才能生效,方法如下：savePhoto () {\r\n        const _this = this;\r\n        wx.getImageInfo({\r\n            src: '/static/images/home/Qr.png',\r\n            success: function (res) {\r\n                wx.saveImageToPhotosAlbum({\r\n                    filePath: res.path,\r\n                    success (result) {\r\n                        _this.setData({ show: false });\r\n                        wx.showToast({\r\n                            title: '保存成功',\r\n                            icon: 'success',\r\n                            duration: 2000\r\n                        })\r\n                    },\r\n                    fail (err) {\r\n                        if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n                            wx.openSetting({\r\n                                success (settingdata) {\r\n                                    if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                                        _this.savePhoto()\r\n                                    } else {\r\n                                        wx.showToast({\r\n                                            title: '获取权限失败,无法保存图片',\r\n                                            icon: 'success',\r\n                                            duration: 2000\r\n                                        })\r\n                                    }\r\n                                }\r\n                            })\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n复制代码保存图片也是需要授权的，看代码就完事了。其他textarea 在ios上表现会有padding值。我曹 这个就坑了。我采用要不全是textarea或者全是input 这种去实现表单的填写。 其他样式问题也蛮多的，有点ie的味道。:smiley:！！ 多用flex float去解决一些差异吧~结语文章每个点都是开发小程序的时候遇到的问题，本人能力有限，欢迎大家提出自己的问题，也可以加入微信群和我们团队一起交流学习。小程序坑还是蛮多的，而且写博客也蛮难得，码子不易，点个赞吧！ :）逃~~~~~"}
{"title": "小程序 swiper 如何多页面高度自适应 ", "author": "Rolan", "pub_time": "2019-11-18 00:40", "content": "轮播，这个概念只要做过 UI 的都不会陌生，盲猜市场上 90% 的应用都有这个需求，在 iOS 和 Android 上都有很完善的控件，比如 Android 的 ViewPager 和 iOS 的 UIScrollview。\r\n\r\n小程序这么牛逼，肯定也要有控件支持这个特性啊， swiper 就这么诞生了。\r\n但是 swiper 有一个很严重的问题，就是高度默认 150px，且不可以自适应内容调整高度。\r\n这就有问题了，我现在有一个多 Tab 的页面，最少高度要满屏，还要超出内容可以往下滚动，此时就蒙蔽了，怎么给 swiper 设置高度呢？\r\n首先看一下我搜索到的一些方法：\r\n\r\n\r\n在初始化的时候获取到屏幕的高度，然后将高度设置到 swiper 上，至于滚动的问题，在里面再嵌入一个 scroll-view\r\n这个问题有很多坑，首先 屏幕的高度要比内容区的高度大，这么设置以后就算内容较少，页面也能滑动一点；其次，小程序的 scroll-view 在实现上拉加载更多的时候，坑更多。\r\n\r\n\r\n每个 item 的高度都一致，根据 item 的数量和统一的高度计算出内容的高度，然后设置进去\r\n这个方案感觉完全是 zz 方案，局限性太大了\r\n\r\n\r\n我的方案\r\n\r\n一句话解释：给 swiper-item 内部添加三个锚点，最上面一个，最下面一个，还有一个锚点始终位于屏幕最底下。根据这三个锚点计算出内容高度和内容显示区高度。\r\nPS：锚点，宽高为 0 的不可见的 view，用于获取定位\r\n\r\n如果还有不理解可以看下面这个示意图：\r\n\r\n这三个锚点的具体作用是用来计算 swiper 内容高度和 swiper 距离屏幕底部的具体，计算方式如下：\r\n\r\n使用 swiper-item 内部的两个锚点计算出内容区高度\r\n通过屏幕底部和 swiper-item 顶部的锚点计算出离屏幕底部的距离\r\n\r\n接下来看看代码具体实现\r\n代码实现\r\npage.wxml\r\n<view>\r\n\t<swiper style=\"height: {{anchor.deviceHeight + 'px'}}\">\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t</swiper>\r\n\t<view class=\"anchor-screen-bottom\"></view>\r\n</view>\r\n复制代码\r\npage.wxss\r\n.anchor-top {\r\n    width: 0;\r\n    height: 0;\r\n}\r\n\r\n.anchor-bottom {\r\n    width: 0;\r\n    height: 0;\r\n}\r\n\r\n.anchor-screen-bottom {\r\n    position: absolute;\r\n    bottom: 0;\r\n    width: 0;\r\n    height: 0;\r\n}\r\n复制代码\r\npage.js\r\nPage({\r\n\tdata: {\r\n\t\tanchor: {\r\n\t\t\tdeviceHeight: 0,\r\n      anchorTop: 0,\r\n      anchorBottom: 0,\r\n      anchorScreenBottom: 0\r\n\t\t}\r\n\t},\r\n\tonReady: function() {\r\n\t\tthis.computeSwiperHeight(0)\r\n\t},\r\n\tcomputeSwiperHeight(pageIndex) {\r\n\t  let getSwiperHeight = () => {\r\n      let min = this.data.anchor.anchorScreenBottom - this.data.anchor.anchorTop;\r\n      let value = this.data.anchor.anchorBottom - this.data.anchor.anchorTop\r\n      return Math.max(min, value)\r\n\t  }\r\n\t  wx.createSelectorQuery()\r\n      .select('.anchor-screen-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorScreenBottom = res[0].bottom\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-top')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorTop = res[0].top\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorBottom = res[0].bottom\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t},\r\n})\r\n复制代码\r\n适配多页面\r\n当然，肯定要适配每个页面的高度不一样的情况。方案也很简单，屏幕底部的锚只需要一个了，给每个 swiper-item 的都添加两个锚点，和之前一样一个在上面一个在下面，在切换页面的时候，根据当前页面的锚点重新计算一下高度，然后设置进去。\r\n只需要在原有基础上改一下代码：\r\npage.wxml\r\n<view>\r\n\t<swiper style=\"height: {{anchor.deviceHeight + 'px'}}\" bindchange=\"swiperChange\">\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t</swiper>\r\n\t<view class=\"anchor-screen-bottom\"></view>\r\n</view>\r\n复制代码\r\npage.wxss\r\nCSS 不需要改动\r\npage.js\r\nPage({\r\n\tdata: {\r\n\t\tanchor: {\r\n\t\t\tdeviceHeight: 0,\r\n      anchorTop: 0,\r\n      anchorBottom: 0,\r\n      anchorScreenBottom: 0\r\n\t\t}\r\n\t},\r\n\tonReady: function() {\r\n\t\tthis.computeSwiperHeight(0)\r\n\t},\r\n\tswiperChange(e) {\r\n    this.computeSwiperHeight(e.detail.current)\r\n  },\r\n\tcomputeSwiperHeight(pageIndex) {\r\n\t  let getSwiperHeight = () => {\r\n      let min = this.data.anchor.anchorScreenBottom - this.data.anchor.anchorTop;\r\n      let value = this.data.anchor.anchorBottom - this.data.anchor.anchorTop\r\n      return Math.max(min, value)\r\n\t  }\r\n\t  wx.createSelectorQuery()\r\n      .select('.anchor-screen-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorScreenBottom = res[0].bottom\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-top')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorTop = res[0][pageIndex].top\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorBottom = res[0][pageIndex].bottom\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t},\r\n})\r\n复制代码\r\n实现效果\r\n\r\nswiper 的高度高度根据内容自适应\r\nswiper 的高度最小占满屏幕，最大和内容一样高（为了用户滑动体验（如果划页后高度突然变小，用户在原来的位置就划不回去了）\r\n适配不同高度的页面\r\n\r\n这个方案是了实现为自己的需求而写的，应该不适应全部的场景，不过希望可以为你提供一点思路。\r\n感想\r\n小程序里的坑真的很多，而且有些 API 设计的很奇怪，真的不知道当初开发人员怀着怎样的心路历程设计出的 API。\r\n个人感觉小程序就是给前端新造了一个轮子，更新还很不及时，有很多陈年老 Bug，比如本文讲的 swiper。\r\n前端娱乐圈发展这么快，感觉小程序可能会跟不上潮流。\r\n最后\r\n给我正在开发的小程序预热一下～\r\n\r\n欢迎关注～"}
{"title": "微信小程序——基础知识 ", "author": "Rolan", "pub_time": "2019-11-26 00:02", "content": "目录结构介绍一个小程序至少由俩个文件组成 app.js 和 app.json 1. app.js 小程序逻辑 2. app.json 小程序全局配置 3. app.wxss 小程序公共样式表 4. project.config.json 开发项目时工具配置文件。一个小程序页面由四个文件组成传统web小程序结构HTMLwxml样式表CSSwxss逻辑Javascriptjs配置无json初始化页面的俩个警告:warning::warning:根据 sitemap 的规则[0]，当前页面 [pages/index/index] 将被索引 解决方案：小程序项目配置文件 project.config.json 的 setting 中配置字段 \"checkSiteMap\": false\"setting\": {\r\n    \"checkSiteMap\": false\r\n},\r\n复制代码:warning:获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级解决方案：清空 App.js全局配置路由、导航栏和tabBar小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。路由 Pages路由 Pages | 微信开放文档项目开发目录为：├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── pages\r\n│   │── index\r\n│   │   ├── index.wxml\r\n│   │   ├── index.js\r\n│   │   ├── index.json\r\n│   │   └── index.wxss\r\n│   └── logs\r\n│       ├── logs.wxml\r\n│       └── logs.js\r\n└── utils\r\n复制代码则需要在 app.json 中写{\r\n    \"pages\": [\r\n        \"pages/index/index\",\r\n        \"pages/logs/logs\"\r\n    ],\r\n}\r\n复制代码顶部导航 window顶部导航 window | 微信开放文档用于设置小程序的状态栏、导航条、标题、窗口背景色。window属性说明文档属性描述backgroundTextStyle下拉 loading 的样式，仅支持 dark / lightnavigationBarBackgroundColor导航栏背景颜色，如 #000000navigationBarTitleText导航栏标题文字内容`navigationBarTextStyle导航栏标题颜色，仅支持 black / whiteenablePullDownRefresh是否开启当前页面的下拉刷新 true / false代码实例{\r\n    \"window\": {\r\n        \"backgroundTextStyle\": \"dark\",\r\n        \"navigationBarBackgroundColor\": \"#0081ff\",\r\n        \"navigationBarTitleText\": \"教育Top10\",\r\n        \"navigationBarTextStyle\": \"white\",\r\n        \"enablePullDownRefresh\": true\r\n    },\r\n}\r\n复制代码如何设置某个单页面的导航栏？自定义顶部栏,文字、背景色，在该单页面的 json里添加如下：{\r\n\t\"usingComponents\": {},\r\n    \"navigationBarTitleText\": \"课程列表\",\r\n    \"navigationBarBackgroundColor\": \"#0081ff\",\r\n    \"navigationBarTextStyle\": \"white\"\r\n}\r\n复制代码隐藏顶部栏，在该单页面的 json 里添加如下：{\r\n    \"navigationStyle\": \"custom\"\r\n}\r\n复制代码底部 tabBar底部 tabBar | 微信开放文档 小程序是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，及切换时显示的对应页面。tabBar属性说明文档属性描述colortab 上的文字默认颜色，仅支持十六进制颜色selectedColortab 上的文字选中时的颜色，仅支持十六进制颜色backgroundColortab 的背景色，仅支持十六进制颜色borderStyletabbar上边框的颜色， 仅支持 black / whitecustom自定义 tabBar，见 详情listtab 的列表，详见 list 属性说明list 数组，包含 tab 最少 2 个、最多 5 个list属性描述pagePath路由：跳转到指定页面text底部导航文字iconPath底部导航图标、未选中状态selectedIconPath底部导航图标、选中状态代码实例{\r\n    \"tabBar\": {\r\n        \"color\": \"#333\",\r\n        \"selectedColor\": \"#0081ff\",\r\n        \"borderStyle\": \"black\",\r\n        \"backgroundColor\": \"#fff\",\r\n        \"list\": [\r\n            {\r\n                \"pagePath\": \"pages/tabBar/tabBar_home/tabBar_home\",\r\n                \"text\": \"首页\",\r\n                \"iconPath\": \"images/Tabbar/home.png\",\r\n                \"selectedIconPath\": \"images/Tabbar/home_cur.png\",\r\n            },\r\n            {\r\n                \"selectedIconPath\": \"images/Tabbar/my_cur.png\",\r\n                \"iconPath\": \"images/Tabbar/my.png\",\r\n                \"pagePath\": \"pages/tabBar/tabBar_myCenter/tabBar_myCenter\",\r\n                \"text\": \"个人中心\"\r\n            }\r\n        ],\r\n    }\r\n}\r\n复制代码基础组件view 视图容器text 文本<text>纯文本</text> 组件之间只能包含纯文本，在text中写其他标签，将会被忽略掉<text \r\n    class=\"info\" \r\n    id=\"zbc\" \r\n    style=\"\" \r\n    bindtap=\"_fun\" 点击事件\r\n    hidden=\"true\" 显示隐藏[微信小程序--hidden不生效原因及解决方案?]\r\n    data-user=\"user\" 自定义组件\r\n>\r\n    hello world\r\n</text>\r\n复制代码image 图片微信小程序 Image 图片实现宽度100%，高度自适应 mode=\"widthFix\"<image class=\"img\" src=\"../../images/hello.png\" mode=\"widthFix\">\r\n\r\n.img{width: 100vw;}\r\n复制代码Flex 布局Flex 布局兼容性Flex 布局属性要使用弹性布局，通过 display: flex 或者 display: inline-flex 来将此元素定义为弹性容器。flex-direction 决定元素的排列方向row\r\ncolumn\r\nflex-wrap 决定元素如何换行nowrap\r\nwrap\r\njustify-content 定义主轴为水平方向，分布方式。flex-start\r\nflex-end\r\ncenter\r\nspace-between\r\nspace-around\r\nalign-items 定义主轴为垂直方向，分布方式。flex-start\r\nflex-end\r\ncenter\r\nflex: 1 权重，分配主轴上剩余的空间（有图）<view style=\"display:flex;\">\r\n    <view class=\"A\" style=\"width: 140rpx;height: 80rpx; flex: 1;\"></view>\r\n    <view class=\"B\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n    <view class=\"C\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n    <view class=\"D\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n</view>\r\n复制代码数据绑定数据绑定 | 微信开放文档简单绑定<view> {{ message }} </view>\r\n复制代码Page({\r\n  data: {\r\n    message: 'Hello MINA!'\r\n  }\r\n})\r\n复制代码三元运算<view hidden=\"{{flag ? true : false}}\"> Hidden </view>\r\n复制代码算数运算<view> {{a + b}} + {{c}} + d </view>\r\n复制代码Page({\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n    c: 3\r\n  }\r\n})\r\n复制代码view中的内容为 3 + 3 + d。是否同意该协议表单按钮<checkbox checked=\"{{false}}\"> </checkbox>\r\n复制代码特别注意：不要直接写  checked=\"false\" ，其计算结果是一个字符串，转成 boolean 类型后代表真值。列表渲染wx:for列表渲染 | 微信开放文档在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index ，数组当前项的变量名默认为 item 数据绑定使用 {{}} 将变量包起来，可以作用于：轮播图wx:for<swiper>\r\n    <swiper-item wx:for=\"{{banner}}\" wx:key=\"{{index}}\">\r\n        <image src=\"{{item.img}}\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码Page({\r\n    data: {\r\n        banner: [{\r\n            img: '../../images/swiper-1.jpeg',\r\n        }, {\r\n            img: '../../images/swiper-2.jpeg',\r\n        }]\r\n    }\r\n})\r\n复制代码上述代码的简略版<swiper>\r\n    <swiper-item wx:for=\"{{2}}\" wx:key=\"{{index}}\">\r\n        <image src=\"../../images/swiper-{{index + 1}}.jpeg\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码wx:for-item 和 wx:for-index使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名：<swiper>\r\n    <swiper-item wx:for=\"{{banner}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">\r\n        <image src=\"{{itemName.img}}\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码wx:keywx:key 是列表中唯一的字符串或数字，且不能动态改变。例如：<switch wx:for=\"{{objectArray}}\" wx:key=\"unique\" style=\"display: block;\"> {{item.id}} </switch>\r\n复制代码Page({\r\n    data: {\r\n        objectArray: [\r\n            { id: '时间', unique: 'unique_5' },\r\n            { id: '速度', unique: 'unique_4' },\r\n            { id: '路程', unique: 'unique_3' },\r\n            { id: 2, unique: 'unique_2' },\r\n        ],\r\n    },\r\n})\r\n复制代码小鹿咖啡的菜单【实例】<scroll-view scroll-y class=\"rightBar\">\r\n        <view class=\"rightBar_Item\" wx:for=\"{{foodList}}\" wx:key=\"{{index}}\">\r\n            <view class=\"series_Title flex\">\r\n                <view class=\"drink_Title_name\">{{item.title}}</view>\r\n                <view class=\"drink_Title_line\"></view>\r\n            </view>\r\n            <view class=\"drink_List\">\r\n                <view class=\"drink_Item flex\" wx:for-item=\"it\" wx:for=\"{{item.food}}\" wx:key=\"{{index}}\">\r\n                    <view class=\"drink_Img\">\r\n                        <image class=\"drink_Img\" src=\"{{it.img}}\"></image>\r\n                        <view class=\"tip\" wx:if=\"{{it.tip}}\">{{it.tip}}</view>\r\n                    </view>\r\n                    <view class=\"drink_Cont\">\r\n                        <view class=\"drink_Title\">\r\n                            <view class=\"drink_Ch_Title\">{{it.name}}</view>\r\n                            <view class=\"drink_En_Title\">{{it.enname}}</view>\r\n                        </view>\r\n                        <view class=\"ju_between\">\r\n                            <view class=\"drink_price\">¥{{it.price}}</view>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </scroll-view>\r\n复制代码Page({\r\n    data: {\r\n        \"foodList\": [\r\n            {\r\n                \"id\": 1,\r\n                \"title\": \"大师咖啡\",\r\n                \"food\": [\r\n                    {\r\n                        \"id\": 1,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/SvHL13tH2g5UKUmVrbCjAPs4sLNBvAo7fhdJGpEU1.s!/r/dFQBAAAAAAAA\",\r\n                        \"name\": \"摩卡\",\r\n                        \"enname\": \"Mocha\",\r\n                        \"price\": \"27\",\r\n                        \"tip\": \"买2增1\"\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                \"id\": 2,\r\n                \"title\": \"小鹿茶\",\r\n                \"food\": [\r\n                    {\r\n                        \"id\": 1,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/VoBwYjGp2dIkV1owMWjVr4rm6Tp3wl8H1Gsa7n5hh08!/r/dFQBAAAAAAAA\",\r\n                        \"name\": \"活力柠檬红宝石茶\",\r\n                        \"enname\": \"Lemon Ruby Tea\",\r\n                        \"price\": \"24\",\r\n                        \"tip\": \"买2增1\"\r\n                    },\r\n                    {\r\n                        \"id\": 2,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/o7p7XoYAGaeMH6EtQNPVbU8tHFnKZitOcl9RarOcqNA!/r/dAgBAAAAAAAA\",\r\n                        \"name\": \"桃桃山雾乌龙茶\",\r\n                        \"enname\": \"White & Yellow Peach Oolong Tea\",\r\n                        \"price\": \"24\"\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    },\r\n})\r\n复制代码条件渲染wx:if条件渲染 | 微信开放文档wx:if使用方法wx:if=\"{{false}}\" , wx:if=\"{{true}}\"在小程序里面识别boolean值时，只要属性的值 不为空时，boolean就判断为真，就算里面随便几个字符，例如 wx:if=\"11223\" ，也判断为真， 如果需要为false,就必须采用数据绑定的方式{{false}},才能被小程序解析为假。在框架中，使用 wx:if=\"\" 来判断是否需要渲染该代码块： 也可以用  wx:elif 和  wx:else 来添加一个 else 块：<view wx:if=\"{{length > 85}}\">优秀</view>\r\n<view wx:elif=\"{{length > 60}}\">及格</view>\r\n<view wx:else>不及格</view>\r\n复制代码Page({\r\n    data: {\r\n        length: 61,\r\n    }\r\n})\r\n复制代码结果：及格的使用注意： <block/> 并不是一个组件，它仅仅是一个包装元素，将多个组件包装起来,不会在页面中做任何渲染，只接受控制属性。 wx:if 和 wx:for 含有 <block/> 的写法data: {\r\n        modalToggle: false,\r\n    },\r\n复制代码<block wx:if=\"{{modalToggle}}\">\r\n    \t<view class=\"modalWrap\">\r\n        \t<view class=\"modal\"></view>\r\n    \t</view>\r\n\t</block>\r\n\r\n复制代码不含有 <block/> 的写法data: {\r\n        modalToggle: false,\r\n    },\r\n复制代码<view class=\"modalWrap\" wx:if=\"{{modalToggle}}\">\r\n    \t<view class=\"modal\"></view>\r\n\t</view>\r\n复制代码教育Top10收藏列表【实例】页面描述：当有数据时，显示左侧列表。当没有数据时，则显示右侧内容<block wx:if=\"{{list.length>0}}\">\r\n    <block wx:for=\"{{list}}\" wx:key=\"idx\">\r\n        <view>{{item}}</view>\r\n    </block>\r\n</block>\r\n<block wx:else>\r\n    <view>暂时未收藏哦~</view>\r\n</block>\r\n复制代码Page({\r\n    data: {\r\n        list: ['月落乌啼霜满天','江枫渔火对愁眠']\r\n    },\r\n})\r\n复制代码wx:if vs  hidden1. wx:if 在初始渲染条件为  false ，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。所以当  wx:if 的条件值切换时，框架有一个局部渲染的过程，确保条件块在切换时销毁或重新渲染。 2. hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。总结: wx:if 有更高的切换消耗，而  hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用  hiddenhidden不生效原因及解决方案?<view hidden=\"true\" style=\"display:flex;\">\r\n    <text>text1</text>\r\n    <text>text2</text>\r\n</view>\r\n复制代码你会发现 hidden 没生效。经我实验发现 hidden 元素对块状布局才生效，所以这段代码里导致 hidden 没生效的罪魁祸首是 display:flex 。把这个去掉就可以了。如果一定要用flex布局怎么办？其实这里想用 hidden 无非就是想影藏这个布局， display:none 也能做到隐藏。这里可以用一个取巧的方法，动态设置 display 属性，示例如下：<view style=\"display:{{hideview ? 'none' : 'flex'}};\">\r\n    <text>text1</text>\r\n    <text>text2</text>\r\n</view>\r\n复制代码这里的 hideview 是在对应的 js 里是一个变量，由 js 来动态控制。"}
{"title": "小程序-腾讯地图SDK-获取当前地址 ", "author": "Rolan", "pub_time": "2019-12-3 00:41", "content": "如何获取用户当前地址，这个就要先用到小程序的定位功能:定位官方文档第一步获取当前定位在js当中写运行项目之后会有个这样的弹窗：这是因为开发者需要说明获取用户地理位置的用途。 解决方法： 在app.json中增加permission属性。这样就可以获取到用户的地理坐标了。第二步讲当前定位转换程地址信息这个功能需要用到腾讯地图SDK：官方文档 官方文档上使用SDK的步骤写的挺详细的，还带上了各种链接：第4步的安全域名设置在你自己的小程序管理后台里设置 以上4步都完成后，将下载好的SDK文件放到项目里。 在页面js里引入SDK：我们需要用到的是SKD里面的reverseGeocoder()方法，所以我们在获取到用户当前坐标后调用这个方法：这样就将地址坐标转换成了地址，在页面上简单展示出来：完整代码 最后贴上我的js完整代码，写的有点小啰嗦了，如果有什么不太懂的地方欢迎加我qq一起讨论下：546529770，谢谢~~js/**引入SDK核心类 */var qqSDK = require('../../apis/qqmap-wx-jssdk.min.js')Page({  /**   * 页面的初始数据   */  data: {    latitude: '',    longitude: '',    positionData: ''  },  /**   * 生命周期函数--监听页面加载   */  onLoad: function(options) {    var _this = this    /**实例化SDK核心类 */    var qqMap = new qqSDK({      key: '3B4BZ-QHNK3-HLX34-YKUQA-YDHCV-CHFFB' //必填    });    /**获取当前坐标 */    wx.getLocation({      success: function(res) {        var latitude = res.latitude        var longitude = res.longitude        qqMap.reverseGeocoder({          success: function(res) {            var address = res.result.address;            _this.setData({              latitude: latitude,              longitude: longitude,              positionData: address            });          }        })      }    })  }})"}
{"title": "小程序Canvas性能优化实战 ", "author": "Rolan", "pub_time": "2019-12-17 00:18", "content": "案例背景需求：在小程序中使用canvas组件绘制地铁图，地铁图包括地铁线路、站点图标、线及站点名称文字，绘制元素为线、圆、图片、文字。支持拖动平移和双指缩放。问题：小程序中的canvas性能有限，特别在交互的过程中不断触发重绘会引发严重卡顿。基本实现在不考虑优化的情况下，先说说如何实现绘制和交互。数据格式首先看看数据，服务返回的数据中每个元素都是独立的，包括该元素的样式及坐标1234567891011121314// 线路数据lineData = { path: [x0, y0, x1, y1, ...], strokeColor, strokeWidth }// 站点数据：分为普通站点和换乘站点// 普通站点绘制简单圆形stationData = { x, y, r, fillColor, strokeColor, strokeWidth }// 换乘站点绘制换乘图标（png图片）stationData_transfer = { x, y, width, height }// 线路名称lineNameData = { text, x, y, fillColor }// 站点名称stationNameData = { text, x, y }绘图API绘制的时候遍历绘制元素数组，根据元素类型设置上下文样式，绘制及填充。接口参考：https://developers.weixin.qq.com/miniprogram/dev/api/CanvasContext.html。设置样式：setStrokeStyle, setFillStyle, setLineWidth, setFontSize绘制路线：moveTo, lineTo, stroke绘制站点：moveTo, arc, stroke, fill绘制图片：drawImage绘制文字：fillText交互实现实现交互主要步骤如下：通过bindtouchstart、bindtouchmove、bindtouchend实现对用户拖动和双指缩放的监听，得到拖动位移向量、缩放比例，触发重绘绘制时通过scale和translate在不用对数据坐标进行处理的情况下实现缩放和平移最终得到的结果如下，平均渲染时长为42.82ms，真机（ios）验证：龟速移动，画面延迟非常大。优化方法完全不了解canvas优化方案的同学可以先看看： canvas的优化。避免不必要的画布状态改变参考Canvas 最佳实践（性能篇） ，绘图上下文是一个状态机，状态的改变是有一定开销的。画布状态改变这里主要指strokeStyle、fillStyle等样式的改变。如何减少这部分的开销呢？我们可以尽量让样式相同的元素放在一起进行一次性的绘制。观察一下数据可以发现，很多站点元素样式都是相同的，那么在绘制之前可以先做一次数据的聚合，将样式相同的数据组合成一条数据：12345678910111213141516function mergeStationData(mapStation) {  let mergedData = {}  mapStation.forEach(station => {    let coord = `${station.x},${station.y},${station.r}`    let stationStyle = `${station.fillColor}|${station.strokeColor}|${station.strokeWidth}`    if (mergedData[stationStyle]) {      mergedData[stationStyle].push(coord)    } else {      mergedData[stationStyle] = [coord]    }  })  return mergedData}聚合后，329条站点数据合并为24条，有效的减少了90%的冗余状态改变开销。修改之后测试一下，平均渲染时长降到了20.48ms，真机验证：移动稍快了一些，但画面仍有较高延迟。合并数据的时候需要注意，此应用场景下各站点是没有互相压盖的，而如果有压盖顺序的话，在合并时只能合并相邻且样式相同的数据。减少绘制物筛除视野外的绘制物： 当用户在放大图像时，其实大部分绘制物都消失在了视野范围之外，避免绘制视野外的元素可以节省不必要的开销。点元素是比较容易判断是否在视野范围之外的，而站点、站点名、线路名都可以作为点元素处理；线路也可以计算出在视野范围内的部分线段，较为复杂，这里先不做处理。筛除掉视野外的绘制物之后测试一下，平均渲染时长17.02ms，真机验证：同上，没有太多变化。筛除过小的绘制物： 当用户在缩小图像时，文字和站点会由于尺寸太小而看不大清，在不影响用户体验的前提下可以考虑直接去掉。根据测试，最终决定在显示比例小于30%时去除文字和站点，这个级别下的渲染时长从22.12ms，减少到了9.68ms。降低重绘频率虽然平均渲染时长已经低了很多，但是在交互时却仍有较高的延迟，这是因为每次ontouchmove都会将渲染任务加入到异步队列中，事件触发频率远高于每秒能够执行的渲染次数，导致渲染任务严重积压，不断滞后。在PC端一般使用requestAnimationFrame解决这个问题，小程序里没有，但是可以自己实现，参考微信小程序中使用requestAnimationFrame：1234567891011121314151617const requestAnimationFrame = function (callback, lastTime) {  var lastTime;  if (typeof lastTime === 'undefined') {    lastTime = 0  }  var currTime = new Date().getTime();  var timeToCall = Math.max(0, 30 - (currTime - lastTime));  lastTime = currTime + timeToCall;  var id = setTimeout(function () {    callback(lastTime);  }, timeToCall);  return id;};const cancelAnimationFrame = function (id) {  clearTimeout(id);};PC端我们一般将渲染间隔控制在16ms左右，但是在小程序中考虑到性能限制，且移动端各机型性能不一，所以这里留了一些空间，控制在30ms，对应到30FPS左右。但如果一直循环调用也会造成静止状态下不必要的开销，所以可以在交互开始ontouchstart和结束ontouchend时分别开启、停止动画：12345678910animate(lastTime) {  this.animateId = requestAnimationFrame((t) => {    this.render()    this.animate(t)  }, lastTime)},stop() {  cancelAnimationFrame(this.animateId)},修改之后真机验证一下：画面比较流程，有轻微卡顿，但不会延迟。其他注意由于本例中缩放和平移状态是以绝对状态保存的，所以scale和translate要搭配save和restore一起使用；但也可以使用setTransform直接重置矩阵。从理论上看这样应该能节省开销，但实际测试并没什么效果，平均渲染时长在18.12ms。这个问题有待研究。小程序中避免使用setData保存与界面渲染无关的数据，以避免引起页面重绘。优化结果经过以上优化，渲染时长从42降到了17ms左右，真机验证下安卓机型普遍非常流畅，体验很好；ios机型有轻微卡顿，且随着使用时长卡顿逐渐明显，后期可以深入研究下是否有内存管理的问题。"}
{"title": "xquery小程序简易步进器 ", "author": "Rolan", "pub_time": "2019-12-30 00:29", "content": "这样一个简单的组件，翻了ant.design才知道这种组件叫做步进器(steper)，步进器常用于购物车等需要增减数量的场景，最近的旅游项目中用于增减房间数和人数，从产品的角度来理解步进器很简单，但在开发角度来说需要适应多种场景及控制一些状态边界值(最大值，最小值)，初始值，步进值(一次增减数量)需要可控边界状态，即超出后显示为什么状态可供外部设置边界状态的api方法内部加减方法可供外部调用的加减方法(一些场景中，外部有一个总量约束，比如sku场景)加减回调方法，比如当数量超出时提示用户相关信息多实例模式，实例之间即隔离又能交互大致需求如上，demo及实现部分如下GITHUB源码小程序代码片段wxml<view class=\"container\">\r\n  <ui-item item=\"{{steperConfig}}\" />\r\n</view>\r\n复制代码Page因为是直接使用Item组件实现，所以组件写在Page页面中，当然独立成组件看需求了const Pager = require('../components/aotoo/core/index')\r\nlet lib = Pager.lib\r\n\r\nfunction mkSteper(id=lib.suid('step_'), min, max, step=1) {\r\n  return {\r\n    $$id: id,\r\n    itemClass: 'steper-class',\r\n    title: [\r\n      {title: '-', aim: 'reduce', itemClass: 'steper-reduce'},\r\n      {title: '0', aim: 'custom', itemClass: 'steper-counter'},\r\n      {title: '+', aim: 'plus', itemClass: 'steper-plus'},\r\n    ],\r\n    methods: {\r\n      __ready(){\r\n        this.count = 0\r\n        this.min = min||0\r\n        this.max = max||10\r\n        this.step = step||1\r\n        this.stat = {\r\n          reduce: true,\r\n          plus: true,\r\n          count: true\r\n        }\r\n      },\r\n      reduce(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[0]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (e === true) {\r\n          this.stat.reduce = true\r\n          inst.removeClass('disable')\r\n        }\r\n\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count -= step\r\n        if (this.count <= this.min) {\r\n          this.count = this.min\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (this.count < this.max && !this.stat.plus) {\r\n          this.stat.plus = true\r\n          let $plus = inst.siblings('steper-plus')\r\n          $plus.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('reduce', {count: this.count}, this)\r\n\r\n      },\r\n      plus(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[2]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (e === true) {\r\n          this.stat.plus = true\r\n          inst.removeClass('disable')\r\n        }\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count += step\r\n        if (this.count >= this.max) {\r\n          this.count = this.max\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (this.count > this.min && !this.stat.reduce) {\r\n          this.stat.reduce = true\r\n          let $reduce = inst.siblings('steper-reduce')\r\n          $reduce.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('plus', {count: this.count}, this)\r\n      },\r\n      changeNum(inst){\r\n        let count = this.count\r\n        if (typeof inst === 'number') {\r\n          count = inst\r\n          inst = undefined\r\n        }\r\n\r\n        if (!inst) {\r\n          inst = this.children[1]\r\n        }\r\n\r\n        let $counter = inst.siblings('steper-counter')\r\n        $counter.update({\r\n          title: count\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    steperConfig: mkSteper('steper'),\r\n  },\r\n  onReady(){\r\n    let $steper = this.getElementsById('steper')\r\n    $steper.hooks.on('plus', function(param) {\r\n      if (this.count === 10) {\r\n        Pager.alert('不能再多了，仓库没货了')\r\n      }\r\n    })\r\n    $steper.hooks.on('reduce', function(param) {\r\n      if (param.count <= 0) {\r\n        Pager.alert('大哥，买点啊')\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码"}
{"title": "红包小程序小结 ", "author": "Rolan", "pub_time": "2019-12-30 00:33", "content": "最近做了一个红包兑换小程序，遇到了一些问题这里做一下总结。1、需求：回流用户在游戏客户端获取到口令，然后在小程序这边输入口令兑换红包，成功之后钱会发到用户微信账户里。2、流程：若未授权，显示授权按钮。点击授权登录，授权成功后获取到私密字段iv和encryptedData，调取登陆接口，错误则提示相关信息，正确则跳转校验姓名和身份证的页面，校验通过就调取提现接口，成功则提示提现成功，同时显示生成分享图按钮。分享图由用户昵称，头像，二维码，提现金额等等组成。3、框架：uniapp分享图的问题1、 measureText 获取宽度的时候，传入的参数如果是数字，则会返回0。let money = 10;  //这里需要把数字转成字符串\r\nctx.measureText(money).width;\r\n2、绘制图片的时候不要忘了先使用 getImageInfo 转成临时地址，再 drawImage ，如果不经过这步，虽然开发者工具上看到是正常的，但是真机是显示不了。3、需要绘制微信头像的时候，要在后台配置downloadFile合法域名 https://wx.qlogo.cn 4、最初背景图大概170KB，尺寸750*1334，最终绘制出来的分享图太大了。解决方法：把背景图片尽量再压缩，最终是60多KB。调 canvasToTempFilePath 的时候，设置 fileType 为jpg，quality范围是(0,1]，取个合适的值。 5、小程序里面的保存图片并不是长按保存的，需要点击按钮授权。<button  open-type=\"getUserInfo\"  @getuserinfo=\"onGotUserInfo\"></button>、\r\n...\r\nonGotUserInfo(e){\r\n\tuni.saveImageToPhotosAlbum({\r\n\t\tfilePath: this.tempPath,\r\n\t\tsuccess(res) {\r\n\t\t\tuni.showToast({\r\n\t\t\t  title: '保存成功',\r\n\t\t\t  icon: 'success',\r\n\t\t\t  duration: 1500\r\n\t\t\t})\r\n\t\t},\r\n\t\tfail(err){\r\n\t\r\n\t\t}\r\n\t})\r\n}\r\n...\r\n如图：如果用户点击确定，就会正常保存图片到本地相册了。如果用户点击取消，不授权呢？那还能怎么样，点击再弹出原来的弹窗重新授权呗。很遗憾，这里并不能像授权登录弹窗一样点了取消之后，再次点击授权按钮还会唤起那个弹窗。解决方法：在 saveImageToPhotosAlbum 的fail回调函数里面操作，再次获取保存到相册权限。if (err.errMsg === \"saveImageToPhotosAlbum:fail:auth denied\" || err.errMsg === \"saveImageToPhotosAlbum:fail authorize no response\" || err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n  uni.showModal({\r\n\ttitle: '提示',\r\n\tcontent: '需要您授权保存相册',\r\n\tshowCancel: false,\r\n\tsuccess:res=>{\r\n\t  uni.openSetting({\r\n\t\tsuccess(settingdata) {\r\n\t\t  if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限成功,再次点击保存图片按钮即可保存',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  } else {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限失败，将无法保存到相册哦~',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  }\r\n\t\t},\r\n\t\tfail(failData) {\r\n\t\t  console.log(\"failData\",failData)\r\n\t\t},\r\n\t\tcomplete(finishData) {\r\n\t\t  console.log(\"finishData\", finishData)\r\n\t\t}\r\n\t  })\r\n\t}\r\n  })\r\n}\r\n点击取消按钮之后，会跳转到这里。打开设置里的“保存到相册”的开关即可。原生微信小程序和uniapp框架的一些对比针对此次项目，这里挑两点来写。全局变量的管理1、原生微信小程序可以在app.js的globalData对象中对全局变量进行管理app.jsApp({\r\n    globalData: {\r\n        session:\"\"\r\n    }\r\n})\r\npages/index/index.js...\r\nconst app = getApp()//获取应用实例\r\napp.globalData.session = \"xxxx\" //设置\r\napp.globalData.session  //读取\r\n...\r\n2、uniapp用的是vue的那套，所以可以用vuex来管理状态import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nVue.use(Vuex);\r\nconst store = new Vuex.Store({\r\n\t state : {\r\n\t\tsession:\"\"\r\n\t },\r\n\t mutations : {\r\n\t\tgetSession(state, res){\r\n\t\t\tstate.session = res;\r\n\t\t},\r\n\t }\r\n});\r\nexport default store\r\n设置this.$store.commit('getSession',res.session) //接口返回res.session\r\n获取this.$store.state.session\r\n页面获取全局函数返回的值1、原生微信小程序，比如在app.js中获取用户信息保存在 globalData 中userInfo字段，然后页面在onload的时候获取全局的userInfo，你会发现有时候拿不到。由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回，所以需要加入 callback 以防止这种情况。app.jsApp({\r\n  onLaunch: function() {\r\n    this.init()\r\n  },\r\n  init: function() {\r\n    // 获取用户授权结果\r\n    wx.getSetting({\r\n      success: (res) => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({ // 获取用户信息\r\n            success: res => {\r\n              this.globalData.userInfo = res.userInfo;\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            },\r\n            //拒绝授权\r\n            fail: res => {\r\n\r\n            }\r\n          })\r\n        } else {\r\n\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    userInfo: \"\"\r\n  }\r\n})\r\npages/index/index.jsconst app = getApp()\r\nPage({\r\n  data: {\r\n\tuserInfo:\"\"\r\n  },\r\n  onLoad: function() {\r\n    if (app.globalData.userInfo) {\r\n      this.setData({\r\n        userInfo: app.globalData.userInfo,\r\n      })\r\n    } else{\r\n      app.userInfoReadyCallback = res => {\r\n        this.setData({\r\n          userInfo: res.userInfo,\r\n        })\r\n      }\r\n    } \r\n  },\r\n})\r\n2、uniapp是配合vuex和计算属性computed来处理的APP.vueexport default {\r\n\tonLaunch: function() {\r\n\t\tthis.getUserInfo();\r\n\t},\r\n\tmethods:{\r\n\t\tgetUserInfo() {\r\n\t\t\tuni.getSetting({\r\n\t\t\t  success: (res) => {\r\n\t\t\t\tif (res.authSetting['scope.userInfo']) {\r\n\t\t\t\t  uni.getUserInfo({ // 获取用户信息 \r\n\t\t\t\t\tsuccess: res => {\r\n\t\t\t\t\t\tthis.$store.commit('userInfo',{\r\n\t\t\t\t\t\t\tavatarUrl:res.userInfo.avatarUrl,\r\n\t\t\t\t\t\t\tnickName:res.userInfo.nickName\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfail: res => {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t  })\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t})\r\n\t\t},\t\r\n\t}\r\n}\r\npages/index/index.vue获取到 userInfo 便可以使用了，如果需要，还可以使用watch监听。export default {\r\n\tdata() {\r\n\t\treturn {\r\n\r\n\t\t} \r\n\t},\r\n\tonLoad(){\r\n\t\t\r\n\t},\r\n\tcomputed: {\r\n\t\tuserInfo() {\r\n\t\t\treturn this.$store.state.hasUserInfo\r\n\t\t}\r\n\t},\r\n\twatch:{\r\n\t\tuserInfo(val){\r\n\t\t\tif(val){\r\n\t \t\t \t\r\n\t \t\t}\r\n\t \t}\r\n\t},\r\n\tcreated() {\r\n\r\n\t},\r\n\tmethods: {\r\n\t\t\r\n\t}\r\n}"}
{"title": "从CSS角度来做一个模态框 ", "author": "Rolan", "pub_time": "2019-12-30 00:42", "content": "今天我们从CSS角度来做一个下图这种模态框。先上代码： https://developers.weixin.qq....模态框背后的背景是一个fixed定位，四个方向都为0的view，主要是怎么实现中间弹窗的垂直水平居中，这里提供两个方案。1、定位这种方案是将弹窗设置绝对定位后，左边（上边）距设为50%，就是弹窗左上角距父级左上角的距离正好是父级的宽度（高度）的50%，就是在正中间，同时使用 transform 属性，将弹窗向左（上）移动自身宽度（高度）的50%，来实现弹窗正好在水平（垂直）方向都能居中。position: absolute;\r\ntop: 50%;\r\nleft: 50%;\r\ntransform: translateX(-50%) translateY(-50%);2、flex布局这种方案更简单，只需要将父级设置为flex布局的同时设置 justify-content 和 align-items都是 center 就可以了。display: flex;\r\njustify-content: center;\r\nalign-items: center;彩蛋模态框弹出后，在父级上加上 catchtouchmove=\"ture\" 就可以阻止背后页面的上下滚动。"}
{"title": "小程序中解决网络请求缓存 ", "author": "Rolan", "pub_time": "2019-12-30 00:45", "content": "需求\r\n提交小程序审核时，有一个体验测评，产品让我们根据小程序的体验测评报告去优化小程序。\r\n其中有一项是网络请求的优化，给我们出了很大的难题。\r\n文档中是这样解释的：3分钟以内同一个url请求不出现两次回包大于128KB且一模一样的内容\r\n看到这个问题的时候，首先想到的是在响应头上加上cache-control，经过测试发现小程序并不支持网路请求缓存。搜索发现官方明确答复，小程序不支持网络请求缓存：wx.request不支持http缓存\r\n既然官方不支持网络请求缓存，那只能自己想办法解决这个问题了。\r\n先来看一下需求：3分钟内，同一请求只能请求一次。\r\n分析\r\n分析：\r\n\r\n只需做GET请求的网络缓存。\r\n缓存时间如何控制。\r\n做了缓存之后，如何知道3分钟，这个请求在服务端数据有没更新。\r\n提交GET请求前，先检查本地有没有缓存\r\n\r\n前两点比较好实现，虽然小程序不支持网络请求缓存，但我们还是可以利用cache-control来实现这个功能。\r\n首先网络请求需不需要情缓存统一交给服务端去做，服务端在处理GET请求时，统一加上响应头cache-control，如果需要缓存就用max-age=180，如果不需要做网络请求就用no-cache。前端根据响应头信息自己做前端缓存。\r\n其中的难点是前端如何知道服务端数据有没更新，如果服务端数据更新了，前端还是使用缓存这是有问题的。\r\n经过一番思考后发现，前端提交数据后，相应的GET请求数据会更新，也就是说前端只要有数据提交，就应该把缓存清空。\r\n这有一个难点，当前端提交数据时，前端是不知道哪些GET请求会因此更新数据，所以这个问题我们没有解决，我的方法比较粗暴：只要前端提交了数据，就将所有缓存清空。这是一个治标不治本的问题。\r\n实现\r\n公司项目封装了HTTP请求\r\n\r\n拦截请求，如果是GET请求，检查缓存，\r\n\r\n如果缓存没过期，将缓存返回出去，不再发请求\r\n如果缓存过期，发请求\r\n\r\n\r\n\r\nif (request.method.toLowerCase() === \"get\"){\r\n  // param 请求信息\r\n  const cache = this.handleCatchControl(request)\r\n  if (!cache.isRequest)\r\n    return this.listener.onApiResponse(request, 200, cache.data), sequence;   //将缓存返回给对应的请求\r\n}\r\n复制代码\r\n缓存网络请求\r\n\r\n// param 响应头，上下文，响应数据\r\nthis.setCatchControl(headers, context, response.data)\r\n复制代码\r\n两个工具函数\r\n\r\n处理网络缓存\r\n设置网络缓存\r\n\r\n\r\n\r\n\r\n设置网络请求\r\n\r\nGET请求缓存数据，其他请求清空数据\r\n数据格式：\r\n\r\n//如果同时发起多个`GET`请求，需要拼接之前缓存数据\r\nApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n  [context.request.url]: {    //api\r\n    data,   //响应数据\r\n    expireTime: Number(cacheControl.split(\"=\")[1] + '000'),   //过期时间\r\n    cacheTime: new Date().getTime(),    //缓存时间\r\n  }\r\n})\r\n复制代码\r\n\r\n// param 响应头，上下文，响应数据\r\nsetCatchControl(responseHeader: any, context: any, data: any) {\r\n  if (context.request.method.toLowerCase() === \"get\") {\r\n    const headers = HandleHeaders.get(responseHeader)\r\n    const cacheControl = headers[\"cache-control\"]\r\n    if (cacheControl && cacheControl !== \"no-cache\") {\r\n      ApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n        [context.request.url]: {\r\n          data,\r\n          expireTime: Number(cacheControl.split(\"=\")[1] + '000'),\r\n          cacheTime: new Date().getTime(),\r\n        }\r\n      })\r\n    }\r\n  } else {\r\n    ApiAgent.cacheData = {}\r\n  }\r\n}\r\n复制代码\r\n处理网络缓存\r\n\r\n判断缓存是否存在\r\n判断缓存有没过期，在设置缓存时，比对当前时间和缓存时间，是否小于失效时间\r\n\r\n\r\n\r\n// param 请求信息\r\nhandleCatchControl(request): any {\r\n  const cacheArr = ApiAgent.cacheData\r\n  if (Object.keys(cacheArr).length === 0)\r\n    return { isRequest: true }\r\n  let cache = {}\r\n  Object.keys(cacheArr).forEach(cacheArrKey => {\r\n    if (cacheArrKey === request.url) {\r\n      cache = cacheArr[cacheArrKey]\r\n    }\r\n  })\r\n  const newDate = new Date().getTime()\r\n  if (newDate - cache.cacheTime < expireTime){\r\n    return { isRequest: false, data: cache.data }\r\n  }\r\n  return { isRequest: true}\r\n}\r\n复制代码\r\n响应头全部变成小写，在小程序中，无法确定响应头的大小写会导致报错，所以统一处理响应头\r\n\r\nclass HandleHeaders {\r\n  static get(headers: { [key: string]: string }) {\r\n    const headersData: any = {}\r\n    Object.keys(headers).forEach(key => {\r\n      headersData[key.toLowerCase()] = headers[key]\r\n    })\r\n    return headersData\r\n  }\r\n}\r\n复制代码总结\r\n有一点没有说，就是这个缓存是保存在哪里的？\r\n既没有用localStorage，也没有用globalapp，用的是类的静态属性。\r\n这样做有3个好处：\r\n\r\n使用localStorage数据不好清除，后期可维护性也较差\r\n缓存挂在globalapp和请求无直接联系\r\n无需在退出小程序时手动清理缓存\r\n\r\n我在使用时遇到一个坑，是因为自己没有理解：类能保存数据的，不能保存状态，但类的对象是既可以保存数据，也可以保存状态的。\r\n最后，此方法还是有很大的优化空间。\r\n另外可添加微信ttxbg180218交流"}
{"title": "小程序初实践总结 ", "author": "Rolan", "pub_time": "2019-12-31 00:05", "content": "近期组内接了小程序项目，也是有幸能够加入到项目中，做一些简单的开发。之前对小程序有所接触，但是仅限于自己了解和书写demo，真正项目开发还是第一次~开发过程中也是遇到了一些不熟悉和自己觉得是小坑的地方，做个简单总结，给自己做个记录，同时给需要的小伙伴一些小小参考。一、添加一个新组建，控制台报错“Component is not found in path '../../components/xx/xx'”。答：这个问题开始是很迷茫的，仔细检查了文件名称、引用路径以及父组件usingComponents，都没有发现有问题，但是控制台依旧提示找不到对应组件。后面经过大老提示： 对于一个新的组件，必须在对应的js里添加Component({})，json文件里也要写上component:true。加上相关配置后，控制台就不会飘红了。二、text组件，默认会出现上内边距。答：使用text组件展示文字内容，看上去并没有什么技术而言，直接引用就好了（心里默默开森）<text>\r\n  this is component\r\n</text>复制代码但是，看到效果之后，显然有点蒙圈，为什么上边会出现那么大的距离啊？！第一个想法是去看css，是否有默认内边距样式，然而并没有；通过padding、margin去设置值，也没什么用；然后。。然后。。。我就不知道怎么办了，只好请教度娘。网上有小伙伴给出了答案，其实并不是样式问题，而是text组件本身问题，要修改这个问题，只需要把text标签和内容写在一行就可以了。<text>this is component</text>\r\n复制代码三、小程序分享功能，页面分享和按钮分享功能。答：众所周知，小程序是可以进行分享的，有两种方式，一个是自带的分享功能，另一个是页面上按钮点击分享。本质上他们调用的是同一个方法，即onShareAppMessage，可以通过options参数的options.from区分是来自按钮还是原生分享，可以通过设置对应字段修改分享展示的内容，不设置则默认分享当前页。onShareAppMessage (res) {\r\n  // 来自页面内转发按钮    \r\n  if (res.from === 'button') {\r\n     return {\r\n        title: `标题`,      //分享标题        \r\n        path: shareUrl,    //分享的链接        \r\n        imageUrl:‘’        //分享展示的图片           \r\n     };    \r\n   } else {      \r\n     return {        \r\n       title: `分享标题`,        \r\n       imageUrl:''    \r\n     };\r\n   }\r\n}复制代码按钮分享，只需要给button添加一个open-type即可，<button open-type=\"share\"></button>。但是此时按钮会有默认样式，可以通过控制台查看，进行css修复样式，分享回调同样调用上边方法。四、小程序内获取某个元素或者组件距离顶部初始高度答：实际开发中，我们基本会遇到需要获取某个元素位置信息的需求，早在jq一把梭的时代，获取这些属性值是很容易的，直接一个api就可以了。同样的小程序里也有比较实用的方法，我们可以给需要获取位置的元素/组件一个id，然后通过下面方法即可获取：let query = wx.createSelectorQuery().in(this);\r\nquery.select('#testId').boundingClientRect(function(rect){\r\n    //rect即包含了所需要的各种位置信息，如top、left、right、bottom等\r\n})复制代码如果在页面初始化时需要获取到位置，可以在onLoad方法里使用（最好使用setTimeout，否则可能会取不到），获取对应值之后就可以进行后续的处理了。五、scroll-view组件使用答：滚动组件的使用，在开发中可以说很普遍了。小程序也封装了scroll-view组件，并提供了一些封装好的方法，使用起来可以说很方便了，但是也不可避免的有一些需要注意的地方。1、scroll-view的绑定scroll事件不触发当页面组件按照文档方法书写完成后，去滚动页面发现页面滚动事件并没有触发，后面经过仔细查看，确定问题原因是scroll-view没有设置高度，而且必须是精准高度，不能用百分比。2、scroll-view滚动到某一位置我们开发时可能需要用到点击后滚动到某一位置或者初始化时滚动到对应位置，过去通常是通过锚点方式进行触发，同样的scroll-view为我们封装了一个很好用的方法scroll-into-view，对应的值也是一个id值，具体使用方法及注意事项可以参考文档（ scroll-view ）。3、scroll-view中包含fixed定位元素，滚动时fixed定位元素闪动这个问题算是比较坑了，在scroll-view里面，我们设置某个元素或者组件为fixed定位，在滚动页面时，会发现定位的元素会消失一下然后再出现，虽然不是什么严重问题，但是很影响用户体验。这个问题我看到社区里也有很多人在问，但是目前官方还没有给出合理方法。目前简单的应对方法我总结了两点：一是把定位元素放到scroll-view外部，此类方法可以完美避开上述问题，但是某些场景下可能不太适用；二是，在使用scroll-view时我们通常会设置scroll-with-animation=true即开启滚动过度动画效果，当我们把这个值设置为false时，上述问题也能很好的解决，即使定位元素在scroll-view内部也不会有闪现问题。但是此方法牺牲的也是用户体验，如果有短距离的页面滚动可以使用此类方法。欢迎遇到此类问题的小伙伴进行补充，在官方给出完美方案之前，我们也能有自己的应对方案。六、小程序checkbox样式这个就不得不吐槽一下UI了，其他的都还好，但是对于表单相对应的样式，真的是丑爆了！而且，当你想通过css样式覆盖方法修改的时候，会发现，你的修改根本就是不起作用的！！根本原因就是你所看见的wxml结构与内容和样式所定义的根本不是一个样子！！！当然也有机智的小伙伴探究出了方案（以checkbox为例）：//wxml\r\n<label>\r\n    <checkbox>aaa</checkbox>\r\n</label>\r\n\r\n//wxss\r\n//修改checkbox大小\r\ncheckbox .wx-checkbox-input{}\r\n//修改checkbox选中后的样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked{}\r\n//修改checkbox选中图标样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked::before{}复制代码当然，如果你不喜欢原组件，不想去修改css，完全可以自己仿写一个checkbox，样式自己写，切换效果通过点击事件（参数e，获取data）自己控制就好。关于表单内容，后面会再总结一个自定义表单及自定义校验方法及自己进行的优化。七、小程序页面跳转，跳转到其他域名页面小程序页面跳转，我们可以通过wx.navigateTo()方法进行，但是当需要跳转到不同域页面时，直接跳转链接的方式就不好用了。小程序也为我们提供了方法，即webb-view( 使用方法见文档)。以上就是在初次开发中遇到的问题及总结的使用方法，后面随着使用的增多，肯定还会有更多的问题出现，随时进行添加吧，算是对小程序使用自己的一个总结，有不足和错误之处，还希望各位大大提出宝贵意见。ps：前期初次接触小程序书写demo时，也遇到了一些小问题，付个传送门：初试微信小程序遇到的问题总结"}
{"title": "如何一人五天开发完复杂小程序（前端必看） ", "author": "Rolan", "pub_time": "2019-12-31 00:21", "content": "随着业务需求的不断累加、小程序追求快速产出。在人手不足且开发周期较短的情况下，我们需要找到一个最大化开发效率的方法。而高效率的开发离不开规范化、工程化、组件化。为此整理写下总结，细数小程序中的坑与实践。介绍我们对小程序高效率开发的思考与探索。布局方案导航栏TabBarBasicPage用户系统登录方案初始化登录鉴权优化及 Bug 追踪日志收集数据分析常用优化方案preLoad独立分包加载布局方案我们首先思考的是，在小程序中如何快速且高还原产出页面。为此我们封装了一套页面组件。导航栏目前小程序有如下两种导航栏：常规、自定义导航栏自定义导航栏布局下，我们可以完全控制导航栏样式，赋予导航栏更多交互及 UI 设计上的可能。如上图所示，Readhub 在导航栏中加入了设置按钮，喜茶在个人页中标题渐隐及沉浸式导航栏效果。常规布局下，顶部导航栏部分直接使用小程序提供导航栏。可根据具体业务选择具体布局方案，在我们小程序中，我们选择了全部使用自定义导航栏的方式并对其进行了一定封装。在确定使用自定义导航栏方案后，我们对导航栏进行了拆解拆解后，我们发现可以将自定义导航栏分为两个部分：StatusBar 及 NavigationBar 。通过查阅微信 API ，我们分别通过 wx.getSystemInfoSync 及 wx.getMenuButtonBoundingClientRect 获取到 StatusBarHeight 及 MenuButton 的布局信息。由拆解图可知1 NavigationBarPaddingTop = MenuButtonTop - StatusBarHeight\r\n3 NavigationBarPaddingBottom = NavigationBarPaddingTop\r\n5 NavigationBar = StatusBarHeight + NavigationBarPaddingTop + NavigationBarPaddingBottom + MenuButtonHeight复制代码得到上述数据后，结果简单封装， 我们得到如下方案StatusBar 部分， 我们使用 PaddingTop 填充。可在此基础上可再进一步封装一些通用 NavigationBar 组件。我们封装了一些常用 NavigationBar 组件， 如下所示：沉浸式导航栏自定义 TabBar目前小程序 TabBar 中也存在两种方案。常规 TabBar ：微信提供方案，可修改 icon 、 文字及其对应选中状态。自定义 TabBar ：小程序基础库 2.5.0 开始支持。可通过其实现异形 TabBar 或各种自定义样式。在我们小程序中，我们选择全部使用自定义 TabBar 来实现业务。由于小程序基础库 2.5.0 之后官方才开始支持自定义 TabBar 。我们此处不直接选择使用 custom-tab-bar 方案。选择结合 custom-tab-bar 、 自定义组件及 wx.hideTabBar 的方案实现。具体方案为放置空节点 custom-tab-bar 文件。在页面中按需引入自定义 TabBar 组件。在页面初始化完成后调用 wx.hideTabBar 隐藏原 TabBar 。这样做的好处在于，在基础库 2.5.0 及更高版本时正常显示，在低版本时以最小代价兼容。在 iPhone X 系列下的底部安全区兼容方案如下 1@mixin media-style() { 2  .tab { 3    padding-bottom: 84px; 4  } 5} 6// 适配iPhone X系列下巴 7@media screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) { 8    @include media-style(); 9}1011@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio:3) {12    @include media-style();13}1415@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio:2) {16    @include media-style();17}18// 下面代码只为适配iPhone X在微信调试模拟器中为724px19@media screen and (device-width: 375px) and (device-height: 724px) and (-webkit-device-pixel-ratio: 3) {20    @include media-style();21}复制代码推荐如无特殊需求，建议直接使用微信提供方案，在自定义 TabBar 方案中 安卓手机下拉刷新时， TabBar 会被拉出可视区域。需自定义下拉刷新组件解决方案整合 BasicPage以上方案在线上运行一段时间后稳定后。对自定义导航栏及自定义 TabBar 方案进行了整合。封装了 BasicPage 组件。以我们线上典型页面为例，我们可以将页面分为两大类。基于以上分析结合线上需求，我们对此基础组件进行封装。Taro 框架伪代码，可根据各自使用框架进行封装，思路一致 1class BasicPage extends Taro.Component { 2 3  state = { 4    menuButtonHeight: 32, 5    menuButtonTop: 48, 6    statusBarHeight: 44, 7  }; 8 9  componentDidMount() {10        // ...获取并设置 menuButtonHeight 、 menuButtonTop 、 statusBarHeight11  }1213  render() {14    return (15      <View className='basic-page'>16        {17          this.props.header && <View className={`basic-page-header${this.props.fixed ? ' fixed' : ''}`} style={{18            paddingTop: `${this.state.statusBarHeight}px`,19            height: `${(this.state.menuButtonTop - this.state.statusBarHeight) * 2 + this.state.menuButtonHeight}px`,20          }}21          >22            {this.props.renderHeader}23          </View>24        }25        <View className={`basic-page-body${this.props.tab ? ' tab' : ''}`}>26          {this.props.renderBody}27        </View>28        {this.props.tab && <TabBar active={this.props.tabActive} />}29      </View>30    );31  }32}3334BasicPage.defaultProps = {35  fixed: false, // header 是否浮动36  tab: false,37  header: false,38  tabActive: 'template',39};40复制代码使用中会经常用到 自定义 TabBar 、 自定义 NavigationBar 布局数据。再封装一个工具类获取。 1import Taro from \"@tarojs/taro\"; 2 3function rpx2px(rpx, windowWidth) { 4  return rpx / 750 * windowWidth; 5} 6 7export default class customConfig { 8 9  static fetchAllConfig() {10    const menuButton = Taro.getMenuButtonBoundingClientRect();11    const systemInfo = Taro.getSystemInfoSync();1213    const statusBarHeight = systemInfo.statusBarHeight;14    const headerHeight = (menuButton.top - systemInfo.statusBarHeight) * 2 + menuButton.height;15    const footerHeight = systemInfo.model.indexOf('iPhone X') === -116      ?17      rpx2px(100, systemInfo.windowWidth)18      :19      rpx2px(168, systemInfo.windowWidth);  // 50  8420    const bodyHeight = systemInfo.windowHeight - statusBarHeight - headerHeight - footerHeight;21    const noTabBodyHeight = systemInfo.windowHeight - statusBarHeight - headerHeight;2223    let data = {24      source: {25        menu: menuButton,26        system: systemInfo,27      },28      height: {29        statusBar: statusBarHeight,30        header: headerHeight,31        body: bodyHeight,32        noTabBody: noTabBodyHeight,33        footer: footerHeight,34      },35    };36    Taro.setStorageSync('customConfig', data);37    return data;38  }3940  static get config() {41    let storageInfoSync = Taro.getStorageSync('customConfig');42    if(!storageInfoSync) {43      storageInfoSync = this.fetchAllConfig();44    }45    return storageInfoSync;46  }47}复制代码到此，我们完成对基础页面组件的封装。目前线上运行小程序所有页面都基于该组件进行开发。开发新页面时只需要引用该组件即可。1<BasicPage header tab tabActive='index' 2        renderHeader={ 3          <View 4            className='my-index-header' 5          > 6            <Text>Title</Text> 7          </View> 8        } 9        renderBody={10          <View className='my-index-header'>11            Body12          </View>13        }14/>复制代码用户系统在一个应用中，用户系统是至关重要的。我们通过数个小程序的开发，整理了一套我们目前正在使用的用户系统实践。登录、获取用户信息如上图所示，我们将小程序登录及获取用户信息拆分为两部分。主要有如下考虑：降低用户使用门槛，可先让用户体验部分功能。后续分享或互动时提示授权完善用户信息保证始终持有用户登录态，方便程序处理。如把用户登录及完善用户信息放置一起，在未授权时无法获取自定义登录态。判断变得复杂且无法提前收集 formId同一开发者账号下，多小程序互通时，如有一小程序用户授权过，可通过返回 unionid 直接同步信息，无需再授权，提升用户体验。处理注意点授权获取用户信息时，如果服务端未记录用户 sessionKey ，在 Button type = getUserInfo 回调事件中使用 wx.login 方法获取 code 的话，会导致 sessionKey 变化。从而导致 getUserInfo 时使用 sessionKey 与新 sessionKey 不匹配。从而导致解密用户信息失败。解决方案有如下两种：Button type = getUserInfo 回调事件中使用 wx.login 方法后，再次调用 wx.getUserInfo 方法重新获取加密用户信息。服务端记录 sessionKey ，Button type = getUserInfo 回调后无需调用 wx.login ，直接提交供服务端处理。第一种方案适合简单改造旧项目、快速开发，但强烈建议使用服务端处理方式解决。完善用户信息时，解密用户信息部分请查看官方文档，这里不叙述具体流程https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.htmlunionid 机制另外，在登录流程中服务端向微信换取 sessionKey 过程中，如果满足一定条件，会直接返回 unionid 。同开发者账号下多个小程序时可用 unionid 做用户信息同步，无需再授权。提升用户体验。unionid 机制: https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html小程序初始化及页面初始化处理在日常开发中，我们通常会把登录获取 token 操作放置在小程序初始化中即 app.js 定义的 onLaunch 中。而该生命周期与页面初始化生命周期为同步进行。此时，如果在页面初始化中，需要携带用户登录态请求接口获取信息时，可能出现如下情况因为小程序初始化及页面初始化是同步进行的。若页面初始化时，小程序初始化中登录请求仍未完成。会导致未携带 token 或其他鉴权信息，鉴权失败。最开始我们通过在组件中挂载一个特殊事件 componentDidInit ，待小程序初始化登录请求后获取当前页面实例进行调用。但该方案对代码侵入性太强，最终我们选择维护一个登录请求队列。用上队列的原因在于，在产品需求上经常会有先跳入首页，再从首页跳入二级页的需求，这样能让用户回退一次后，仍然能回到首页。但会导致在不同页面中近乎同时调用 login 方法。在第一种方案中，解决该问题需要获得所有页面实例进行调用。而引入队列后只需要轮询消费队列中函数执行即可。上述流程可解决此问题。伪代码如下：代码仅供理解思路 1let loginDoing = false; 2const loginEvent = []; 3 4const userProfile = observable({ 5  user: { 6    avatar: '', 7    isCompleted: false, 8    nickname: '', 9    uid: 0,10    token: '',11  },12  async loginProcess() {13    if(this.user.token) {14      return this.user;15    }16    loginDoing = true;17    let code;18    try {19      const codeResult = await Taro.login();20      if(codeResult.errMsg !== 'login:ok') {21        throw new Error('Taro.login 失败');22      }23      code = codeResult.code;24    } catch (e) {25      loginDoing = false;26      throw e;27    }28    const result = await post(URL().user.login, {29      code,30    });31    let user = {32      ...result.user,33      token: result.token,34    };35    this.user = user;36    loginDoing = false;37    setTimeout(() => {38      let length = loginEvent.length;39      for(let i = 0; i < length; i++) {40        loginEvent.pop()(user);41      }42    });43    return user;44  },45  login() {46    if(loginDoing) {47      return new Promise((resolve) => {48        loginEvent.push(resolve);49      });50    } else {51      return this.loginProcess()52    }53  },54});复制代码鉴权业务需求中，通常存在某些操作需要 【 用户授权完善信息 】 后才能继续进行，早期项目中都是各自页面中写鉴权代码。因而会涉及大量重复代码，也不利于快速开发。为此我们封装了一套鉴权方案。BasePage通过所有页面基础一个基类 BasePage 。在 BasePage 中写入鉴权逻辑来实现。配合在主页面中使用 AuthorizationModal 组件实现鉴权。代码仅供理解思路1 export default class BasePage extends Component { 2 3    state = { 4        // 鉴权相关 5        showAuthorizationModal: false, 6    }; 7 8    /** 9     * 鉴权相关10     */11    // 授权成功事件12    authSuccessEvent() {13    }1415    // 取消授权事件16    authFailEvent() {17    }1819    async checkAuthorization() {20        // 当前是否有已验证21        let globalData = getGlobalData(STORAGE_KEY.VERIFY);22        if(globalData) {23            return {24                isNew: false,25            };26        } else {27            Taro.showLoading({28                title: '检查授权中...',29                mask: true,30                showTicketModal: false,31            });32            // 如果本地不存在时，先请求接口33            // 未登录过，或新机器34            // 请求token及授权状态35            let res;36            try {37                res = await Taro.login();38            } catch() {39                Toast.fail('登录失败~');40                Taro.hideLoading();41                throw new Error('Taro.login 失败');42            }43            // 请求授权接口44            const result = {};45            if(result.errno === 0) {46                resolve({47                    isNew: false,48                });49            } else {50                // 未授权过51                // 弹窗提示授权52                this.setState({53                    showAuthorizationModal: true,54                });55                this.authSuccessEvent = () => {56                    this.setState({57                        showAuthorizationModal: false,58                    });59                    resolve({60                        isNew: true,61                    });62                };63                this.authFailEvent = () => {64                    this.setState({65                        showAuthorizationModal: false,66                    });67                    reject();68                };69            }70        }71    }72}复制代码页面继承该基类1 class LaunchIndex extends BasePage {}复制代码在页面中置入组件1 {this.state.showAuthorizationModal &&2 <AuthorizationModal onSuccess={this.authSuccessEvent} onFail={this.authFailEvent}/>}3复制代码AuthorizationModal 组件接下来，我们只需要在需要鉴权的操作中如下使用即可1this.checkAuthorization()2  .then((res) => {3   // 授权成功逻辑4       console.log('是否新用户', res.isNew);5   })6   .catch(() => {7    // 授权失败逻辑8    })复制代码该方案好处在于，授权由状态驱动，只需在代码中调用 checkAuthorization 方法即可。AuthorizationView后来，由于第一种方案过于重，对页面代码侵入性较强。为此我们又封装了一套较轻的组件。大部分逻辑中，需要用户主动点击时才进行鉴权，我们基于此思路封装了 AuthorizationView 。对外暴露 onAgree 、 onDeny 方法实现对部分区域的点击鉴权操作。代码仅供理解思路1 class AuthorizationView extends Taro.Component { 2 3  state = { 4    showLoginPanel: false, 5  }; 6 7  /** 8   * 登录 9   */10  click() {11    const { userProfile: { user, }, } = this.props;12    if(user.isCompleted) {13      this.props.onAgree(user);14    } else {15      // 显示登录框16      this.setState({17        showLoginPanel: true,18      });19    }20  }2122  /**23   * 授权登录24   * @param e25   */26  async bindGetUserInfo(e) {27    if(e.detail.errMsg === 'getUserInfo:ok') {28      const { userProfile, } = this.props;29      const userResult = await userProfile.login(true);30      this.setState({31        showLoginPanel: false,32      });33      this.props.onAgree(userResult);34    } else {35      this.props.onDeny();36    }37  }3839  cancel() {40    this.setState({41      showLoginPanel: false,42    });43  }4445  render() {46    return (47      <Block>48        <View onClick={this.click}>{this.props.children}</View>49        {50          this.state.showLoginPanel && <View className='login-panel'>51            <View className='login-panel-main'>52              <View className='login-panel-main-title'>您还未登录</View>53              <View className='login-panel-main-subtitle'>请先登录再进行操作</View>54              <Image className='login-panel-main-image' src='https://p0.ssl.qhimg.com/t01a1e495cc2be1e651.png' />55              <View className='login-panel-main-footer'>56                <View className='login-panel-main-footer-button cancel' onClick={this.cancel.bind(this)}>暂不登录</View>57                <Button className='btn-reset' openType='getUserInfo' onGetUserInfo={this.bindGetUserInfo}>58                  <View className='login-panel-main-footer-button confirm'>立即登录</View>59                </Button>60              </View>61            </View>62          </View>63        }64      </Block>65    );66  }67}6869AuthorizationView.defaultProps = {70  onAgree: () => {71  },72  onDeny: () => {73  },74};7576export default AuthorizationView;77复制代码代码中只需要使用该组件包裹子组件即可使用1 <AuthorizationView onAgree={this.onAgree.bind(this)} onDeny={this.onDeny.bind(this)}>2  <View>生成海报</View>3</AuthorizationView>4复制代码以上两种方案都有在线上业务中使用，具体选型看业务决定优化及Bug追踪在维护阶段，我们会更加关注于用户反馈 bug 时如何复现场景及数据分析。日志收集在小程序基础库版本 2.1.0 后，微信提供了一套日志相关接口：LogManager 。在用户反馈时，通过该接口记录的日志会同步上传至微信后台，可下载查看追踪 Bug。我们通过简单的对其封装，实现一套日志收集机制。1 const _logger = Taro.getLogManager({ level: 0, }); 2 3const Logger = { 4  debug(...args) { 5    _logger.debug(`${dayjs().format('YYYY-MM-DD HH:mm:ss')}"}
{"title": "给你的头像加个圣诞帽吧 ", "author": "Rolan", "pub_time": "2019-12-31 00:43", "content": "看着大伙都在弄这个，我自己也来试一哈，我分别用了两种方式来实现，一种是普通的方式，一种是wxs方式\r\n普通方式\r\n效果图如下：\r\n\r\n思路\r\n\r\n获取头像\r\n选择素材\r\n缩放，移动，旋转素材\r\n生成canvas\r\n生成图片，保存图片\r\n\r\n实现方式\r\n\r\n首先是获取头像，这个不用说，大家应该都会的。\r\n选择素材这里我准备了三张圣诞帽的素材，这个网上有很多，可以自己找下，然后我还做了一个选择手机相册的功能，如果你自己有素材的话也可以直接选择这个功能。\r\n缩放，移动，旋转素材都是通过触摸函数去实现的，这里是先将布局做好，然后在标签上面绑定各个触摸事件，通过返回的值在标签的style里设置实现各个效果。\r\n调整好了之后点击保存头像会获取所有参数并将头像画出来，再通过 wx.canvasToTempFilePath() 将canvas生成图片最后通过 wx.saveImageToPhotosAlbum() 保存图片。\r\n主要代码\r\n主要的函数就是下面这几个，代码片段我会放在文末，没有什么比较难的地方，就是要注意下计算的时候不要算错就行。\r\n\r\n需要注意的点\r\n由于素材的大小可能会有不同，所以在重新选择素材的时候高度要重新设置一下，这里我用了一个方法来重置高度，主要是每次重新选择素材的时候就用 wx.getImageInfo() 这个api去获取图片素材的宽高，再计算出宽高比。\r\n\r\nwxs实现方式\r\n实现方式\r\n思路跟普通方式是一样的，不同的是这里将绑定事件通过 wxs 去实现，直接设置标签的参数而不通过逻辑层去处理，在性能上会比较好一点，不过这种实现方式在进行旋转的时候最后生成的图片会有不准，后面会说到。\r\n参数的获取是通过在标签上设置style，然后点击保存的时候用  wx.createSelectorQuery() 获取各个参数的\r\n\r\n获取旋转的值\r\n由于 wx.createSelectorQuery() 并不能获取到 rotate 这个参数，所以我是通过下面这种方式来拿到旋转的值的，将旋转值以宽度的形式赋值给 .vo-ro\r\n\r\n但是我发现旋转之后生成的图片不是正确的，原因是旋转之后通过 wx.createSelectorQuery() 拿到的宽高并不是图片大小的宽高，而是旋转之后的宽高，按理来说不应该是这样的，即使通过样式旋转，它的宽高应该保持不变才对，这样就造成了参数上的错误，所以画出来的图片是不准确的。\r\n因为加了旋转之后画出来的图片会不准确，暂时想不出别的方法，我把旋转的按钮先注释掉了，只支持缩放跟拖拽。\r\n总结\r\n两种方式，wxs性能要更好，但是效果没第一种的好，看你要哪种了，最后祝大家圣诞节快乐，祝你生活愉快\r\ndevelopers.weixin.qq.com/s/Cizd1RmY7…"}
{"title": "微信小程序使用自定义组件导航实现当前页面高亮 ", "author": "Rolan", "pub_time": "2020-1-2 00:18", "content": "最近开发小程序，需要做一个导航，导航可以通过template写出来，但是这个项目需要在导航中处理一些逻辑，做成组件更方便些。首先新建header文件夹，里面新建对应的js、json、wxml、wxss文件。<!-- 公共头部组件 -->\r\n<view class='headers'>\r\n     <navigator open-type=\"redirectTo\" class='logo' url=\"../index/index\" hover-class=\"none\">\r\n        <image src=\"../../assets/img/logo2.png\" mode=\"widthFix\"></image>\r\n     </navigator>\r\n    <view class=\"phone_nav_switch\" bindtap=\"controlNav\">\r\n        <view class=\"iconfont icon-daohang\" hidden=\"{{navIsShow}}\"></view>\r\n        <view class=\"iconfont icon-guanbi\" hidden=\"{{!navIsShow}}\"></view>\r\n    </view>\r\n    <view class=\"nav\">\r\n        <view class=\"shadow {{navIsShow ? 'active':''}}\" bindtap=\"controlNav\"></view>\r\n        <view class=\"bg {{navIsShow ? 'active':''}}\">\r\n            <view class='con' wx:for=\"{{navs}}\" wx:key=\"item.url\">\r\n                 <navigator open-type=\"redirect\" data-index=\"{{index}}\" class=\"{{index === navActive ? 'active' : ''}}\" url=\"{{item.url}}\" hover-class=\"none\">\r\n                    {{item.text}}\r\n                 </navigator>\r\n            </view>\r\n        </view>\r\n    </view>\r\n    <!-- 返回顶部 -->\r\n    <view class=\"backTop\" bindtap=\"goTop\" hidden='{{floorstatus}}'>\r\n        <text class=\"icon iconfont icon-iconfonticontrianglecopy\"></text>\r\n    </view>\r\n\r\n</view>header.js里的导航数据/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 当前导航高亮\r\n    navActive: {\r\n      // 类型\r\n      type: Number,\r\n      // 默认值\r\n      value: 0\r\n    }\r\n  },\r\n\r\n  data: { \r\n    // 导航开关 \r\n    navIsShow: false,\r\n    currentIndexNav: 0,\r\n    // floorstatus: false,\r\n    navs: [\r\n      {\r\n        text: '网站首页',\r\n        url: '../index/index'\r\n      },\r\n      {\r\n        text: '招商加盟',\r\n        url: '../join/join'\r\n      },\r\n      {\r\n        text: '关于煮田',\r\n        url: '../about/about'\r\n      },\r\n      {\r\n        text: '煮田美食',\r\n        url: '../food/food'\r\n      },\r\n      {\r\n        text: '最新资讯',\r\n        url: '../news/news'\r\n      },\r\n      {\r\n        text: '门店查询',\r\n        url: '../search/search'\r\n      },\r\n      {\r\n        text: '联系我们',\r\n        url: '../contact/contact'\r\n      },\r\n      {\r\n        text: '视频列表',\r\n        url: '../videoItem/videoItem'\r\n      }\r\n\r\n    ]\r\n  },导航放在class=\"nav\"中，header.json文件中写入{\r\n  \"component\": true\r\n}需要引入组件的页面的json文件写入，比如index.json{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"header\":\"../header/header\"\r\n  }\r\n}然后在index.wxml引入组件,navActive是传给组件的值，目的是为了对应导航组件内的导航每一项的index，比如首页的index为0，那我在首页内定义的navActive就是0，<!-- 头部组件 -->\r\n    <view class='header'> \r\n        <!-- 导航高亮传值 -->\r\n         <header navActive='0'></header>\r\n    </view>如果相等当前页面就会高亮需要在在heaer.js设置navActive的类型，通过上面的操作，我是能够实现当前页面导航高亮的，希望能帮到需要的人，如果觉得我上面写的不清楚的话，这是我的githubhttps://github.com/mazixiao/w...,这个是我做好了的"}
{"title": "微信小程序canvas生成海报 文字自动换行 canvas高度动态设置 ", "author": "Rolan", "pub_time": "2020-1-2 00:24", "content": "在微信小程序中分享，官网只提供分享给好友和群聊的能力，未提供分享到朋友圈的api。因此小程序分享到朋友圈通常做法就是利用canvas生成一张动态海报，上面贴一个小程序码图片，分享到朋友圈，长按识别小程序码进入小程序，以达到在朋友圈推广小程序的功能。初始化canvas1.在.wxml中 创建一个canvas, canvasWidth 和 canvasWidth 分别为创建的canvas的宽高。比如我们需要保存的海报尺寸为750px * 1350px; 我们就可以设置canvasWidth = 750；canvasWidth = 1350；这样导出来的图片比较清晰。<view class=\"canvas-box\">\r\n    <canvas canvas-id=\"canvas\" class=\"canvas\" style=\"width: {{canvasWidth}}px; height: {{canvasHeight}}px;\"></canvas>\r\n<view>2.在小程序中canvas层级最高。因此我们需要隐藏canvas,在窗口中不可见。.canvas-box{  \r\n  position: fixed;  \r\n  top: 1000px;  \r\n  left: 1000px;  \r\n  z-index: -10;  \r\n}在js中获得canvas上下文const ctx = wx.createCanvasContext('canvas'); // canvas-id绘制图片小程序绘制图片的api比较简单，一般可直接使用下面的方式const img = '/assets/images/bg.png';\r\nconst imgX = 0;      // 绘制图片在canvas中起点X坐标\r\nconst imgY = 0;      // 绘制图片在canvas中起点Y坐标\r\nconst imgWidth = 0;  // 绘制图片在canvas中宽度\r\nconst imgHeight = 0; // 绘制图片在canvas中高度\r\nctx.drawImage(img, imgX, imgY, canvasWidth, canvasHeight);本地图片小程序绘制本地图片可直接使用，例如上面的 /assets/images/bg.png' 可直接绘制到canvas上面。网络图片小程序不能直接绘制网络图片到canvas中。1.需要通过 wx.getImageInfo 获取图片信息或 wx.downloadFile 下载到本地。2.获取图片信息。网络图片需先配置download域名才能生效。如果需要绘制微信用户头像，也需要将腾讯的域名加入到白名单。这里使用wx.getImageInfo，在页面初始化的时候就请求所有需要绘制到canvas的网络图片.const localImgInfo = {}; // 存储所有网络图片请求到本地的对象\r\nconst imgList = [  \r\n  img1,\r\n  avatar,\r\n];  \r\nimgList.forEach((item, index) => {  \r\n  wx.getImageInfo({  \r\n    src: item,  \r\n  success: function (res) {  \r\n      // 保存到本地数组  \r\n  localImgInfo[item] = res.path;  \r\n  }  \r\n  })  \r\n})\r\n\r\n... (确保网络图片加载完毕后)绘制网络图片\r\n\r\nctx.drawImage(localImgInfo[avatar], imgX, imgY, canvasWidth, canvasHeight);绘制文字ctx.setFontSize(30);          // 文本字体大小\r\nctx.setFillStyle(\"#E1E6F0\");  // 颜色\r\nconst text = '我是文字';\r\nconst textX = 0;  \r\nconst textY = 0;\r\n\r\nctx.fillText(text, textStartX, textY);绘制文字和图片有一个小区别需要注意一下，起始的x,y坐标不一致。绘制图片的x,y坐标是从图片的 左上角 开始计算位置的。绘制文字的x,y坐标是从文字的 右下角 开始计算位置的。文字自动换行ctx.measureText() 能够获取canvas中文字的宽度，可通过此方法手动给文字换行// 将文字绘制到行 长文本自动换行 并返回行数  \r\n/\\*  \r\n\\* params  \r\n\\* @text 需要绘制的文本字符  \r\n\\* @startX 第一行文本的起始X坐标  \r\n\\* @startY 第一行文本的起始Y坐标  \r\n\\* @lineHeight 文本行高  \r\n\\* @MAX\\_WIDTH 单行文字最大宽度，超过临界值自动换行  \r\n\\*  \r\n\\* return rowLength 返回绘制文本的行数  \r\n\\* \\*/\r\nfunction drawText(text, startX, startY, lineHeight, MAX\\_WIDTH) {  \r\n  let allAtr \\= text.split('');  \r\n  let rowArr \\= \\[\\]; // 拆分出来的每一行  \r\n  let rowStrArr \\= \\[\\]; // 每一行的文字数组  \r\n  for (let i \\= 0; i < allAtr.length; i++) {  \r\n    const currentStr \\= allAtr\\[i\\];  \r\n  rowStrArr.push(currentStr);  \r\n  const rowStr \\= rowStrArr.join('');  \r\n  if (ctx.measureText(rowStr).width \\> MAX\\_WIDTH) {  \r\n      rowStrArr.pop(); // 删除最后一个  \r\n  rowArr.push(rowStrArr.join('')); // 完成一行  \r\n  rowStrArr \\= \\[currentStr\\];  \r\n  continue;  \r\n  }  \r\n    // 最后一个字母 直接添加到一行  \r\n  if (i \\=== allAtr.length \\- 1) {  \r\n      rowArr.push(rowStr); // 完成一行  \r\n  }  \r\n  }  \r\n  \r\n  for (let i \\= 0; i < rowArr.length; i++) {  \r\n    ctx.fillText(rowArr\\[i\\], startX, startY \\+ i \\* lineHeight);  \r\n  }  \r\n  return rowArr.length;  \r\n}drawText() 函数主要的作用就是绘制传入的文本，使用 ctx.measureText() 判断单行文字的宽度是否超过单行最大宽度，如果超过就将ctx绘制文本的startY坐标设置为当前startY+文本行高，实现切换到下一行的效果canvas高度动态设置由于项目中生成的海报图片高度随内容变化，导致不同的内容生成的海报高度不一致，所以这边只需要将canvas的高度放在data中，然后根据不同的内容动态计算最终海报的高度，然后设置data中canvas的高度即刻。下面是项目中的实际效果，在这里，海报由三个部分组成，头部，内容，底部。其中头部和底部高度固定，中间的内容高度由后台返回的书籍数量决定，其中可能需要换行的就是书籍的名称和副标题。这里简单的将每一本书作为一块区域，高度固定，因此 内容区域的高度 = 书籍数量 * 书籍高度，通过此方法简单计算出中间内容区的高度，然后动态设置canvas的高度。源码https://github.com/zhaosheng808/canvasPoster提供简单的微信小程序测试号demo，包含请求用户保存canvas图片的授权逻辑。测试号需要将不校验合法域名打开，不然无法下微信头像和外部图片。正式号需要在微信公众平台配置下载域名"}
{"title": "微信小程序长按保存图片 ", "author": "Rolan", "pub_time": "2020-1-2 00:43", "content": "微信浏览器打开h5页面如果是img标签的话，长按会弹出保存图片的选项。但是微信小程序里面不可以，需要自己写这个功能。这个功能有两个点，一个是长按，一个是保存图片到本地。1. 微信小程序关于图片长按的解释，有两种：因此我们选用 bindlongpress 事件2. 微信小程序同样提供了保存图片的接口，是wx.saveImageToPhotosAlbum()3. 值得说的是，保存的接口，两个需要注意的地方：1、需要先授权，调用 wx.getSetting()方法2、保存的图片路径参数，不支持网络路径，而在我们渲染页面时，用到的图片有很大可能是网络路径，这时候我们需要先把网络路径转为可用的本地路径，wx.getImageInfo()方法可以满足需要4. 最后再走个心吧，毕竟我这么可爱1、长按后直接保存未免潦草了些，考虑到用户体验，加入 wx.showActionSheet()2、如果用户拒绝授权 或者 以前拒绝过授权，这时候也应该给他提示，或者展示再次打开授权的入口将将！然后就可以开始写代码了：<image src=\"{{url}}\" data-url=\"{{url}}\" bindlongpress=\"saveImage\"></image>// 长按保存功能--授权部分\r\nsaveImage (e) {\r\n    let _this = this\r\n    wx.showActionSheet({\r\n        itemList: ['保存到相册'],\r\n        success(res) {\r\n            let url = e.currentTarget.dataset.url;\r\n            wx.getSetting({\r\n                success: (res) => {\r\n                    if (!res.authSetting['scope.writePhotosAlbum']) {\r\n                        wx.authorize({\r\n                            scope: 'scope.writePhotosAlbum',\r\n                            success: () => {\r\n                                // 同意授权\r\n                                _this.saveImgInner(url);\r\n                            },\r\n                            fail: (res) => {\r\n                                console.log(res);\r\n                                wx.showModal({\r\n                                    title: '保存失败',\r\n                                    content: '请开启访问手机相册权限',\r\n                                    success(res) {\r\n                                        wx.openSetting()\r\n                                    }\r\n                                })\r\n                            }\r\n                        })\r\n                    } else {\r\n                        // 已经授权了\r\n                        _this.saveImgInner(url);\r\n                    }\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })   \r\n        },\r\n        fail(res) {\r\n            console.log(res.errMsg)\r\n        }\r\n    })\r\n},\r\n// 长按保存功能--保存部分\r\nsaveImgInner (url) {\r\n    wx.getImageInfo({\r\n        src: url,\r\n        success: (res) => {\r\n            let path = res.path;\r\n            wx.saveImageToPhotosAlbum({\r\n                filePath: path,\r\n                success: (res) => {\r\n                    console.log(res);\r\n                    wx.showToast({\r\n                        title: '已保存到相册',\r\n                    })\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })\r\n        },\r\n        fail: (res) => {\r\n            console.log(res);\r\n        }\r\n    })\r\n},文章写的比较正序，参考的是这篇倒序文章，喜欢倒序的筒子们可以去看下这篇： https://www.jianshu.com/p/e59...（虽然很痛恨没有视频效果的文章，可是录好了视频的我 实在找不到上传视频的按钮！我好难！！！）"}
{"title": "小程序wifi能力解读与实践 ", "author": "Rolan", "pub_time": "2020-1-3 00:28", "content": "背景\r\n小程序wifi系列接口为系统原生能力。早在2015年，微信就推出了「微信连Wi-Fi」，微信连Wi-Fi是为商家的线下场所提供一套完整和便捷的微信连Wi-Fi的方案。现在已经是一套完整的，便捷的解决方案。顾客通过扫码的方式连接wifi，同时微信还可以向用户下发消息。方案在官方文档已经阐述得很详细，本文就不再赘述。本文重点在于讲解小程序中使用wifi能力遇到的问题和心得。\r\n【微信连wifi】传送门\r\nwifi能力解读\r\nwifi能力简介\r\n在小程序中，使用wifi模块都需要先调用wx.startWifi()来初始化wifi模块。以下能力的使用均需要在wx.startWifi的success回调中使用。\r\n连接wifi\r\nwx.connectWifi({\r\n    SSID: 'mx 的iphone', // Wi-Fi 设备 SSID\r\n    BSSID: '', // Wi-Fi 设备 BSSID\r\n    password: 'xxxxxxxx',\r\n    success(){},\r\n    fail(){},\r\n    complete(){}\r\n})\r\n复制代码connectWifi为我们提供了直连wifi的能力， 仅 Android 与 iOS 11 以上版本支持，需要基础库1.6.0以上。这个一般是我们使用wifi功能的核心API了。在ios中，会出现系统弹框，询问用户是否要连接wifi，只有用户点击确定，connectWifi才会继续进行，否则就走fail回调了。在安卓（以小米note3为例，Anroid9）中则会出现微信连一连的toast。\r\n获取当前已经连接的wifi\r\nwx.getConnectedWifi({\r\n    success(WifiInfo){\r\n        // WifiInfo\r\n    }\r\n})\r\n复制代码从社区中获取的信息得知：signalStrength表示信号强度，iOS 是系统返回的，取值 0-1，安卓经过转换，取值 0-100。数值与信号强度为正比例关系。\r\n获取wifi列表\r\nwx.getWifiList({\r\n    success(e) {\r\n        wx.onGetWifiList((res) {\r\n            // res.wifiList:wifiInfo[]\r\n        })\r\n    }\r\n})\r\n复制代码获取周围的wifi列表，需要先使用getWifiList后使用onGetWifiList进行监听。在ios中，getWifiList会跳到ios系统界面，这是由于ios系统的限制， 目前是无法避免的（其实这么做也无可厚非，wifi信息本来就是敏感的，但是对用户体验有一定的影响）。在安卓中，getWifiList需要获取用户的位置信息，因为可以利用小程序嗅探周边Wi-Fi热点来推断用户所在的位置信息。为了确保用户的隐私不受侵犯，自微信android客户端 7.0.4 起，需要先获取用户地理位置（scope.userLocation）。详情请见wx.getWifiList接口需获取用户位置信息授权后使用\r\n设置AP相关信息\r\nwx.onGetWifiList(function(res) {\r\n    wx.setWifiList({\r\n      wifiList: [{\r\n        SSID: res.wifiList[0].SSID,\r\n        BSSID: res.wifiList[0].BSSID,\r\n        password: '123456'\r\n      }]\r\n    })\r\n})\r\n复制代码\r\n这个接口也挺牛逼，ios特有的。通过设置wifiList，我们在系统页可以直接看到已设置的wifi列表，点了就直接连上了。\r\n其他\r\n\r\nwx.stopWifi 关闭wifi模块\r\nwx.onWifiConnected(function callback)监听连接上 Wi-Fi 的事件\r\nwx.offWifiConnected 取消监听连接上 Wi-Fi 的事件\r\nwx.offGetWifiList(function callback) 取消监听获取到 Wi-Fi 列表数据事件。\r\n\r\n安卓连接wifi\r\n连接指定 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> getWifiList —> onGetWifiList —> connectWifi —> onWifiConnected\r\n复制代码IOS连接wifi\r\n连接指定 Wi-Fi 接口调用时序：(与安卓一致)\r\niOS（仅iOS 11及以上版本支持）：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\niOS（iOS 11.0及11.1版本因系统原因暂不支持）：\r\nstartWifi —> getWifiList —> onGetWifiList —> setWifiList —> onWifiConnected\r\n复制代码实践\r\n笔者在项目中接触到了使用小程序提供的硬件（wifi）能力的场景。利用wifi与socket的能力，我们可以为物联网设备连接wifi。流程如下:\r\n\r\n刚好在开发者社区找到类似的代码片段：\r\n\r\n小程序跟设备数据传输(websocket);\r\n小程序跟设备数据传输(udpsocket);\r\n\r\n\r\nwx.request/wx.connectSocket/wx.uploadFile/wx.downloadFile 的 url 参数允许为 {PORT}/${PATH} 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。\r\n在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。\r\n\r\n局域网通信中，不会进行安全域校验，因此，无需在mp后台添加安全域域名。\r\n总结\r\n借助小程序提供的硬件能力(wifi,蓝牙，NFC)，小程序有了更加广阔的场景。比如【摩拜单车】小程序，有的车需要用户开一下蓝牙，小程序提供的操作原生系统的蓝牙功能便为我们赋能。通过小程序，我们也可以实现与物联网设备通信，通过连接设备热点，利用http/wss/udp传输数据。当然，现在wifi能力还是存在着问题，比如兼容问题，可能有部分安卓手机在连接时会莫名其妙的报错。此时需要对着官方提供的errcode查看具体的原因。\r\n踩过的坑\r\n\r\n安卓部分机型，已经连接wifi，使用connectWifi重新连接，即使传错密码，还是能连上。\r\nA：这个问题目前还没有解决的办法。\r\nios在getWifiList会跳到系统设置页，在connectWifi会出现modal确认是否连接。\r\nA：无法避免。ios系统的限制\r\n调试wifi功能时，无法在开发者工具中调试wifi能力。\r\nA: 目前开发者工具无法进行模拟。并且真机调试时，连接设备热点后会报错。（毕竟真机调试时需要能够访问网络，一般设备热点都不具备访问网络的能力）。目前可以通过 预览+ vconsole解决，还是比较麻烦。\r\n可以主动断开wifi吗？\r\nA: 从文档上看，没有提供这个能力。但是可以尝试连接一个不存在的wifi。\r\n来自文档的注意事项：\r\n\r\n\r\nReference\r\n\r\n微信开放文档 - wifi\r\n微信开放文档 - 局域网通信\r\n小程序WIFI接口和WebSocket创建局域网数据通讯"}
{"title": "探索小程序实现 ", "author": "Rolan", "pub_time": "2020-1-6 00:15", "content": "随着小程序的发展与功能的逐步完善，越来越多的产品需要小程序与 APP 的功能能有一些共性，社区跨平台的解决方案越来越多，比如 taro 等为代表的把一套代码编译成多端运行的机制，本文会使用 Swift 作为原生语言，在 iOS 应用上运行一个小程序 Demo， 使用 Android && React Native 也可以采用同样的思路实现。相关代码仓库： https://github.com/taixw2/rmini编译层编译的目的是为了抹平小程序的与 H5 的差异，利用 Vue 实现数据绑定，利用 Web Component 实现小程序的组件功能。从官网文档中可以看出来，运行一个小程序需要框架（数据绑定渲染）、组件（小程序渲染单元）、api（与原始交互的能力）。框架实现转换成单页应用（一种可行的方案）把所有页面打包成一个 js， 再由 js 管理所有的路由和状态，这种方案适合在 web 端运行，并且是单引擎的方案，在模拟原生的右滑返回等效果也会不尽人意。转换成多页面众所周知，小程序是一个双引擎的框架，上面的方案显然不能达到要求, 双引擎的特点是在运行 javascript 的黑盒子中，无法访问到 DOM && BOM 等。将所有的逻辑代码在原生的 JavascriptCore 中运行，WebView 中的 Javascript 引擎负责数据绑定，需要解决的难点是 JavascriptCore 中的 setData 怎么通知 WebView 渲染， WebView 的事件怎么执行 JavascriptCore，接着往下看。抹平WXMLwxml 是一种类 html 标记语言，他负责所有的渲染规则，包括条件渲染、列表渲染、数据绑定等，与其再实现一种框架，还不如直接利用 Vue 实现同样的功能，再利用各种转换库将 wxml 中的事件转换成 Vue 能够识别的事件，如利用 post-html 可以做到如下的转换:每一个事件绑定的方法全都在原生的 JSContext 中运行，所以此时的事件只需要传递给 JSContext 的作用。抹平WXSSwxss 作为小程序的样式语言，其余 css 的主要区别就是多了一个 rpx 单位，以下是官网的换算表：根据上表可得知， rpx = (750 / 屏幕宽度) * px ;在传统的移动端页面，我们的高清方案，一般需要获取 dpr， 然后修改动态修改 viewport 和 html 上的 font-size，但是小程序的代码因为是放在了设备本地，所以可以在下载小程序页面之后，我们还有一次编译机会，这时就可以把 rpx 根据当前设备的屏幕宽度替换成对应的 px。还有一个 @import ，则利用 scss 或 less 就可以合并到同一个 css 文件中,而全局样式则可以在构建 WXML 的时候再植入进入抹平组件组件具有独特的功能和自己的渲染规则，比如 scroll-view 具有 scroll-x 和 scroll-y 等属性控制滚动条。在 HTML5 中有一个重大的功能 web-component ，它能够自定义 html 元素，并且能够监控属性的变化，非常适合实现小程序组件。如：（使用了 lit-element 框架）这里用了 lit-element 这个框架，能够简化一些操作。抹平 Page 和 AppApp 负责整个应用的生命周期以及存一些全局的数据， getApp 能获取到 app 的信息。 所以类似的结构可能是这样的：getApp 能够直接访问到内部对象，并且在最顶层声明，这样每一个的地方都能访问到 getApp。初始化一个页面都需要是实例化 PageClass, 即使再次进入（不是返回到这个页面）这个页面页需要再次重新实例化，每次实例化都需要关联一个 webviewId, 这个 ID 与原始的 webview 关联，这样每个 PageClass 中的 setData 都能找到对应的 webview 进行再次渲染，所以对应的代码可能是这样的：抹平 API通过 API 能够直接调用原生的功能，比如 wx.request ， 如果直接在 webview 中的 JSContext 中运行的话，则可能存在跨域，但是放在原生就不会存在这个问题。实现JSContext 调用原生代码的功能，需要给 JSContext 中植入一个 JSBridge，如： JSBridge.invoke 和 JSBridge.on , invoke 负责同步任务，on 负责异步任务，原生再利用反射（原生的反射真麻烦）调用对应的原生方法，原生可以利用 while(true) 挂起 JSContext，既可以达到同步和异步的方法。打包 JavascriptJavascript 代码打包后被放在 JavascriptCore 中运行，唯一与 Webview 中的 JSContext 打交道的只有 setData , 先看一下打包流程：利用 App.json 构建入口文件利用 rollup 等工具将所有 Javascript 打包成一个文件（目前没有分包）打包流程及其简单，接下来看一下两个 Javascript 引擎的交互过程。打通 JSContext 到 WebView JavascriptCore每次进入一个页面的时候都需要为这个页面的 webview 分配一个 id, 这个 id 至关重要，作为 native 与 JSContext (原生运行 javascript 的上下文对象) 与 webview 交互的唯一标识，JSContext 中需要实例化一个新的 PageClass 关联这个 id， native 中通过 id 保留 webview 的引用。在 JSContext 中植入一个 JSBridge 用于与原生交互，如： JSBridge.setData(webviewId, appId, data), 当 JSBridge 的 setData 被调用后，通过 appId + webviewId 就能找到对应的 webview, 再将 setData 传入 webview 中，在 Vue 接收到 data 后进行渲染， 整个过程如图：打通 Webview JavascriptCore 到 JSContext有了前面的铺垫，接下来再看 webview 如何调用 JSContext 的方法， Webview 唯一能与 JSContext 交互的方式只有事件，事件触发后，需要通过某种方式触发 JSContext 中的方法，最后调用 setData 再返回来重新渲染 webview。webview 中绑定的方法名众多，如： bindtap=\"a\", bindtap=\"b\", bindtap=\"c\" 等，但是可以通过 “抹平 WXML” 的时候最终只保留一个出口，如:v-on:click=\"callClick('a', $event)\" 等，这样 vue 中的 method 只需要实现对应的几个事件便可：结尾利用原生作为桥梁，在两个引擎之间通信，webview 中的 JSContext 负责接收渲染通知，以及发送事件到 Native 的 JSContext 中，JSContext 独立运行，所以既访问不到 window 对象，也访问不到 document 对象。"}
{"title": "微信小程序 接入 腾讯云验证码 ", "author": "Rolan", "pub_time": "2020-1-7 00:06", "content": "前言：最近做了一个小程序抽奖的活动，出现了部分用户恶意薅羊毛的现象，因此考虑接入腾讯云的验证码。其实腾讯的官方文档写的相当清晰： https://cloud.tencent.com/doc...不想啃文档的筒子们的就往下继续看吧~（虽然大同小异）整体效果1、小程序触发验证，跳转到验证码小程序2、在验证码小程序内通过验证，并携带参数跳回原来的小程序3、在原来的小程序内，监测携带回的参数，并作后续操作前提条件验证码接入前，需要先在 验证码控制台 中注册 AppID 和 AppSecret，注册完成后，您可以在控制台的 基础配置 中查看 AppID (下文extraData中使用) 以及 AppSecret。注意，这里的 appId 和 appSecret 和小程序后台的是不一致的！接入步骤1、在你需要的地方，唤起验证码小程序首先在 app.json 配置 navigateToMiniProgramAppIdList，如下：{\r\n  \"navigateToMiniProgramAppIdList\": [\"wx5a3a7366fd07e119\"]\r\n}这个appId是官方文档中直接提供的，搬上去就好。假设你的唤起方式是通过一个这样的按钮事件：<button bindtap=\"toTCaptcha\">验证</button>toTCaptcha: function () {\r\n    wx.navigateToMiniProgram({\r\n      appId: 'wx5a3a7366fd07e119',\r\n      path: '/pages/captcha/index',\r\n      extraData: {\r\n        appId: 'appId' //您申请的验证码的 appId\r\n      }\r\n    })\r\n  }2、在 app.js 获取验证结果由于小程序间相互跳转过程中产生的数据仅能在 app.js 中获取到，故需要在 app.js 的 onShow 中添加以下代码，来捕获验证结果 captchaResultApp({\r\n  // ...\r\n  onShow: function(options) {\r\n    // 解决各类回调的兼容问题\r\n    if (!this.captchaTicketExpire) this.captchaTicketExpire = {};\r\n\r\n    if (options.scene === 1038 && options.referrerInfo.appId === 'wx5a3a7366fd07e119') {\r\n      const result = options.referrerInfo.extraData;\r\n      if (result.ret === 0) {\r\n        const ticket = result.ticket;\r\n        if (!this.captchaTicketExpire[ticket]) {\r\n          this.captchaResult = result;\r\n          this.captchaTicketExpire[ticket] = true;\r\n        }\r\n      } else {\r\n        // 用户关闭了验证码\r\n        // 这里可以加上一些验证失败提示\r\n      }\r\n    }\r\n  },\r\n  // ...\r\n});验证结果（captchaResult） 参数说明：3、将验证结果返回至服务端校验在小程序页面的 onShow 阶段，将验证结果及待提交的表单数据一起提交到服务器，进行校验。// page.js\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    // ...\r\n  },\r\n  onShow() {\r\n    const captchaResult = app.captchaResult;\r\n    app.captchaResult = null; // 验证码的票据为一次性票据，取完需要置空\r\n    if (captchaResult && captchaResult.ret === 0) {\r\n      // 将验证码的结果返回至服务端校验，以及后续的操作\r\n      // const ticket = captchaResult.ticket;\r\n      // const randstr = captchaResult.randstr;\r\n    }\r\n  },\r\n  // ...\r\n});用一个词描述这个开发过程：搬上去！"}
{"title": "小程序跨页面交互的作用与方法 ", "author": "Rolan", "pub_time": "2020-1-7 00:24", "content": "去年年末，微信小程序的分包大小已经到达了 12M 大小,一方面说明小程序的确逐步为开发者放开更大的权限，另一方面也说明了对于某些小程序 8M 的大小已经不够用了。我个人今年也是在开发一个 to B 小程序应用。这里列举一些跨页面交互的场景。对于 B 端应用的业务需求来说，小程序开发的复杂度相对比网页开发要复杂一些。一个是双线程的处理机制问题，另一个是页面栈之间交互问题。注: 笔者目前只需要开发微信小程序，为了在小程序页面中可以使用 properties behaviors observers 等新功能，已经使用 Component 构造器来构造页面。具体可以参考\t微信小程序 Component 构造器 。如果你也没有多端开发的需求，建议尝试使用，可以得到不错的体验。性能优化类对于小程序在页面中点击触发 wx.navigateTo 跳转其他页面，中间会有一段时间的空白加载期(对于分包出去的页面，空白期则会更长)，但是这是小程序内部机制，没有办法进行优化。我们只能眼睁睁的等待这段没有意思的空白期过去。当考虑到跳转页面后的第一件事情便是取数逻辑，那么我们是否能够进行优化呢？答案是肯定的。我们没有办法直接在当前页面取得数据之后再进行跳转操作(这样操作更不好)，但是我们却可以利用缓存当前的请求，详情可以参考我之前的博客文章 ——\tPromise对象 3 种妙用 。代码如下:const promiseCache = new Map()\r\n\r\nexport function setCachePromise(key, promise) {\r\n  promiseCache.set(key, promise)\r\n}\r\n\r\nexport function getCachePromise(key) {\r\n  // 根据key获取当前的数据  \r\n  const promise = promiseCache.get(key)\r\n  // 用完删除，目前只做中转用途，也可以添加其他用途\r\n  promiseCache.delete(key)\r\n  return promise  \r\n}做一份全局的 Map,然后利用 Map 缓存 promise 对象，在跳转之前代码为:// 导入 setCachePromise 函数\r\n\r\nComponent({\r\n  methods: {\r\n    getBookData(id) {\r\n      const promise = // promise 请求\r\n        setCachePromise(`xxx:${id}`, promise)      \r\n    },  \r\n    handleBookDetailShow(e) {\r\n      const id = e.detail\r\n      this.getBookData(id)\r\n       wx.navigateTo({url: `xx/xx/x?id=${id}`})\r\n    }\r\n  }\r\n})而跳转之后的代码也如下所示:// 导入 getCachePromise 函数\r\n\r\nComponent({\r\n    properties: {\r\n      id: Number  \r\n    },\r\n    lifetimes: {\r\n      attached () {\r\n        const id = this.data.id  \r\n        // 取得全局缓存的promise\r\n        const bookPromise = getCachePromise(`xxx:${id}`)\r\n        bookPromise.then((res) => {\r\n          // 业务处理\r\n        }).catch(error => {\r\n          // 错误处理  \r\n        })\r\n      }\r\n    },\r\n    methods: {\r\n      getBook() {\r\n        // 获取数据，以便于 错误处理 上拉刷新 等操作  \r\n      }  \r\n    }\r\n})如此便可以同时处理取数和页面加载的逻辑，当然，这个对于页面有耦合性，不利于后续的删除与修改。但考虑如果仅仅加在分包跳转之间可能会有不错的效果。想要无侵入式，可以进一步学习研究\t微信小程序之提高应用速度小技巧 以及\twxpage 框架，同时考虑到无论是 ToC 还是 ToC 用户，都有可能存在硬件以及网络环境等问题，该优化还是非常值得的。当然微信小程序为了减少冷启动时间，提供了\t周期性更新 数据预拉取 功能。注: 上面的 promiseCache 只作为中转的用途，不作为缓存的用途，如果你考虑添加缓存，可以参考我之前的博客文章——\t前端 api 请求缓存方案 。通知类如果是 pc 端中进行交互，对于数据的 CRUD。例如在详情页面进行了数据的修改和删除，返回列表时候就直接调取之前存储的列表查询条件再次查询即可，而对于移动端这种下拉滚动的设计，就没有办法直接调用之前的查询条件来进行搜索。如果从列表页面进入详情页面后，在详情页面只会进行添加或者修改操作。然后返回列表页面。此时可以提示用户数据已经进行了修改，请用户自行决定是否进行刷新操作。如在编辑页面修改了数据:const app = getApp()\r\n\r\ncomponent({\r\n  methods: {\r\n    async handleSave() {\r\n      //...\r\n      app.globalData.xxxChanged = true\r\n      //...  \r\n    }\r\n  }\r\n})列表界面:const app = getApp()\r\n\r\ncomponent({\r\n  pageLifetimes: {\r\n    show() {\r\n      this.confirmThenRefresh()\r\n    }    \r\n  },\r\n  methods: {\r\n    confirmThenRefresh() {\r\n      // 检查 globalData，如果当前没有进行修改，直接返回 \r\n      if(!app.globalData.xxxChanged) return\r\n      wx.showModal({\r\n        // ...\r\n        complete: () => {\r\n          // 无论确认刷新与否，都把数据置为 false \r\n          app.globalData.xxxChanged = false  \r\n        }  \r\n      })  \r\n    }\r\n  }  \r\n})当然了，我们也可以利用 wx.setStorage 或者 getCurrentPage 获取前面的页面 setData 来进行数据通知,以便用户进行页面刷新。订阅发布类如果仅仅只涉及到修改数据的前提下，我们可以选择让用户进行刷新操作，但是如果针对于删除操作而言，如果用户选择不进行刷新，然后用户又不小心点击到了已经被删除的数据，就会发生错误。所以如果有删除的需求，我们最好在返回列表页面前就进行列表的修改，以免造成错误。mittgithub 上有很多的 pub/sub 开源库，如果没有什么特定的需求，找到代码量最少的就是\tmitt 这个库了,作者是喜欢开发微型库的\tdevelopit 大佬,著名的\tpreact 也是出于这位大佬之手。 这里就不做过多的介绍，非常简单。大家可能都能看明白，代码如下(除去 flow 工具的检查):export default function mitt(all) {\r\n  all = all || Object.create(null);\r\n\r\n  return {\r\n    on(type, handler) {\r\n      (all[type] || (all[type] = [])).push(handler);\r\n    },\r\n\r\n    off(type, handler) {\r\n      if (all[type]) {\r\n        all[type].splice(all[type].indexOf(handler) >>> 0, 1);\r\n      }\r\n    },\r\n    emit(type, evt) {\r\n      (all[type] || []).slice().map((handler) => { handler(evt); });\r\n      (all['*'] || []).slice().map((handler) => { handler(type, evt); });\r\n    }\r\n  };\r\n}仅仅只有3个方法，on emit以及 off。只要在多个页面导入 生成的 mitt() 函数生成的对象即可(或者直接放入 app.globalData 中也可)。Component({\r\n  lifetimes: {\r\n    attached: function() {\r\n      // 页面创建时执行\r\n      const changeData = (type, data) => {\r\n        // 处理传递过来的类型与数据\r\n      }\r\n      this._changed = changeData\r\n      bus.on('xxxchanged', this._changed)\r\n    },\r\n    detached: function() {\r\n      // 页面销毁时执行\r\n      bus.off('xxxchanged', this._changed)\r\n    }\r\n  }\r\n})这里mitt可以有多个页面进行绑定事件，如果需求仅仅只涉及到两个页面之间，我们就可以使用 wx.navigateTo 中的 EventChannel (页面间事件信息通道)。可以参考\t微信小程序wx.navigateTo方法里的events参数使用详情及场景 ,该方案的利好在于，传递到下一个页面的参数也可以通过 EventChannel 来通知，以便于解决 properties 传递数据不宜过大的问题。注: 一个页面展示很多信息的时候，会造成小程序页面的卡顿以及白屏。小程序官方也有长列表组件\trecycle-view 。有需求的情况下可以自行研究，这个不在这里详述。鼓励一下如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。博客地址参考文档微信小程序 Component 构造器微信小程序之提高应用速度小技巧wxpagemittPromise对象 3 种妙用前端 api 请求缓存方案"}
{"title": "从客户端角度窥探小程序架构 ", "author": "Rolan", "pub_time": "2020-1-7 00:42", "content": "小程序自诞生以来。就以一种百家争鸣的姿态展现在开发者的面前。继2017年1月9日微信小程序诞生后，小程序市场又陆续出现了支付宝小程序、头条小程序、百度智能小程序等等，甚至平安内部，也在发展自己的小程序生态。各家都在微信小程序的基础上，面向自己的业务，对架构进行逐步优化调整，但是万变不离其宗，微信小程序终归为小程序鼻祖，也是得益于微信小程序的思想，才造就了如今这百花齐放的业态。说起微信小程序，在体验上的优化，让我很长一段时间认为，这是 Native 层渲染。事实并不完全是，至今不敢相信，webView 的渲染竟能带来如此体验。本篇主要以一个客户端开发者的角度，来对微信小程序、支付宝小程序一探究竟。本篇旨在原理分析，我并未有真实的小程序架构设计经验。说到小程序，不得不需要指出另外一个问题，苹果爸爸 对于 HTML5 app 的更新 的审核问题，目前会有开发者存在这样的疑问，Hybrid 和 H5 是不是要被苹果拒审了呢？其实从更新描述来看，不难发现苹果的主要目的是针对 “核心功能未在二进制文件内” 的 App ，实际上小程序无论是在设计理念上，还是核心技术上，都不存在这样的问题，小程序并非App，小程序是以 App 为载体，尽可能的对 web 页面进行优化而生成的产物。还有一点是 马甲包 日益猖獗，马甲包最后基本都转化成为了条款内描述的 “现金Bocai、彩票抽奖和慈善捐款” 类型，所以苹果想要尽可能的禁止它。而且从微信小程序开发文档来看，微信小程序是典型的 技术推动产品的结果 。关于RN类技术，更不存在这样的问题了，RN本质为 JS 通过 JSCore 调用 Native 组件。实际上它的核心仍然在 Native 端，当然对 code push 我还尚存疑问。关于 RN 的动态更新上，从 bang's 的描述也不难发现苹果爸爸的态度， 只要不是为了绕过审核去做动态更新就可以接受 。二、从微信小程序的发展史说起微信小程序是什么，微信把小程序定义为是 一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验 。便捷和出色有何而来？小程序技术最初来源于 H5 和 Native 间的简单调用，微信构建了一个 WeixinJSBridge 来为H5提供一些 Native 的功能，例如地图、播放器、定位、拍照、预览等功能。关于 Bridge 的具体实现可以参考之前的文章 写一个易于维护使用方便性能可靠的Hybrid框架 。但是微信逐渐的又遇到了另外一个问题，那就 H5 页面的体验问题，微信团队为了解决 H5 页面的白屏问题，他们引入了最近很火的 离线包 概念，当然微信称之为 微信 Web 资源离线存储 ，实际上是一个东西。Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页的加载时间。关于离线包的概念，不了解的话可以参考下我之前的文章 iOS 性能优化 -- H5离线秒开 。但是当页面加载大量 CSS 和 JS 时，依然会有白屏问题，包括 H5 页面点击事件的迟钝感和页面跳转的体验问题。那么基于此问题，应运而生的，小程序技术就诞生了。从微信小程序的发展史，不难看出，小程序实际上是近几年开发者对 H5 体验优化而来的，这也切合了前面所说的， 小程序实际上是典型的技术推动产品的结果 。三、微信小程序原理分析微信小程序自称能够解决以下问题：快速的加载。更强大的能力。原生的体验。易用且安全的微信数据开发。高效和简单的开发。快速加载和原生的体验，这其实都是在体验上的升级，更强大能力实际上源于微信小程序为开发者提供了大量的组件，这些组件有基于web技术，也有基于Native技术，在我看来这和 RN 技术不谋而合。后面我会举一个模仿 RN 实现的小例子来阐述一下它的原理。高效和简单的开发是因为微信小程序开发语言实质上还是基于 web 开发规范，这使得开发前端的人来开发小程序显得更容易。还有一点更重要的就是安全，为什么说小程序是安全的？后面会逐步展开，揭开小程序的神秘面纱。快速加载和原生的体验小程序的架构设计与 web 技术还是有一定的差别，吸取了 web 技术的一些优势，也摒弃了 web 技术中体验不好的地方。最主要的特点就是小程序采用双线程机制，即视图渲染和业务逻辑分别运行在不同的线程中。在传统的 web 开发中，网页开发渲染线程和脚本线程是互斥的，所以 H5 页面中长时间的脚本运行可能会导致页面失去响应或者白屏，体验糟糕。为了更好的体验，将页面渲染线程和脚本线程分开执行：渲染层：界面渲染相关的逻辑全部 在webView 线程内执行，一个小程序存在多个页面，一个页面对应一个 webView，微信小程序限制开发者最多只能创建五个页面。逻辑层：Android采用 JSCore ，iOS采用的 JavaScriptCore 框架运行 JS 脚本。怎么在 JavaScriptCore 运行脚本文件后面会讲。双线程模型是小程序框架与大多数前端 web 框架的不同之处，基于这个模型可以更好的管控以及提供更安全的环境。因为逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。客户端的开发者可能对 DOM 有些陌生，了解编译过程的同学应该知道在编译器编译代码的时候，会有一个语法分析的过程，生成抽象语法树 AST，编译器会根据语法树去检查表达式是否合法、括号是否匹配等。实际上DOM也是一种树结构，经过浏览器的解析，最终呈现在用户面前。通过 JavaScript 操纵 DOM 可以随意改变元素的位置，这对于小程序来说是极为不安全的。所以说逻辑层为小程序带来的另一个特点，易于管控和安全。线程通信基于前面提到的 WeixinJSBridge ：逻辑层把数据变化通知到视图层，触发视图层页面的更新，视图层把触发的事件通知到逻辑层进行业务处理。当我们对渲染层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 Native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层，View 渲染更新视图。渲染层根据 微信小程序开发者文档 描述， 在视图层内，小程序的每一个页面都独立运行在一个页面层级上。小程序启动时仅有一个页面层级，每次调用wx.navigateTo，都会创建一个新的页面层级；相对地，wx.navigateBack会销毁一个页面层级 。大概可以理解为，每个 web 页面都是运行在单独的 webView 里面，这样的好处就是让每个 webView 单纯的处理当前页面的渲染逻辑，不需要加载其他页面的逻辑代码，减轻负担能够加速页面渲染，使其能够尽可能的接近原生，这与小程序跳转页面的体验上也是一致的。实际上在小程序源码内有一个 index.html 文件的存在，这是小程序启动后的入口文件。初次加载的时候，主入口会加载相应的 webView ，这其中就会包括前面所提到的，视图层和逻辑层。逻辑层虽然也提供了 webView ，但是并不提供浏览器相关接口，而是单纯的为了获取当前的 JSCore ，执行相关的 JS 脚本文件，这也是开发小程序是没办法直接操作 DOM 的根本原因。当我们每打开一个新页面的时候，调用 navigateTo 都相当于打开了一个新的 webView ，这样一直打开，内存也会变得吃紧，这也是为什么小程序对页面打开数量有限制的原因了。预加载根据小程序开发文档描述： 对于每一个新的页面层级，视图层都需要进行一些额外的准备工作。在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。除此以外，每当一个页面层级被用于渲染页面，微信都会提前开始准备一个新的页面层级，使得每次调用wx.navigateTo都能够尽快展示一个新的页面 。这在客户端的角度来看，相当于打开新页面之后，对下一个页面的 webView 提前做了预加载，这个思路与当前比较流行的 webView 缓存池的思路不谋而合，原因是在 iOS 和 Android 系统上，操作系统启动 webView 都需要一小段时间，预加载会提升页面打开速度，优化白屏问题。基础库内部优化再往深层次来看，通过小程序开发工具的源码，能找到一个 pageframe.html 的模版文件，具体位置在 package.nw/html/pageframe.html ：看标题就应该很清楚了，这是渲染层的核心模块，它的作用就是为小程序准备一个新的页面，小程序每个视图层页面内容都是通过 pageframe.html 模板来生成的，包括小程序启动的首页。通过查看源码，里面定义了一个属性 var __webviewId__ ，我猜想这是每个 webView 页面的页面 ID ，逻辑层处理多个视图层间的业务逻辑可能就是通过这个ID来做的映射关系。在首次启动时，后台会缓存生成的 pageframe.html 模版，在后面的页面打开时，直接加载缓存的 pageframe.html 模版，页面引入的资源文件也可以直接在缓存中加载，包括小程序基础库视图层底层、页面的模版信息、配置信息以及样式等内容，这样避免重复生成，快速打开页面，提升页面渲染性能。注入小程序WXML结构和WXSS样式关于 pageframe.html 最后是怎么生成相应页面的归功于一个叫 nw.js 的框架，具体实现这里就不讲了，更多的偏向于前端的知识了。逻辑层上面了解了渲染层都做了什么之后，下面在窥探一下，小程序的逻辑层都做了什么。参考 eux.baidu.com/blog/fe/微信小… 不难发现，sevice 层的代码是由 WAService.js 实现的，逻辑层实际上主要提供了 Page， App，GetApp 接口和更为丰富 wx 接口模块，包括数据绑定、事件分发、生命周期管理、路由管理等等。关于视图层和逻辑层间的具体交互细节可以看下这张图：我们写的页面逻辑最后都被引入到了一个叫 appservice.html 的页面中，并且分别从 app.js 开始一一执行；小程序代码调用 Page 构造器的时候，小程序基础库会记录页面的基础信息，如初始数据（data）、方法等。需要注意的是，如果一个页面被多次创建，并不会使得这个页面所在的JS文件被执行多次，而仅仅是根据初始数据多生成了一个页面实例（this），在页面 JS 文件中直接定义的变量，在所有这个页面的实例间是共享的。对于逻辑层，从客户端的角度看，我们应该更关注于逻辑层的JS是怎么注入到JSCore中的。四、看看JavaScriptCore是怎么执行JS脚本的说到JavaScriptCore，我们先来讨论下Hybrid App 的构建思路，Hybird App是指混合模式移动应用，即其中既包含原生的结构又有内嵌有 Web 的组件。这种 App 不仅性能和用户体验可以达到和原生所差无几的程度，更大的优势在于 bug 修复快，版本迭代无需发版。Hybird App的实质并没有修改原 Native 的行为，而是将下发的资源进行加载和界面渲染，类似 WebView。下面通过一个例子来模拟一下 avaScriptCore 执行 JS 脚本来让 Native 和 JS 之间的通信。关于 JavaScriptCore 的具体使用可以参考下戴铭的 深入剖析 JavaScriptCore 。我们打算实现这样的功能：通过下发JS脚本创建原生的 UILabel 和 UIButton 控件并响应事件，首先编写 JS 代码如下：(function(){\r\n console.log(\"ProgectInit\");\r\n //JS脚本加载完成后 自动render界面\r\n return render();\r\n })();\r\n\r\n//JS标签类\r\nfunction Label(rect,text,color){\r\n    this.rect = rect;\r\n    this.text = text;\r\n    this.color = color;\r\n    this.typeName = \"Label\";\r\n}\r\n//JS按钮类\r\nfunction Button(rect,text,callFunc){\r\n    this.rect = rect;\r\n    this.text = text;\r\n    this.callFunc = callFunc;\r\n    this.typeName = \"Button\";\r\n}\r\n//JS Rect类\r\nfunction Rect(x,y,width,height){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n}\r\n//JS颜色类\r\nfunction Color(r,g,b,a){\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a;\r\n}\r\n//渲染方法 界面的渲染写在这里面\r\nfunction render(){\r\n    var rect = new Rect(20,100,280,30);\r\n    var color = new Color(1,0,0,1);\r\n    var label = new Label(rect,\"这是一个原生的Label\",color);\r\n\r\n    var rect4 = new Rect(20,150,280,30);\r\n    var button = new Button(rect4,\"这是一个原生的Button\",function(){\r\n                            var randColor = new Color(Math.random(),Math.random(),Math.random(),1);\r\n                            TestBridge.changeBackgroundColor(randColor);\r\n                            });\r\n    //将控件以数组形式返回\r\n    return [label,button];\r\n}\r\n复制代码创建一个 OC 类 TestBridge 绑定到 JavaScriptCore 全局对象上：@protocol TestBridgeProtocol <JSExport>\r\n- (void)changeBackgroundColor:(JSValue *)value;\r\n@end\r\n\r\n@interface TestBridge : NSObject<TestBridgeProtocol>\r\n\r\n@property(nonatomic, weak) UIViewController *ownerController;\r\n\r\n@end\r\n复制代码#import \"TestBridge.h\"\r\n\r\n@implementation TestBridge\r\n\r\n- (void)changeBackgroundColor:(JSValue *)value{\r\n    self.ownerController.view.backgroundColor = [UIColor colorWithRed:value[@\"r\"].toDouble green:value[@\"g\"].toDouble blue:value[@\"b\"].toDouble alpha:value[@\"a\"].toDouble];\r\n}\r\n\r\n@end\r\n复制代码在 ViewController 中实现一个界面渲染的 render 解释方法：#import \"ViewController.h\"\r\n#import <JavaScriptCore/JavaScriptCore.h>\r\n#import \"TestBridge.h\"\r\n\r\n@interface ViewController ()\r\n\r\n@property(nonatomic, strong)JSContext *jsContext;\r\n@property(nonatomic, strong)NSMutableArray *actionArray;\r\n@property(nonatomic, strong)TestBridge *bridge;\r\n\r\n@end\r\n\r\n@implementation ViewController\r\n\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    //创建JS运行环境\r\n    self.jsContext = [JSContext new];\r\n    //绑定桥接器\r\n    self.bridge =  [TestBridge new];\r\n    self.bridge.ownerController = self;\r\n    self.jsContext[@\"TestBridge\"] = self.bridge;\r\n    self.actionArray = [NSMutableArray array];\r\n    [self render];\r\n}\r\n\r\n-(void)render{\r\n    NSString * path = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"js\"];\r\n    NSData * jsData = [[NSData alloc]initWithContentsOfFile:path];\r\n    NSString * jsCode = [[NSString alloc]initWithData:jsData encoding:NSUTF8StringEncoding];\r\n    JSValue * jsVlaue = [self.jsContext evaluateScript:jsCode];\r\n    for (int i=0; i<jsVlaue.toArray.count; i++) {\r\n        JSValue * subValue = [jsVlaue objectAtIndexedSubscript:i];\r\n        if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Label\"]) {\r\n            UILabel * label = [UILabel new];\r\n            label.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble);\r\n            label.text = subValue[@\"text\"].toString;\r\n            label.textColor = [UIColor colorWithRed:subValue[@\"color\"][@\"r\"].toDouble green:subValue[@\"color\"][@\"g\"].toDouble blue:subValue[@\"color\"][@\"b\"].toDouble alpha:subValue[@\"color\"][@\"a\"].toDouble];\r\n            label.textAlignment = NSTextAlignmentCenter;\r\n            [self.view addSubview:label];\r\n        }else if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Button\"]){\r\n            UIButton * button = [UIButton buttonWithType:UIButtonTypeSystem];\r\n            button.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble);\r\n            [button setTitle:subValue[@\"text\"].toString forState:UIControlStateNormal];\r\n            button.tag = self.actionArray.count;\r\n            [button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];\r\n            [self.actionArray addObject:subValue[@\"callFunc\"]];\r\n            [self.view addSubview:button];\r\n            \r\n        }\r\n    }\r\n}\r\n\r\n-(void)buttonAction:(UIButton *)btn{\r\n    JSValue * action  = self.actionArray[btn.tag];\r\n    [action callWithArguments:nil];\r\n}\r\n\r\n@end\r\n复制代码这样就完成了一个简单的 JS 脚本注入，实际上执行后的样子是这样的：这就是一个简单的执行 JS 脚本的逻辑，实际上 ReactNative 的原理也是基于此，小程序逻辑层与微信客户端的交互逻辑也是基于此。到这里，关于微信小程序渲染层与逻辑层做了什么、怎么做的、优化了什么以及为什么要采用这样的架构来设计，基本都梳理完毕了。小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 JS 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 JS 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的也是逻辑层模块，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。总结一句话就是 webView渲染，JSCore处理逻辑，JSBridge做线程通信 。后面再简要的分析下支付宝小程序，支付宝小程序属于后起之秀，支付宝小程序在微信小程序的基础上，做了一些优化，单从技术角度来看，有点后来者居上的意思。目前支付宝技术通过官方的媒体账号对外暴漏的一些实现细节也在逐步增多。六、再说说支付宝小程序前端框架下面是小程序 native 引擎，包括了小程序容器、渲染引擎和 JavaScript 引擎，这块主要是把客户端 native 的能力和前端框架结合起来，给开发者提供系统底层能力的接口。在渲染引擎上面，支付宝小程序不仅提供 JavaScript+Webview 的方式，还提供 JavaScript+Native 的方式，在对性能要求较高的场景，可以选择 Native 的渲染模式，给用户更好的体验。这段文字来源于支付宝对外开放的技术博客的描述，从这段描述中，我们能够发现支付宝小程序在架构设计上同样采用的渲染引擎加 JavaScript 引擎两部分，包括页面间的切换实际上和微信小程序逻辑基本一致。下面这张是支付宝小程序应用框架的架构图：运行时架构单从这个运行时架构来看，它与微信小程序不同的地方是，webView 页面也就是渲染层通过消息服务直接与逻辑层进行通讯，而不需要像微信的 JSBridge 那样作为中间层，消息服务具体实现细节目前尚不得知。支付宝的JSBridge只会与逻辑层进行通讯，来给小程序提供一些 Native 能力。支付宝的这种架构主要目的是解决渲染层与逻辑层交互的对象较复杂、数据量较大时，交互的性能比较差的问题。支付宝小程序的设计思路比较值得借鉴，微信小程序线程间的通讯是通过 JSBridge ，序列化 json 进行传递的。支付宝小程序重新设计了V8虚拟机，让逻辑和渲染都有自己的 Local Runtime，存放私有的模块和数据。在渲染层和逻辑层交互时，setData 的 对象会直接创建在 Shared Heap 里面，因此渲染层的 Local Runtime 可以直接读到该对象，并且用于 render 层的渲染，保证了逻辑和渲染的隔离，又减少了序列化和传输成本。当然支付宝还有些其他的优化，包括首页离线缓存，缓存时机的处理以及闪屏处理等等问题，这里就不再延伸讨论了（因为很多细节我也不知道）。小程序SDK根据支付宝小程序对外开放的技术文章来看，架构设计还是非常巧妙的，也很值得我们学习，先看图：参考： 独家！支付宝小程序技术架构全解析小程序SDK在架构设计上把它分为了两部分，一部分是核心库基础引擎，一部分是基于基础库开发的插件功能。从上往下看：第一层小程序层，这是小程序开发者使用小程序 DSL 及各种组件开发的代码层。第二层和第三层架应该是小程序内部封装的一些组件和对外提供的相关API等。第四层和第五层是小程序的运行基础框架，主要包含小程序的逻辑处理引擎及渲染层。支付宝基于 ReactNative 增加了 Native 引擎，可以用原生来渲染 UI 。根据支付宝 mPaaS 的介绍来看，目前支付宝的小程序使用的是 React 版，蚂蚁内部的其他 App 有在使用 React Native 版的小程序。基础组件部分和扩展能力部分更像是基于 Bridge 调用的原生能力。六、最后差不多半年多没有写文章了，趁着公司年会时间稍显充裕，对当前的小程序架构进行了下分析和总结，当然，真正的小程序应该比这还要复杂的多，小程序实际上是多年来大前端融合的一个结果，是一套非常成体系的技术方案，看了这么多我想你对小程序也有了初步认识，小程序的核心实际上还是 渲染层 和 逻辑层 的构建，那么如果让你开发一套 小程序SDK ，你会怎样设计它们呢？"}
{"title": "小程序跨页面数据传递与事件响应 ", "author": "Rolan", "pub_time": "2019-12-17 00:27", "content": "在实际工作中有很多场景需要在第二个页面中将用户操作之后的将数据回传到上一页面。接下来将我的方案分享给小伙伴。\r\n\r\n本次示例采用 uni-app 框架和 weui 样式库\r\n\r\n实现思路\r\n\r\n创建一个 Emitter，用于事件处理\r\n创建一个全局的 Storage\r\n在第一个页面创建一个 emitter 对象，并添加事件监听，将 emitter 存储到 Storage 中\r\n在第二个页面从 Storage 中取出 emitter 对象， 并触发事件，将数据传递到第一个页面中做处理\r\n\r\n创建 Emitter\r\nfunction isFunc(fn) {\r\n  return typeof fn === 'function';\r\n}\r\n\r\nexport default class Emitter {\r\n  constructor() {\r\n    this._store = {};\r\n  }\r\n\r\n  /**\r\n   * 事件监听\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  on(event, listener) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    listeners.push(listener);\r\n  }\r\n\r\n  /**\r\n   * 取消事件监听\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  off(event, listener) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    listeners.splice(listeners.findIndex(item => item === listener), 1);\r\n  }\r\n\r\n  /**\r\n   * 事件监听 仅监听一次\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  once(event, listener) {\r\n    const proxyListener = (data) => {\r\n      isFunc(listener) && listener.call(null, data);\r\n\r\n      this.off(event, proxyListener);\r\n    }\r\n\r\n    this.on(event, proxyListener);\r\n  }\r\n\r\n  /**\r\n   * 触发事件\r\n   * @param {String} 事件名\r\n   * @param {Object} 传给事件回调函数的参数\r\n   */\r\n  emit(event, data) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    for (const listener of listeners) {\r\n      isFunc(listener) && listener.call(null, data);\r\n    }\r\n  }\r\n}\r\n\r\n复制代码创建 Storage\r\nexport class Storage {\r\n  constructor() {\r\n    this._store = {};\r\n  }\r\n\r\n  add(key, val) {\r\n    this._store[key] = val;\r\n  }\r\n  \r\n  get(key) {\r\n    return this._store[key];\r\n  }\r\n  \r\n  remove(key) {\r\n    delete this._store[key];\r\n  }\r\n  \r\n  clear() {\r\n    this._store = {};\r\n  }\r\n}\r\n\r\nexport default new Storage();\r\n\r\n复制代码第一个页面中的处理\r\n<template>\r\n  <div class=\"page\">\r\n    <div class=\"weui-cells__title\">选择城市</div>\r\n    <div class=\"weui-cells weui-cells_after-title\">\r\n      <navigator :url=\"`../select/select?id=${cityId}`\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\">\r\n        <div class=\"weui-cell__hd weui-label\">所在城市</div>\r\n        <div class=\"weui-cell__bd\" :style=\"{color: cityName || '#999'}\">{{ cityName || '请选择' }}</div>\r\n        <div class=\"weui-cell__ft weui-cell__ft_in-access\"></div>\r\n      </navigator>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Emitter from '../../utils/emitter';\r\nimport storage from '../../utils/storage';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      cityId: '',\r\n      cityName: '',\r\n    }\r\n  },\r\n  onLoad() {\r\n    const emitter = new Emitter();\r\n\r\n    // 将emitter存到storage中\r\n    storage.add('indexEmitter', emitter);\r\n\r\n    // 添加事件监听\r\n    emitter.on('onSelect', this.handleSelect);\r\n  },\r\n  methods: {\r\n    // 事件处理\r\n    handleSelect(data) {\r\n      this.cityId = data.id;\r\n      this.cityName = data.text;\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n复制代码第二个页面中的处理\r\n<template>\r\n  <div class=\"page\">\r\n    <div class=\"weui-cells__title\">城市列表</div>\r\n    <div class=\"weui-cells weui-cells_after-title\">\r\n      <radio-group @change=\"handleChange\">\r\n        <label class=\"weui-cell weui-check__label\" v-for=\"item in list\" :key=\"item.id\">\r\n          <radio class=\"weui-check\" :value=\"item.id\" :checked=\"`${item.id}` === selectedId\" />\r\n          <div class=\"weui-cell__bd\">{{ item.text }}</div>\r\n          <div v-if=\"`${item.id}` === selectedId\" class=\"weui-cell__ft weui-cell__ft_in-radio\">\r\n            <icon class=\"weui-icon-radio\" type=\"success_no_circle\" size=\"16\" />\r\n          </div>\r\n        </label>\r\n      </radio-group>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport storage from '../../utils/storage';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      list: [\r\n        { id: 0, text: '北京' },\r\n        { id: 1, text: '上海' },\r\n        { id: 2, text: '广州' },\r\n        { id: 3, text: '深圳' },\r\n        { id: 4, text: '杭州' },\r\n      ],\r\n      selectedId: ''\r\n    }\r\n  },\r\n  onLoad({ id }) {\r\n    this.selectedId = id;\r\n    \r\n    // 取出 emitter\r\n    this.emitter = storage.get('indexEmitter');\r\n  },\r\n  methods: {\r\n    handleChange(e) {\r\n      this.selectedId = e.detail.value;\r\n\r\n      const item = this.list.find(({ id }) => `${id}` === e.detail.value);\r\n\r\n      // 触发事件并传递数据\r\n      this.emitter.emit('onSelect', { ...item });\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n复制代码效果展示\r\n传送门\r\ngithub\r\n总结\r\n之所以将Storage定义成全局的，是为了保证第一个页面放到Storage中和第二个页面从 Storage 中取出的emitter是同一个实例，如此第一个页面才能正确监听到第二个页面触发的事件。也可以使用 vuex，将 emitter 放到 state 中。"}
{"title": "小程序 input 使用setData触发bindinput事件 ", "author": "Rolan", "pub_time": "2019-12-17 00:33", "content": "背景\r\nUI设计如下图\r\n\r\n当有输入内容后显示后面的清除按钮，点击清除删除input里的内容\r\n代码实现\r\n我的代码实现是监听bindinput事件，将输入框中的值this.setData({inputValue}), 清除按钮监听点击事件，触发后this.setData({inputValue: ''})\r\n问题\r\nandroid手机上存在一个问题，当input组件是focus状态时，点击清除按钮输入框会闪一下，键盘保持弹出状态，输入框中的内容并没有删除，再次点击后才能删除， 开发者工具和ios均没有上述问题\r\n解决\r\n我发现出现上面的问题是因为在点击清除按钮时额外的触发了一次bindinput事件，将输入框中的值又重新赋值给inputValue了，我一开始以为，额外触发bindinput事件是因为input失焦导致的，但是后面又发现我点击空白的地方并不会触发bindinput事件\r\n后来我发现是setData导致的，找到了原因就可以对症下药了，查看开发文档发现bindinput的返回值中有一个keyCode属性，这个属性只有在键盘输入的时候才会有，用于记录输入的键值，所以我在bindinput中加了一层判断，如果有keyCode这个属性才会进行后面的运算。\r\n缺陷\r\n在开发者工具中使用键盘输入bindinput的返回值中并没有keyCode这个属性，所以在调试时就会存在输入的值并不会赋值给inputValue,需要注释对keyCode的判断。\r\n疑问\r\n上面的问题只会在input组件是focus状态时才会出现，如果一开始不是focus时直接点击清除按钮并不会出现上述问题，所以这个bug可能还和同时监听bindinput和bindblur或者bindfocus有关，这个有待后面进行验证。"}
{"title": "某相册类小程序项目总结 ", "author": "Rolan", "pub_time": "2019-12-19 00:02", "content": "某相册类小程序项目总结1.项目简介一款为家庭设计的亲密社交产品，分为云端存储、智能电视、小程序三个平台，小程序端主要功能包括：建立相册，上传图片、视频，单张图片(视频)的预览、分享、下载、评论相册集预览、分享、下载、评论相册内容管理，删除、下载、设置封面、重命名、设置成开机视屏及屏保图片等照片共享，手机、电视多端家庭内容同步和管理邀请、删除家庭成员，添加、删除绑定设备个性化设置家庭昵称、自己昵称、相册名称2. 主要工作和疑难点汇总2.1 主要工作封装api请求，改造wx.requeset方法，封装http请求抽取公共样式文件，在每个page文件夹的.wxss文件中，通过import 引入，\t如：@import \"../../lib/base.wxss\";抽取公共组件，如单个相册组件、弹出卡片组件、个人头像组件、照片卡片组件，通过在各个页面配置usingComponents参数使用。封装全局公共函数业务逻辑接入百度统计, 统计实时数据在我的应用中添加小程序appkey，下载解压后的js文件到utils文件夹中去，同时将百度添加到request合法域名中去。2.2 业务亮点2.3 疑难点汇总如何在小程序中使用less，可以实时转化为 .wxss文件？小程序Page里的函数比app.js先执行的解决办法fixed 元素 auto 不生效原因封装一个有输入框的modal层组件微信小程序去除button默认边框样式小程序如何获取点击元素信息小程序如何在页面间传递数组对象？小程序如何批量上传图片chooseImage、chooseVideo的回调函数中，wx.uploadFile\r\n上传，更新进度\r\nthis.data.updated_length + 1\r\n\r\n当所有照片都上传成功，updated_length == total_length时，\r\n显示完全上传完毕\r\n\r\n视频的进度显示和图片的不一样\r\n图片是每次上传成功一张，updated_length + 1\r\n视频是调用\r\nwx.uploadFile 对象的 onProgressUpdate 函数，看到视频上传进度，每500毫秒更新一次小程序几个组件如何让swiper 跳转到点击的index ？current 参数\r\npreview了, 还能点击图片么,  失败，不使用\r\nhttps://www.cnblogs.com/BlueCc/p/10172742.html动态设置小程序背景图片如何实现分享、点赞功能分享： onShareAppMessage, 点赞：根据本人是否点赞过，是否有点赞权限\r\n\r\nonShareAppMessage: function(res) {\r\n    var obj = {\r\n      from: 'sharephoto',\r\n      mac: app.globalData.mac,\r\n      open_id: app.globalData.open_id,\r\n      member_id: app.globalData.current_member.member_id,\r\n      family_id: app.globalData.family_id,\r\n      album_id: this.data.album_id\r\n    }\r\n    obj = JSON.stringify(obj);\r\n    var name = app.globalData.current_member.nick_name;\r\n    var shareObj = {\r\n　　　　title: `${name}跟你分享了一本有趣的相册集‘${this.data.album_title}’`,        // 默认是小程序的名称(可以写slogan等)\r\n       path:`pages/login/login?message=${obj}`,\r\n　　　　imageUrl: this.data.album_cover,     //自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径，支持PNG及JPG，不传入 imageUrl 则使用默认截图。显示图片长宽比是 5:4\r\n　　　　success: function(res){\r\n　　　　},\r\n　　　　fail: function(){\r\n　　　　}\r\n　　};\r\n　　return shareObj;\r\n  },\r\n        \r\n\r\n\r\n\r\n//节流,300ms才能点一次\r\nif (this.timer) {\r\n  clearTimeout(this.timer)\r\n}\r\nthis.timer = setTimeout(() => {\r\n  console.log('点击点赞', this.data.like_id);\r\n  server.like(family_id, this.data.album_id, mac, member_id, open_id, app.globalData.open_id, form_id,  this.data.like_id).then((res)=>{\r\n    this.getPhotoBlock();\r\n  })\r\n}, 300)如何实现全选、单选功能对某一天日期的照片，如果没张都选了，传递今天整个相册\r\n每次单选照片都会重新判断是否全选小程序时间过滤器 formatTime util的使用wxs中new Date()等js方法不可用,  所以不能用过滤器，还是用方法为什么多个 formId 会重复，因为不支持同时获取多个 formId, 每次只能获取一个如何实现预览照片，点击后跳转到单张照片？wx.previewImage，这里注意 swiper中，currentIndex 左右滑动是否一致，change函数的处理。如何支持同时预览图片和视频？直接使用 wx.previewImage缺点：不能支持视频，不支持对单张照片做其他操作，智能预览，所以先跳转到 swiper页面\r\n点击照片，预览单张照片。点击视频，跳转到vediofull页面。视频播放是否全屏videofullchange，监听全屏事件，小程序视频根据尺寸判断全屏\r\n在 chooseVideo 的时候， 获取视频的高宽解决，如果有其他照片上传失败怎么办？每次调用 showProgress如何判断小程序来源？分享？邀请？this.data.message.from几个值判断，一共有9种情况\r\n\r\n邀请、分享、在家庭中，不在家庭中，是不是管理员，是否来源扫一扫\r\n\r\n单张相片\r\n相册\r\n受到邀请，不在家庭\r\n受到邀请，在家庭中\r\n扫一扫，不在家庭中\r\n扫一扫，在家庭中，是管理员\r\n扫一扫，在家庭中，不是管理员\r\n不是成员，不是扫一扫\r\n已经在家庭中\r\n其他showActionSheet 有长度限制吗？有6个，超过怎么办？二层底部弹卡如何见人照片与视频内容过滤接入百度移动统计授权问题问题出现在，分享给第三人单张照片的时候，未先授权小程序前，不能查看照片，改变login页面逻辑，去掉入门授权，在点击分享、下载时候再询问授权\r\n首页、家庭页，操作后才授权，点击前会有蒙层安全问题需要操作的页面，onLoad都会 checkInFamily，如果不在任何家庭中，跳转到scan页面哪些情况下展示红包？创建相册、邀请成功成员如何通过扫描二维码获得数据wx.scanCode, 获取返回参数如何判断自己有没有全选评论、点赞、编辑？如果照片、视频来源于分享者，且分享人的id=评论id，用分享人的信息给后端传递参数。无论是获取评论、删除评论、发送评论，被分享人都是使用的分享者信息。一级tab页面需要哪些验证？1，首先检查有没有授权，wx.getUserInfo，授权后下一步操作  \r\n2，检查checkIn，在不在家庭中，有没有操作权限，没有退出  \r\n3，获取成员信息，检查有没有红包，有，领取后下一步操作如何拿到信息扫描？wx.scanCode({\r\n      success: (res)...\r\n      \r\n  通过res值获取获取验证码逻辑me.data.timerFun = setInterval(function () {\r\n    if (me.data.timer > 0) {\r\n    me.setData({timer:me.data.timer-1})\r\n    }else {\r\n    me.setData({timer:'重新发送'})\r\n      clearInterval(me.data.timerFun);\r\n    }\r\n    }, 1000);4. 业务逻辑梳理4.1 项目哪几个page组成？有几个组件？| 16个page  | 5个组件 |\r\n|  ----  | ----  |\r\n| login  | 获取token、管理跳转 |\r\n| le_login  | 同步账号 |\r\n| about | 账号绑定、消息、关于、意见反馈 |\r\n|  photo-edit | 照片编辑页 |\r\n| select-device | 选择屏保页面 |\r\n| h5 | 红包页面 |\r\n| comment | 评论列表页面 |\r\n| swiperphotos | 视频、照片滑动页面 |\r\n| vediofull | 全屏播放视频页面 |\r\n| photomanage | 照片管理页面，全选、反选、下载 |\r\n| photos | 相册所有照片页面 |\r\n| one-photo | 单张照片分享页面 |\r\n| homepage | 首页，我的相册页面 |\r\n| familypage | 家庭首页 |\r\n| del-member | 删除成员、设备页面 |\r\n| my-modal | 弹卡组件|\r\n| member-icon | 头像组件|\r\n| photo-album | 相册组件|\r\n| photo-detail | 相册详情组件|\r\n| red-packet | 红包组件|4.2 挑几个页面看看family 页面？1.1 邀请成员主要通过 onShareAppMessage 函数，将邀请人的信息添加在 path的参数中，在login页面中获得1.2 添加设备调整到 homescan页面1.3 退出家庭//如果只剩本人自己, 解散家庭，否则按照退出家庭算photomanage 页面？（点击，下载、设置壁纸，设置屏保后跳转的页面）全选，反选逻辑\r\n\r\n\r\n\r\n设置封面逻辑，如何做到 所有天，只有一个封面？每一天的照片、视频，是一个组件\r\n\r\nselect_photos  所有选中的照片\r\n\r\n\r\n选照片、下载、删除逻辑：\r\n传值过来的是 按日期分布的数组，按照日期对应，修改当天的照片数组。\r\n遍历所有天的照片，计算选中张数，编号。\r\n\r\n设置封面逻辑：\r\n所有天照片，只有有一天选中了，其他所有置灰。photos 页面？ 点击相册进入的页面功能：上传照片、视频，点赞、评论vediofull 页面首先需要创建视频播放上下文对象   \r\nwx.createVideoContext('myVideo');\r\n\r\n退出：\r\n视频对象 pause，退出全屏， 对象置为null\r\n\r\n监听是否需要横屏：\r\n如果视频宽度大于高度，横屏swiperphotos 页面如何支持，同时预览照片和视频？  \r\n不使用原生自带的 wx.previewImage\r\n视频，跳转到 vediofull 页面\r\n\r\n定位到当前照片是，所有 swiper数组的第几章照片  \r\n初始状态，当前滑动照片数，预览照片上面的显示数字，current_index，和 swiper组件绑定的，current值差1，change函数滑动照片，改变current_index值5. 几个组件简介member-icon:支持头像组件两种形态：文字在头像下方、文字在头像右方my-modal:支持弹出会话层有input文本框，支持编辑和新建功能\r\n    \r\n    新建相册名称为空，编辑相册名称为相册名称，怎么做到的？\r\n    新建，文本框内容为update_value，编辑为从父类传过来的数据，textvalue\r\n    \r\n    如何在操作完编辑后，新建，相册名称为空？\r\n    每次确认后，input框内容置空\r\n    \r\n    实时计算文本框字数？\r\n    bindinput函数photo-album: 相册组件每个相册组件，点击跳转到该相册详情页面red-packet: 红包组件//将红包信息参数发送给后端，传递给前端一个web-view 地址链接\r\n    //webview src指向网页的链接。（承载网页的容器，会自动铺满整个小程序页面）\r\n    <web-view src=\"{{link}}\"></web-view>photo-detail: 相册详情组件，支持同一天照片全选、反选，设置屏保、删除、下载等功能如何区分对照片的操作类型？设置封面？下载？删除？根据前一个页面传过来的操作类型判断\r\n    photo-detail只是一天的照片、视频操作，如何将所有日期选中照片传递给后端？\r\n    每次触发某一天的照片，是一个数组，向父元素触发事件，\r\n    \r\n    this.data.photo_block.forEach((item, index)=> {\r\n     if(item.days == photo.days) {\r\n       this.data.photo_block[index] = photo;\r\n     }\r\n   })\r\n   \r\n     \r\n     如何统计总数？\r\n     每次重新计算选中照片。遍历。6. 问题汇总解答1. 如何在小程序中使用less，可以实时转化为 .wxss文件？微信小程序只支持原生css写法，但是很浪费时间，使用 wxss-cli 可以实时将编写的 .less 文件自动编译为 .wxss 文件1、npm或者yarn全局安装wxss-clinpm install -g wxss-cli2、运行wxss-cli命令(miniProject为小程序目录)，less文件保存时自动编译wxss ./miniProject参考资料2. 小程序Page里的函数比app.js先执行的解决办法问题描述：当我们初始化一个小程序时，默认文件 app.js 中有onLaunch函数，onLaunch: function () {\r\n    console.log(\"onLaunch\");\r\n    wx.login({\r\n      success: res => {\r\n        console.log(\"login\");\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n      }\r\n    })\r\n}默认目录，\"pages/index/index\", 中index.js 有 onLoad函数onLoad: function () {\r\n    console.log(\"index onLoad\");\r\n}小程序网络请求默认为异步请求，在app.js的onLaunch运行后进行异步请求时，程序不会停止，index.js页已执行onload, onload里面的数据会因为没有获取到app.js里的东西而报错, 我们希望onLaunch执行完后再执行onLoad。他们的执行顺序是，onLaunch > index onLoad > login我们希望的执行顺序是：onLaunch > login > index onLoad解决办法定义回调函数, onload里获取不到东西就一直获取，不执行下一步操作，直到获取到app.js的数据才继续执行。若login返回为空，则给app.js注册一个loginSuccessCallback回调，这个回调方法的执行时机，就是app.js中的异步请求完毕把 app.js 中的 onLaunch 中方法拿到 index.js 文件中，按照自己的逻辑写使用promise方法1：App({\r\n  onLaunch: function () {\r\n    wx.login({\r\n      success: res => {\r\n        this.globalData.checkLogin = true;\r\n        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回\r\n        // 所以此处加入 callback 以防止这种情况\r\n        if (this.checkLoginReadyCallback){\r\n          this.checkLoginReadyCallback(res);\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    checkLogin: false\r\n  }\r\n  \r\n  ...\r\n})\r\n \r\n\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n \r\nPage({\r\n  data: {\r\n    test: false\r\n  },\r\n  onLoad: function () {\r\n    let that = this;\r\n    //判断onLaunch是否执行完毕\r\n    if (app.globalData.checkLogin){\r\n      that.setData({\r\n        test:true\r\n      })\r\n    }else{\r\n      app.checkLoginReadyCallback = res => {\r\n            //登陆成功后自己希望执行的，和上面一样\r\n        that.setData({\r\n          test:true\r\n        })\r\n      };\r\n    }\r\n  }\r\n})方法2：把 app.js 中的 onLaunch 中登陆后才执行的方法拿到 index.js 文件中，这是最简单的方法//index.js\r\n\r\nonLoad: function () { \r\n    wx.login({\r\n      success: res => {\r\n        resolve(res); \r\n      }\r\n    })\r\n}方法3：// app.js中定义一个新的方法\r\nApp({\r\n  onLaunch: function () {\r\n      ...\r\n  },\r\n  getAuthKey: function (argument) {\r\n    var that = this;\r\n    return new Promise(function(resolve, reject){\r\n        wx.login({\r\n          success: res => {\r\n            resolve(res); \r\n          }\r\n        })\r\n    })\r\n  }\r\n  ...\r\n  \r\n})\r\n\r\n//index.js\r\nonLoad: function () {\r\n    ...\r\n        \r\n    app.getAuthKey().then(function(res){\r\n      console.log('res')\r\n    })\r\n }参考资料：\t参考1 参考2 参考33. fixed 元素 auto 必须要同时设置 top、leftposition: fixed;\r\ntop: 132rpx;\r\nleft: 30rpx;\r\nwidth: 690rpx;\r\nmargin: 0 auto;4.封装一个有输入框的modal层组件其实很简单，就是在modal中添加新的 input,<view>\r\n    <modal class=\"modal\" wx:if=\"{{!hiddenModal}}\"\r\n     title=\"{{title}}\" confirm-text=\"确定\" cancel-text=\"取消\" bindconfirm=\"modalconfirm\" bindcancel=\"modalcancel\">\r\n        <view class=\"input-line\">\r\n            <input placeholder='请输入内容' maxlength=\"{{ maxlength }}\" bindinput='input' type=\"text\" type=\"text\"  value=\"{{ textvalue }}\" />\r\n            <text>{{ currentlength}}/{{ maxlength }}</text>\r\n        </view>\r\n    </modal>\r\n</view>\r\n\r\n.modal{\r\n    width: 540rpx;\r\n    max-width: 540rpx;\r\n    border-radius: 28rpx;\r\n    .input-line {\r\n        display: flex;\r\n        border: 2rpx solid rgba(0, 0, 0, 0.05);\r\n        font-size: 28rpx;\r\n        padding: 16rpx;\r\n        height: 40rpx;\r\n        line-height: 40rpx;\r\n    }\r\n    input,  text{\r\n        display: inline-block;\r\n        vertical-align: top;\r\n    }\r\n    input {\r\n        flex: 1;\r\n    }\r\n    text {\r\n        width: 90rpx;\r\n        color: #FFA004 ;\r\n    }\r\n}5.微信小程序去除button默认边框样式button::after{\r\n    border: none;\r\n}6.小程序如何获取点击元素信息使用驼峰模式，给点击元素绑定 data-\t* ，通过 event.currentTarget.dataset 获取<image src=\"{{ item.mini_pic }}\" class=\"{{ item.show_opacity ? 'show_opacity' : ''}}\" bindtap=\"tap\" data-message=\"{{ item }}\">\r\n</image>\r\n\r\n// 获取的点击节点元素是一个对象\r\n tap: function(event) {\r\n    var message = event.currentTarget.dataset.message;\r\n}7. 小程序如何在页面间传递数组对象？方法1：A页面跳转链接添加参数，B页面onLoad 接受方法2：设置全局变量 globalData，用的少，一般适用于全局共享的一份信息，如用户open_id等// A页面\r\n// 数组、对象都需要stringify\r\nvar listData = JSON.stringify(that.data.listData)\r\nvar taskArray = JSON.stringify(that.data.taskArray)\r\nwx.navigateTo({\r\n    url: '../workRecord/updateBatch?listData=' + listData + '&taskArray=' + taskArray \r\n})\r\n\r\n//B页面\r\nonLoad: function (options) {\r\n    var that = this\r\n    var listData = JSON.parse(options.listData)\r\n    var taskArray = JSON.parse(options.taskArray)\r\n}\r\n\r\n\r\n\r\n//A页面：\r\napp.globalData.open_id = 3;\r\n//B页面：\r\nvar lala = app.globalData.open_id;8. 小程序如何批量上传图片chooseImage、的回调函数中，wx.uploadFile\r\n    上传，更新进度6. 其他封装http请求class HTTP{request({url,data={},method='POST', header={'content-type':'application/json'} }){\r\n            return new Promise((resolve, reject)=>{\r\n                this._request(url,resolve,reject,data, method, header)\r\n            })\r\n        }\r\n        _request(url,resolve, reject, data={}, method='POST', header){\r\n            wx.request({\r\n                url:url,\r\n                method:method,\r\n                data:data,\r\n                header: header,\r\n                success:(res)=>{\r\n                    const code = res.statusCode.toString()\r\n                    if (code.startsWith('2') && res.data.errno == 10000){\r\n                        resolve(res.data)\r\n                    }\r\n                    else{\r\n                        if(res && res.data && res.data.errmsg) {\r\n                            this._show_error(res.data.errmsg)\r\n                        }\r\n                        else {\r\n                            this._show_error(tips[1])\r\n                        }\r\n                        console.log('错111111111')\r\n                        reject(res)\r\n                    }\r\n                },\r\n                fail:(err)=>{\r\n                    reject(err)\r\n                    console.log('错22222222')\r\n                    this._show_error(tips[1])\r\n                }\r\n            })\r\n    \r\n        }\r\n    \r\n        _show_error(tip){\r\n            if(!tip){\r\n                tip = tips[1]\r\n            }\r\n            wx.showToast({\r\n                title: tip,\r\n                icon:'none',\r\n                duration:2000\r\n            })\r\n        }\r\n    }"}
{"title": "实战：在小程序中获取用户所在城市信息 ", "author": "Rolan", "pub_time": "2019-12-19 00:18", "content": "最近在做自己的小程序《看啥好呢》，这个小程序是使用云开发的方式开发的，功能特别简单，就是获取豆瓣、大麦网的数据展示，虽然功能简单，但还是记录下开发过程和一些技术点，大约会有两篇博文产出，这是第二篇。 GitHub地址背景在《看啥好呢》中有个本地好看 Tab，进去后会获取用户当前所在城市，然后显示该城市的数据，并且显示在导航栏和 Tab上。微信小程序中，我们可以通过调用 wx.getLocation() 获取到设备当前的地理位置信息，这个信息是当前位置的经纬度。如果我们想获取当前位置是处于哪个国家，哪个城市等信息，该如何实现呢？微信小程序中并没有提供这样的API，但是没关系，有 wx.getLocation() 得到的经纬度作为基础就够了，其他的，我们可以使用其他第三方地图服务可以来实现，比如腾讯地图或百度地图的API。所以整个步骤就是：wx.getLocation\r\nreverseGeocoder(options:Object)\r\n在小程序中获取当前的地理位置在小程序中，调用 wx.getLocation ，使用前需要用户授权 scope.userLocation ，代码如下checkAuth(callback) {\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (!res.authSetting\\['scope.userLocation'\\]) {\r\n        wx.authorize({\r\n          scope: 'scope.userLocation',\r\n          success() {\r\n            wx.getLocation({\r\n              type: 'wgs84', \r\n              success(res) {\r\n                callback(res.latitude, res.longitude)\r\n              }\r\n            })\r\n          }\r\n        })\r\n      }\r\n    }\r\n  })\r\n}其中 type 的取值可以为：wgs84 意思返回 gps 坐标gcj02 返回可用于 wx.openLocation 的坐标。运行后会提示如下信息，还需要在 app.json 中配置 permission 字段查询 文档 后得知，得知需要如下配置\"permission\": {\r\n    \"scope.userLocation\": {\r\n      \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n    }\r\n}desc 用于在弹出的授权提示框中展示，如下允许后即可获取接口返回的信息，此过程会在右上角胶囊按钮上显示箭头图标{\r\n    accuracy: 65\r\n    errMsg: \"getLocation:ok\"\r\n    horizontalAccuracy: 65\r\n    latitude: 30.25961    // 纬度，范围为 -90~90，负数表示南纬\r\n    longitude: 120.13026    // 经度，范围为 -180~180，负数表示西经\r\n    speed: \\-1\r\n    verticalAccuracy: 65\r\n}latitude 和 longitude 即是我们需要的两个字段腾讯地图接口逆地址解析以腾讯地图为例，我们可以去腾讯地图开放平台注册一个账号，然后在它的管理后台创建一个密钥(key)，以及进行KEY设置，按照 微信小程序JavaScript SDK 入门及使用限制文档在 KEY设置的启用产品中，勾选 WebServiceAPI，选择签名校验方式，因为我是使用云开发的方式，所以没有什么域名也没有授权IP。这部分代码逻辑如下import QQMapWX from '../../scripts/qqmap-wx-jssdk.min.js'\r\nlet qqmapsdk\r\nPage({\r\n    onLoad: function (options) {\r\n      // 实例化API核心类\r\n      qqmapsdk = new QQMapWX({\r\n         key: '开发密钥（key）'    // 必填\r\n      });\r\n      this.checkAuth((latitude, longitude) => {\r\n         // https://lbs.qq.com/qqmap\\_wx\\_jssdk/method-reverseGeocoder.html\r\n         qqmapsdk.reverseGeocoder({\r\n           sig: 'KEY设置中生成的SK字符串',    // 必填\r\n            location: {latitude, longitude},\r\n            success(res) {\r\n                wx.setStorageSync('loca\\_city', res.result.ad\\_info.city)\r\n            },\r\n            fail(err) {\r\n               console.log(err)\r\n               wx.showToast('获取城市失败')\r\n            },\r\n            complete() {\r\n               // 做点什么\r\n            }\r\n         })\r\n      })\r\n    }\r\n}）reverseGeocoder 接口返回的结果，这里面的字段比较多，详细可以看接口文档，里面好几个字段可以取到城市，其中 ad_info 是行政区划信息，我就取这里面的 city 了。全文完。关注公众号，第一时间接收最新文章。如果对你有一点点帮助，可以点喜欢点赞点收藏，还可以小额打赏作者，以鼓励作者写出更多更好的文章。"}
{"title": "微信小程序文本展开/收起功能 ", "author": "Rolan", "pub_time": "2019-12-19 00:44", "content": "微信小程序中，有时候文本需要实现这样的功能 1、文本超过n行显示省略号 2、省略时，显示 展开/收起 按钮 3、文本不超过n行时，不显示省略号和展开/收起按钮 实现思路文本过长显示省略号、展开和收起功能，通过css样式即可实现 判断是否显示展开/收起按钮： 通过嵌套元素，可以实现text既显示省略号，其高度又是全显示时的高度 通过SelectorQuery选择器，获取text及其父元素的高度，判断text高度是否超过其父元素高度，决定是否显示展开/收起按钮即可代码wxss.frame {  width: 100%;  max-height: 206rpx;  text-align: left;  display: -webkit-box;  overflow: hidden;  text-overflow: ellipsis;  word-wrap: break-word;  white-space: normal !important;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;}.nofold {  display: block;  text-overflow: unset;  -webkit-line-clamp: unset;  max-height: unset;}frame样式设置最大高度，超过3行后出现省略号。overflow为hidden，使得text的超出父元素部分隐藏掉。nofold样式则将最大高度、出现省略号的行数去除，以展示全文。wxml<view id=\"frame\" class='frame {{fold == false ? \"nofold\":\"\"}}'>    <text id=\"content\">{{detail}}</text></view>wxml中，在view元素中嵌套text元素。样式写在view中，text不加任何样式（重要）。分别写上id，方便js代码获取其尺寸信息。 javascriptvar query = this.createSelectorQuery();query.select('#content').boundingClientRect();query.select('#frame').boundingClientRect();query.exec(function(res) {  if (res[0] && res[0].height) {    if (res[0].height > res[1].height) {      self.setData({        fold: true,      });    } else {      self.setData({        fold: null,      });    }  }})js代码中，通过选择器获取两者的高度，如果text高度高于view，则说明有省略文本，显示展开/收起按钮。 js的选择器如果是写在onshow/onload方法中，最好加上延迟，以防止出现判断时元素尚未渲染出来的情况。"}
{"title": "基于微信小程序picker组件开发的时间自定义功能 ", "author": "Rolan", "pub_time": "2019-12-23 00:33", "content": "背景需求：最近接了一个需求，需要做一个类似电影院的选座功能，不同的是需要自己选择日期，预定时间段，然后根据日期+时间段查询座位信息，结合图片说下需求。a、日期组件可选2天内（当天+第二天）。进入页面默认展示当天日期，预定开始时间为当前时间，预定结束时间为开始时间之后30分钟。b、日期确定后才能选择预定开始时间，开始时间以及结束时间我这边是固定的时间点（08:30-22:30）。开始时间分钟段以5分钟为倍数设置往后推算展示，其余时段不显示。如果当前时间为22:00，则不展示当天时间，自动切换到第二天。c、选择预定结束时间。结束时间已开始时间为标记，半小时为倍数生成规则，其余时段不显示。两个时间段确定以后算出预定时长（小时为单位），并调后端接口查询座位信息。"}
{"title": "使用阿里云函数计算构建小程序 ", "author": "Rolan", "pub_time": "2019-12-23 00:43", "content": "在用户使用HyperMotion产品过程中，用户可以通过扫描产品中二维码方式，自助进行Licnese申请。用户提交申请后，请求将发送到钉钉流程中。完成审批后，后台服务将自动根据用户的特征码、申请的数量、可使用的时间将生成好的正式Licnese发送到客户的邮箱中。在原有设计中，使用了Python Flask提供WEB界面，后台使用Celery异步的将用户请求发送至钉钉中，之后采用轮询方式监控审批工单状态，当工单完成审批后，将生成好的License发送至客户提供的邮箱中。实现的效果：这种方式虽然可以满足需求，但是在使用过程中也发现有如下痛点：1、由于对于可用性要求比较高，所以将整套应用以容器化方式部署在云主机上，程序高可用性依赖于底层的平台，基于成本考虑并没有在多可用区进行部署。2、当业务变化时，需要专人将容器从本地容器库上传后进行更新，更新速度慢，敏捷性低。3、需要专人对操作系统层进行维护，并且由于该云主机还运行了其他程序，所以管控上也存在安全风险。基于以上出现的问题，决定对原有二维码程序进行重构，并重新部署在阿里云函数计算服务上。1、第一阶段的改造主要是将二维码扫描程序移植到函数计算服务中。2、第二阶段的改造主要是将发送二维码程序改造为函数计算服务，使用钉钉流程接口中的Callback方法调用该接口，在审批结束后触发发送License流程。2、函数计算服务——无服务，零运维最早接触Serverless的雏形是在2011年开发Cloud Foundry项目时，当时留下一个非常深的印象就是把写好的应用直接上传就完成了部署、扩展等。但是当时Cloud Foundry有一个非常大的局限性，受限于几种开发语言和框架。记得当时的Cloud Foundry只支持Node.js、Python、Java、PHP、Ruby on Rails等，脱离了这个范围则就无法支持，所以当时我其实对这种形态的应用场景存在很大的疑问。这种困惑直到2013年Docker的出现而逐步解开，Docker的出现让开发语言、框架不再是问题，巧妙的解决了Cloud Foundry上述局限性。但是Docker毕竟只是一种工具形态，还不能称得上是平台，紧接着k8s的出现弥补了这一空白，使得Docker从游击队变成了正规军。在这个发展过程中我们不难看出，软件领域发展出现了重大变革，从服务器为王逐渐演进到应用为王的阶段。如果说虚拟化改变了整个物理机的格局，那么无服务化的出现则改变了整个软件开发行业。由于网上各种文档太多了，这里就不对Serverless基本概念进行介绍了，借用一张图说明下。另外还有一点，我们从这里面看到IT行业里的某些岗位，注定要消失的，比如传统运维。3、应用架构整个架构上，分为两个函数计算服务完成：二维码前端：主要用于显示页面，并承担HTTP请求转发代理的角色，将请求转发至二维码后端，发给钉钉，采用HTTP触发器，允许公网访问。二维码后端：用于将用户请求发送给钉钉，该部分服务仍然采用HTTP触发器，不同于前端，该服务是不允许公网直接访问的，但是需要配置NAT网关，通过网关访问钉钉，实现固定IP访问钉钉的效果。从逻辑上讲，整个应用并不复杂，但是在实际使用时遇到最大的问题来自钉钉白名单。由于函数服务对外连接的IP并不固定，所以无法在钉钉中添加，那么就要求函数服务对外连接的IP地址一定要固定。社区中提供的方法主要分为：ECI（运行Nginx充当Proxy），优势是便宜，劣势是高可用性需要自己维护NAT网关，优势是高可用性，劣势是比ECI贵4、构建过程由于篇幅原因，这里只介绍关键步骤。4.1 构建模板为了后续管理和扩展方便，选用了阿里云函数计算中使用flask-web模板进行构建，同时可以将前端静态文件模板存放于项目下（出于统一管理的需要，也可以存放于阿里云的OSS中，作为静态网站发布）。前端我们使用flask-web作为模板创建函数，后端我们直接采用最简单的HTTP函数。函数入口配置，及触发器配置：服务配置，包含公网访问权限，专有网络配置，日志配置，权限配置。前端服务需要公网访问权限，不需要专有网络配置，需要的权限为：AliyunLogFullAccess。后端服务不需要公网访问权限，但是需要配置好的NAT映射的专有网络，由于函数服务在北京2区中在cn-beijing-c和cn-beijing-f，所以在新建交换机时需要使用这两个区。还需要选择安全组，由于出方向并没有明确禁止，所以不需要特别的安全组规则设定。需要的权限为：AliyunLogFullAccess/AliyunECSNetworkInterfaceManagementAccess。配置好后，通过导出功能，分别下载前端和后端代码和配置，在本地进行开发调试。4.2 前端开发我们的前端采用Vue.js进行开发，在main.py同级新建templates目录。Vue编译好的静态文件可以放入该目录中，后续Flask会加载该文件作为入口文件。├── templates\r\n│   ├── index.html\r\n│   ├── static\r\n├── main.py\r\n# main.py sample\r\nfrom flask import render_template\r\n\r\nLICENSE_URL = \"https://[x](https://.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license).cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license\"\r\n\r\n@app.route('/qr_code', methods=['GET'])\r\ndef index():\r\n      return render_template('index.html')\r\n\r\n      @app.route('/qr_code/license', methods=['POST'])\r\n      def create():\r\n            payload = request.json\r\n                resp = requests.post(LICENSE_URL,\r\n                                                 json=payload,\r\n                                                                              headers=DEFAULT_HEADERS)\r\n                return make_response(resp.text, resp.status_code)\r\n4.3 后端开发后端的开发较为简单，实现一个函数支持POST请求，将转发的结果发送至钉钉即可。4.4 本地调试阿里云在本地开发时提供了fun应用部署和开发工具，详细使用方法见： https://help.aliyun.com/document_detail/64204.html 。安装funnpm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) --global\r\nnpm config set disturl [https://npm.taobao.org/dist](https://npm.taobao.org/dist) --global\r\n\r\nnpm install @alicloud/fun -g\r\n配置funfun config\r\n\r\n(venv) [root@ray-dev test_func]# fun config\r\n? Aliyun Account ID xxxxxxxx\r\n? Aliyun Access Key ID ***********r5Qd\r\n? Aliyun Access Key Secret ***********kCCi\r\n? Default region name cn-beijing\r\n? The timeout in seconds for each SDK client invoking 10\r\n? The maximum number of retries for each SDK client 3\r\n? Allow to anonymously report usage statistics to improve the tool over time? Yes\r\nHttp Trigger本地运行fun local start\r\n部署fun deploy\r\n4.5 配置域名解析部署完成后有一点需要特别注意，必须要绑定域名，并且设定必要的路由。如果在没有绑定域名的情况下，服务端会为 response header中强制添加 content-disposition: attachment字段，此字段会使得返回结果在浏览器中以附件的方式打开。（ https://www.alibabacloud.com/help/zh/doc-detail/56103.htm ）"}
{"title": "小程序 找不到可构建的npm包-解决方法 ", "author": "Rolan", "pub_time": "2019-12-23 00:52", "content": "问题复现：在项目根目录执行npm init -y # 初始化npm最近在学习7yue老师的koa课，使用到npm包，出现这个问题，目录结构如下工具 -> 构建 npm -> '没有找到可以构建的 NPM 包'查看文档查阅npm 支持| 微信开放文档)有如下说明此处并没有强制要求 node_modules 必须在小程序根目录下（即 project.config.js 中的 miniprogramRoot 字段），也可以存在于小程序根目录下的各个子目录中。但是不允许 node_modules 在小程序根目录外。所以： npm包应放在小程序根目录下 ，而我搞混了小程序目录和项目根目录小程序根目录(为 /project.config.json 中 miniprogramRoot字段指定)项目根目录(为 / )是两个不同位置原来是我的node-models放错了地方，正确位置应该是**miniprogram**文件夹下问题解决cd miniprogramnpm init -ynpm install lin-ui --production工具 -> 构建 npm目录如下，出现了miniprogram_npm"}
{"title": "【微信小程序】知乎视频查看 ", "author": "Rolan", "pub_time": "2019-12-24 00:04", "content": "第一版做了知乎视频保存视频到本地相册的功能。进一步我们可以做一个增强功能，支持视频查看。用户在登录状态下载过的知乎视频，可以在我的浏览或者查看历史记录在线查看视频这个功能的核心其实是用户身份标识的获取，因为我们只要拿到了用户标识，相应用户下载过的视频就可以和用户标识绑定，存储到数据库中。当用户下次再进入app，只要通过用户标识就可以去数据库中拿用户之前下载过的视频就可以了。表结构如下：CREATE TABLE `wx_user_zhihu_answer` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\r\n  `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '软删除标识',\r\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\r\n  `openId_md5` varchar(128) NOT NULL DEFAULT '' COMMENT 'openId md5加密',\r\n  `answer_url` varchar(128) NOT NULL DEFAULT '' COMMENT '知乎回答url',\r\n  PRIMARY KEY (`id`),\r\n  KEY `idx_is_delete` (`is_delete`),\r\n  KEY `idx_openId_md5` (`openId_md5`),\r\n  KEY `idx_answer_url` (`answer_url`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户及知乎回答信息';获取用户标识我们借鉴微信的例程来设计用户登录逻辑首先按钮上设置open-type=\"getUserInfo\",可以让用户自主选择是否授权小程序。<button class=\"login-btn\" wx:if=\"{{!hasUserInfo}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  点击登录\r\n</button>当用户点击并确认授权，会执行回调的getUserInfo方法getUserInfo: function(e) {\r\n  app.globalData.userInfo = e.detail.userInfo;\r\n  this.setData({\r\n    userInfo: e.detail.userInfo,\r\n    hasUserInfo: true\r\n  });\r\n\r\n  // 登录\r\n  wx.login({\r\n    success: res => {\r\n      const { code } = res;\r\n      app.globalData.loginInfo.jsCode = code;\r\n      this.fetchUserIdInfo();\r\n      // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n    }\r\n  });\r\n  // 获取用户信息\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n        wx.getUserInfo({\r\n          success: res => {\r\n            const { encryptedData, iv } = res;\r\n            // 可以将 res 发送给后台解码出 unionId\r\n            app.globalData.loginInfo.encryptedData = encryptedData;\r\n            app.globalData.loginInfo.iv = iv;\r\n            this.fetchUserIdInfo();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n},\r\nfetchUserIdInfo() {\r\n  const { jsCode, encryptedData, iv } = app.globalData.loginInfo;\r\n  if (!(jsCode && encryptedData && iv)) {\r\n    return;\r\n  }\r\n  wx.request({\r\n    url: userInfoFetchUrl,\r\n    method: \"POST\",\r\n    data: {\r\n      jsCode,\r\n      encryptedData,\r\n      iv\r\n    },\r\n    header: {\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    success: res => {\r\n      res = res.data;\r\n      if (res.code === 1) {\r\n        app.globalData.userIdInfo = res.data;\r\n      }\r\n    }\r\n  });\r\n},getUserInfo可以获取用户的信息，调用wx.login能够拿到code,调用wx.getUserInfo能够拿到encryptedData和iv。拿到code、encryptedData、iv我们就可以调用微信接口以及解码逻辑拿到用户的openId和unionId,我们这部分都放在了后端接口(userInfoFetchUrl)处理，这里我们使用openId标识用户身份，该接口返回的是openId用m5加密后的id。由于所以身份标识相关的操作都在服务器进行且返回的是md5加密后的值，所以极大提高了用户信息的安全性。后端解析用户标识的逻辑如下exports.infoFetch = async params => {\r\n  const { jsCode, encryptedData, iv } = params;\r\n  const sessionRes = await axios.get(\r\n    `${jscode2sessionUrl}?appid=${appId}&secret=${appSecret}&js_code=${jsCode}&grant_type=authorization_code`\r\n  );\r\n  const sessionResData = sessionRes.data;\r\n  const sessionKey = sessionResData.session_key;\r\n  const openId = sessionResData.openid;\r\n  const pc = new WXBizDataCrypt(appId, sessionKey);\r\n  const userInfo = pc.decryptData(encryptedData, iv);\r\n  const unionId = userInfo.unionId;\r\n  if (unionId && openId) {\r\n    return {\r\n      openIdMD5: md5(openId),\r\n      unionIdMD5: md5(unionId)\r\n    };\r\n  } else if (openId) {\r\n    return {\r\n      openIdMD5: md5(openId)\r\n    };\r\n  }\r\n  return {};\r\n};拿到用户标识后工作基本就完成了。我们还需要做一些优化，在app.js的onLaunch回调和登录页onLoad回调中获取用户信息，使得用户再次打开app在有效登录时间内依然可以直接使用用户标识。"}
{"title": "【微信小程序】写一个能自定义尺寸、样式的switch ", "author": "Rolan", "pub_time": "2019-12-24 00:51", "content": "小程序原生的switch不能灵活的修改宽高、样式，很不方便，我这边参考 WeUI 的开关，写了一个可以自定义尺寸样式的switch组件。直接上代码： https://gitee.com/piscdong/we...效果如下图，可以自定义宽高，可以做成方角的代码分析这个switch主要的难点就是点击后背景颜色变换的动画，这里用到了css的transition、transform两个属性来实现动画，以及::before和::after两个伪元素。wxml基本结构为：<view class=\"switch\">\r\n    <view></view>\r\n</view>父级view是整个switch容器，会用到::before做背景色切换动画，::after做禁用时的灰色遮罩。内部的一个view是来回切换的白点。未选中时默认class是switch，选中时增加一个class：switch_checked。选中状态到未选中状态背景有一个从中间变大到全部的白色动画，所以需要给父级view设置一个颜色作为背景色。.switch {\r\n    ...\r\n    background: #00c000;\r\n    position: relative;\r\n}未选中时::before覆盖整个容器，选中时::before设置 transform: scale(0); ，这样选中时白色区域就会缩放到最小，再加上transition的实现动画效果。.switch::before {\r\n    display: block;\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 9999rpx;\r\n    background: #fff;\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked::before {\r\n    transform: scale(0);\r\n}来回移动的白点，未选中时通过 left: 0; 定位到左侧，选中时将left设置为100%定位到右侧，但是这样白点会完全移出容器范围，所以还需要加上 transform: translateX(-100%); 将白点向左再一定自身宽度的100%，同样加上transition的实现动画效果。.switch view {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 60rpx;\r\n    height: 60rpx;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.4);\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked view {\r\n    left: 100%;\r\n    transform: translateX(-100%);\r\n}关于“::”最后搭车说一下“:”和“::”，“:”是伪类，“::”是伪元素。按照我的理解：伪类不会在dom中增加节点，只不过是css选择器的一种特殊效果；伪元素会增加节点，flex布局中会影响到其他元素。为了保证兼容性，css3是允许伪元素使用单个冒号。"}
{"title": "小程序的getElementsById，就像一把梭 ", "author": "Rolan", "pub_time": "2019-12-24 00:52", "content": "使用selectComponent可以抓取自定义组件实例对象，但在层层嵌套结构的业务场景中，id的设置繁复，js/wxml开发界面频繁的切换，查找、维护、调整的开发工作很是让人抓狂啊好想封装一个getElementsById方法给小程序，像在web开发中那样能够方便的获取页面元素。在父子子子子级间轻松调用，好想念jquery开发的一把梭时代！实现如下需求：任何绑定id的自定义组件都能够方便抓取实例对象(任何嵌套层级均可调用)通过数据配置思路实现不难，我们可以将所有自定义组件在create生命周期方法时将\tthis 挂载到一个全局变量中，\tdetached 生命周期时销毁该实例(不然爆内存)实现准备一个全局变量app._elements = {}\r\n复制代码挂载/销毁方法一个全局的挂载、销毁方法，方便将实例对象注册、注销在app._elements上app.mount = function(id, context){\r\n    app._elements[id] = context\r\n}\r\n\r\napp.unmount = function(id){\r\n    app._elements[id] = null\r\n}\r\n复制代码getElementsById定义全局\tgetElementsById 在Page中能够方便调用app.getElementsById = function(id){\r\n    let res = app._elements[id]\r\n    if (!res) {  // 兼容selectComponent\r\n        return wx.selectComponent('#'+id) || wx.selectComponent('.'+id)\r\n    }\r\n    return res\r\n}\r\n复制代码自定义组件ui-component组件const app = getApp()\r\nComponent({\r\n  options: {\r\n    multipleSlots: true, // 在组件定义时的选项中启用多slot支持\r\n    addGlobalClass: true\r\n  },\r\n  properties: {\r\n    dataSource: {\r\n      type: Object,\r\n    },\r\n  },\r\n  data: {},\r\n  behaviors: [],\r\n  lifetimes: {\r\n    created: function() {\r\n    },\r\n    attached: function() {\r\n        this.id = this.data.dataSource.$$id  // 专用$$id来指定唯一名称\r\n    },\r\n    ready: function() {\r\n        app.mount(this.id, this)\r\n    },\r\n    detached: function(){\r\n        app.unmount(this.id)\r\n    }\r\n  },\r\n  methods: {\r\n      active(clsName){\r\n          /* do something */\r\n      }\r\n  })\r\n复制代码应用下面开始在Page中使用\tgetElementsById 来抓取自定义组件实例wxml<ui-component dataSource=\"{{config}}\" />\r\n复制代码jsPage({\r\n    data: {\r\n        config:  {\r\n            $$id: 'component-id',\r\n            title: 'some text'\r\n        }\r\n    },\r\n    \r\n    onReady(){\r\n        // 我们应该在onReady中来调用，onLoad时，页面组件结构并没有渲染完成  \r\n        const $ele = app.getElementsById('component-id')\r\n        $ele.active('.active') \r\n    }\r\n})\r\n复制代码至此，基本思路已经实现，现在即兼容了selectComponent方法，又简化了写模板id的麻烦。不知道大家有没有了解小程序组件是可以递归嵌套自己的(模板不能递归嵌套)。因此聪明的你应该可以想到通过数据嵌套去实现组件嵌套，进而实现结构嵌套，这样我们就能够实现很复杂的页面结构，当然小程序目前建议是结构应该在30层左右，然并卵，反正它能够正常显示，哈哈"}
{"title": "纯CSS实现圆环型进度条 ", "author": "Rolan", "pub_time": "2019-12-27 00:07", "content": "以下内容来自于去年的一次案例，随着微信小程序的不断改版，部分条件可能已不再适用，请谨慎参考。内容比较短，主要都在代码片段里。案例某个项目中需要用到如下图这样的一个圆环行的进度条。一开始的想法是使用canvas来实现，但是canvas是原生组件，层级最高（当时的情况），实际使用时不方便使用。所以决定尝试用纯CSS来实现这一效果。实现原理先上代码：https://developers.weixin.qq....这里主要用到的是CSS中的clip属性，将一个正方形裁剪后只显示右侧一半，但是仍然以正方形中心为圆心来旋转，来实现需要的角度。clip: rect(0rpx, 46rpx, 92rpx, 0rpx);这样最上面那个进度条就可以由以下三部分叠加，在最上面再叠加一个小一号的白色圆形，最外层加上圆角后就可以实现。（下图中红线示例了最外层的圆角以及最上层叠加的白色圆形位置）叠加效果用到蓝色圆环小于180度的情况下，需要把背景色和前景色对调。"}
{"title": "小程序标签展开收起功能实现 ", "author": "Rolan", "pub_time": "2019-12-27 00:41", "content": "先看效果主要结构我用的mpvue，如用原生标签直接转换成原生即可<div id=\"labelBox\">\r\n    <div class=\"label userLabel\" v-for=\"(label,inx) in labelList\" :key=\"inx\">{{label}}</div>\r\n    <div class=\"more\" v-show=\"showLabel===1\" id=\"moreLabel\" @click=\"openMore\">\r\n        <div>全部{{allLabel.length}}个</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_down.png\" />\r\n    </div>\r\n    <div class=\"more\" v-show=\"showLabel===2\" @click=\"closeMore\">\r\n        <div>收起</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_up.png\" />\r\n    </div>\r\n</div>export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    ...\r\n}思路利用小程序api NodesRef.boundingClientRect 获取节点的位置与大小信息，主要用到 width,left,right循环所有标签(.userLabel)，看是否有多行，通过所有节点的 left 去判断，如果 left 相同的有多个，就证明有多行获取标签父级(#labelBox)的宽度 width获取到按钮(#moreLabel)的宽度过滤第一行节点的 right，如果与按钮的width相加小于等于父级盒子的width就保留 具体的代码\r\n wxp为微信接口Promise化，会在之后列出用到的\r\n\r\n export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    methods: {\r\n        async loadPageData(){\r\n            // 请求后台数据\r\n            const res = ...\r\n\r\n            // 设置\r\n            this.allLabel = res.labes;          // 记录所有的标签\r\n            this.labelList = this.allLabel;     // 先插入所有表情\r\n            // 设置状态\r\n            if(this.allLabel.length>0){\r\n                await wxp.timeout(300); // 插入视图之后不会马上获取到节点信息，延迟获取\r\n                this.setLabelStauts();\r\n            }\r\n            \r\n        },\r\n\r\n        // 设置标签状态\r\n        async setLabelStauts(){\r\n            const boxDom = await wxp.getElementById('#labelBox');\r\n            const labelDoms = await wxp.getElementsByClassName('.userLabel');\r\n            const btnDom = await wxp.getElementById('#moreLabel');\r\n            const left = labelDoms[0].left;\r\n\r\n            // 分行转为二维数组\r\n            let lineArr = [];       \r\n            let lineIndex = -1;\r\n            labelDoms.forEach(v => {\r\n                if(v.left==left){\r\n                    lineIndex++;\r\n                    lineArr[lineIndex] = [];\r\n                }\r\n                lineArr[lineIndex].push(v);\r\n            })\r\n\r\n            // 超过一行\r\n            if(lineArr.length>1){\r\n                // 默认显示加载更多按钮\r\n                this.showLabel = 1;\r\n                const firstTr = lineArr[0].filter(v => (v.right+btnDom.width+(left/15*15)) <= boxDom.width);\r\n                this.firstLabel = this.allLabel.slice(0,firstTr.length);\r\n                this.labelList = this.firstLabel;\r\n            }else{\r\n                this.showLabel = 0;\r\n            }\r\n        },\r\n\r\n        // 展开\r\n        openMore(){\r\n            this.showLabel = 2;\r\n            this.labelList = this.allLabel;\r\n        },\r\n        // 收起\r\n        closeMore(){\r\n            this.showLabel = 1;\r\n            this.labelList = this.firstLabel;\r\n        }\r\n    }\r\n}wxp.js相关代码/**\r\n * 延时\r\n * @param {*} delay \r\n */\r\nexport const timeout = delay => new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n/**\r\n * 根据ID获取dom的盒模型信息\r\n * @param {*} id \r\n */\r\nexport const getElementById = (id='') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof id).toLowerCase() !=='string'){\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (id.indexOf('#') < 0) {\r\n            const err = {\r\n                errMsg: '请输入ID，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        }else{\r\n            var query = wx.createSelectorQuery()\r\n            query.select(id).boundingClientRect();\r\n            query.selectViewport().scrollOffset();\r\n            query.exec(rect => {\r\n                if (rect[0]){\r\n                    let info = rect[0];\r\n                    info.position = {\r\n                        left: rect[1].scrollLeft + info.left,\r\n                        top: rect[1].scrollTop + info.top\r\n                    };\r\n                    resolve(info);\r\n                }else{\r\n                    const err = {\r\n                        errMsg: '没有获取到信息'\r\n                    }\r\n                    reject(error(err.errMsg,err));\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * 根据类名获取dom信息\r\n * @param {*} className \r\n */\r\nexport const getElementsByClassName = (className = '') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof className).toLowerCase() !== 'string') {\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (className.indexOf('.') < 0) {\r\n            const err = {\r\n                errMsg: '请输入类名，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else {\r\n            wx.createSelectorQuery().selectAll(className).boundingClientRect(rects => {\r\n                resolve(rects);\r\n            }).exec();\r\n        }\r\n    })\r\n}作者：不二很纯洁链接：https://www.jianshu.com/p/87f3c14038a6"}
{"title": "小程序云开发模糊查询，实现数据库多字段的模糊搜索 ", "author": "Rolan", "pub_time": "2019-12-3 00:53", "content": "最近做小程序云开发时，用到了一个数据库的模糊搜索功能，并且是要求多字段的模糊搜索。网上也有一大堆资源，但是都是单个字段的搜索。如下图上图只可以实现time字段的模糊搜索。但是我们如果相对数据表里的多个字段做模糊查询呢？该怎么办呢。多字段模糊搜索一，如我们的数据表里有以下数据，我们想同时模糊查询name和address字段如我们搜索“周杰”可以看到我们查询到下面两条数据。二，如我们搜索“编程”，可以搜索到下面数据可以看到我们搜索到的两条数据，一个是name字段为 编程小石头， 一个是address字段里包含“编程“ 字样。下面把代码贴给大家    let key = \"编程小石头\";    console.log(\"查询的内容\", key)    const db = wx.cloud.database();    const _ = db.command    db.collection('qcl').where(_.or([{        name: db.RegExp({          regexp: '.*' + key,          options: 'i',        })      },      {        address: db.RegExp({          regexp: '.*' + key,          options: 'i',        })      }    ])).get({      success: res => {        console.log(res)      },      fail: err => {        console.log(err)      }    })key就是我们要搜索的关键字。主要是用到了数据库查询的where,or,get方法。 代码都给大家贴出来来，如果对云开发和云数据库还不是很了解的同学可以去翻看下我以前写的文章。"}
{"title": "用云开发制作教务助手小程序丨实战 ", "author": "Rolan", "pub_time": "2019-12-4 00:02", "content": "本项目由一人承担从后端到前端的构思以及开发，下面我就讲讲从教务助手小程序的构思到开发实现（基于云开发）。1、灵感来源教务小程序的灵感来源：用完即走，查个成绩和课表，无需下载app或去翻看公众号内的历史内容。加上本人很久以前就想实现开发一个类似的app，但app的开发对于开发小白不太友好，不知从何下手！幸好 小程序·云开发 的出现解决了我的需求，它的低入门门槛和免后端运维等优势让非科班出身的我也能快速动手开发一款应用类小程序。2、构思教务小程序需要核心就是： 成绩查询、课表查询、教务通知查询 ！ 那么问题来了，学校教务处只有网页版，教务小程序数据从何而来呢？ 经过一系列思考，百度各种问题，思路就来了：后端模拟登陆——拿到页面数据——整理数据——反馈到小程序前端渲染大概结构如下：▌项目开发1、后端后端的实现 完全基于云开发 。 部分目录：采用云开发后端node.js语言，主要利用模块有：Router模块：const cloud = require('tcb-admin-node');\r\n//   npm  install tcb-router\r\nconst TcbRouter = require('tcb-router');\r\ncloud.init({\r\n  env: '//'\r\n})\r\nconst db = cloud.database();\r\nconst _ = db.command;\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const app = new TcbRouter({ event });\r\n  /** 教务处登陆 eg*/\r\n  app.router('login', async (ctx, next) => {\r\n    const test = require('login/login.js');\r\n    ctx.body = test.main(event, context);\r\n  });\r\n  /**查取成绩*/\r\n  app.router('getpoint', async (ctx, next) => {\r\n    const logList = require('getpoint/index.js');\r\n    ctx.body = logList.main(event, context);\r\n  });\r\n  /**学术活动*/\r\n  app.router('academic', async (ctx, next) => {\r\n    const userList = require('schoolnews/academic.js');\r\n    ctx.body = userList.main(event, context);\r\n  });\r\n  app.router('xsxx', async (ctx, next) => {\r\n    const userList = require('schoolnews/xsxx.js');\r\n    ctx.body = userList.main(event, context);\r\n  });\r\n  return app.serve();\r\n}\r\n复制代码Cherrio实现课表成绩等网页解析：const cloud = require('tcb-admin-node')\r\nconst rp = require('request-promise');\r\nvar cheerio = require(\"cheerio\");\r\ncloud.init()\r\nmodule.exports = {\r\n  main: async (event, context) => {\r\n    var url ='URL'\r\n    var res = await rp({method: 'get',uri: url,json: false}).then((body) => {\r\n      var academic = [];\r\n      var $ = cheerio.load(body);\r\n      $('.fl').find('dl').each(function (i, elem) {\r\n        //业务代码未写\r\n        /**\r\n          **/\r\n        academic.push({date: date,time:time,title:title,speaker:speaker,place:place,link:link})\r\n      });\r\n      return academic\r\n    }).catch(err => {\r\n      return err;\r\n    })\r\n    return res\r\n  }\r\n}\r\n复制代码数据库access_token定时修改// 云函数入口文件\r\nconst cloud = require('wx-server-sdk'),rp = require('request-promise'),key=require('key.js')\r\ncloud.init({\r\n  env: \"//\"\r\n})\r\n//指定数据库环境\r\nconst db = cloud.database({\r\n  env: \"//\"\r\n}), _ = db.command;\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  try { \r\n    var res = await rp(\r\n      {\r\n        method: 'get',\r\n        uri: 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=' + key.APPID + '&secret=' + key.APPSECRET,\r\n        qs: {},//参数\r\n        headers: {},//请求头\r\n        json: true  //是否json数据\r\n      }\r\n    ).then((body) => {\r\n      return body\r\n    }).catch(err => {\r\n      return {errmsg:\"rp函数获取失败\"}\r\n    })\r\n/*将获取的access_token存到数据库*/\r\n    console.log(res)\r\n    if (res.hasOwnProperty('access_token')) {\r\n      await db.collection('key').where({\r\n        type: \"accesstoken\"\r\n      }).update({\r\n        data: {\r\n          accesstoken: res.access_token,\r\n          datearray: _.unshift(new Date(new Date().getTime())),\r\n          num: _.inc(1)\r\n        }\r\n      })\r\n    } else {\r\n      console.log(\"err错误\" + res)\r\n    }\r\n  } catch (err) {\r\n    console.log(err)\r\n  } \r\n  \r\n}\r\n复制代码此外还借助了其他模块实现登陆、数据处理（课表等数据格式化）、云开发数据库操作（用户信息储存，消息发布）、用户权限鉴定（确保后台信息安全）等，在此就不赘述。2、前端小白就是“简单粗暴”的进行各种if、var操作；部分详细介绍如下：① 课程表：实现了一键导入（其实课程表这一功能可以单独形成一个通用的小程序上线），每天一卡片形式在首页提醒：今天有什么课，上完没有？②主题全局替换：支持自定义主题色，给用户自定义能力。③校历：利用了插件【极点日历】再加以美化。▌感悟一个从小白到从后端到前端到UI全部自己写的入门者参赛的心路历程就这么多了，目前源码暂不开放，对本小程序有疑问与建议均可在留言，同时希望大家能够利用好小程序实现自己的想法和创意！源码地址github.com/TencentClou…如果你想要了解更多关于云开发CloudBase相关的技术故事/技术实战经验，请扫码关注【腾讯云云开发】公众号～"}
{"title": "小程序同构方案 kbone 分析与适配 ", "author": "Rolan", "pub_time": "2019-12-4 00:23", "content": "在微信小程序的开发的过程中，我们会存在小程序和 H5 页面共存的场景，而让小程序原生和 web h5 独立开发，往往会遇到需要两套人力去维护。对开发者而言，加大了工作量成本，对于产品而言，容易出现展示形态同步不及时问题。在这种情况下，我们急需要找到一个既能平衡性能，也能满足快速迭代的方案。主流的小程序同构方案web-view 组件webview 组件是一个承载网页的容器，最简单的方案就是使用原 h5 的代码，通过 web-view 组件进行展示。其优点是业务逻辑无需额外开发与适配，只需要处理小程序特有的逻辑，然后通过 jssdk 与原生小程序通讯。使用 webview 加载 h5 的问题也非常明显，首先是体验问题，用户见到页面会经过以下环节：加载小程序包，初始化小程序，再加载 webview 中的 html 页面，然后加载相关资源，渲染 h5 页面，最后进行展示。最终导致的结果是打开体验非常差。另外其他缺点是小程序对 web-view 部分特性有限制，比如组件会自动铺满整个小程序页面，不支持自定义导航效果等。静态编译兼容静态编译是最为主流的小程序同构方案，类似的有 taro, mpvue 等。其思路是在构建打包过程，把一种结构化语言，转换成另一种结构化语言。比如，taro 把 jsx 在构建时进行词法分析，解析代码获取 AST，然后将 AST 递归遍历生成 wxml 目标代码。静态编译的好处是非常明显，一套代码，通过编译分别转 h5 和小程序，兼具性能与跨平台。另一方面，随着这种方案的流行，大家也感受到了其明显的问题，首先，由于小程序本身的限制，比如无法 dom 操作，js 与 webview 双线程通信等，导致静态编译语法转换，不能做到彻底的兼容，开发体验受制于框架本身的支持程度，相信踩过坑的同学应该非常有痛的感悟。其次，静态编译转换逻辑需要与小程序最新的特性保持同步，不断升级。小程序运行时兼容方案静态编译的方案实现了同构，但它只是以一种中间态的结构化语法去编码，非真正的 web，牺牲了大量的灵活性。另外一种更灵活的方案，运行时兼容应值得去尝试。小程序原理我们回到小程序本身的限制上来。由于小程序采用双线程机制，内部通过一个 webview 用于承载页面渲染，但小程序屏蔽了它原本的 DOM/BOM 接口，自己定义了一套组件规范；另一方面，使用独立的 js-core 负责对 javascript 代码进行解析，让页面和 js-core 之间进行相互通信（setData），从而达到执行与渲染的分离。而浏览器的 DOM 接口是大量 web 得以显示的底层依赖，这也是 h5 代码无法直接在小程序中运行的主要原因。那么如何突破小程序对接口 DOM 的屏蔽呢？ 最直接的思路就是用 JS 实现和仿造一层浏览器环境的 DOM 相关的标准接口，让用户的 JS 代码可以无感知的自由操作 DOM。通过仿造的底层 DOM 接口，web 代码执行完后，最终生成一层仿造的 DOM 树，然后讲这棵 DOM 树转换成小程序的 wxml 构成的 DOM 树，最后由小程序原生去负责正确的渲染出来。kbonekbone 是微信官方出一套小程序运行时兼容方案，目前已经接入的小程序有小程序官方社区，及腾讯课堂新人礼包等。并且有专人维护，反馈及时。kbone 方案核心主要有两大模块，第一是 miniprogram-render 实现了对浏览器环境下 dom/bom 的仿造，构建 dom 树，及模拟 web 事件机制。第二个模块是 miniprogram-element 是原生小程序渲染入口，主要监听仿造 dom 树的变化，生成对应的小程序的 dom 树，另外一个功能是监听原生小程序事件，派发到仿造的事件中心处理。DOM/BOM 仿造层DOM、BOM 相关的接口模拟，主要是按照 web 标准构建 widow、document、node 节点等相关 api，思路比较清晰，我们简单看下其流程。首先在用户层有一个配置文件 miniprogram.config，里面有必要信息 origin、entry 等需要配置。在 miniprogram-render 的入口文件 createPage 方法中，配置会初始化到一个全局 cache 对象中，然后根据配置初始化 Window 和 Document 这两个重要的对象。Location、Navigator、Screen、History 等 BOM 实例都是在 window 初始化过程中完成。DOM 节点相关 api 都是在 Document 类中初始化。所有生成的节点和对象都会通过全局的 pageMap 管理，在各个流程中都能获取到。小程序渲染层miniprogram-element 负责监听仿造 DOM 仿造的变化，然后生成对应小程序组件。由于小程序中提供的组件和 web 标准并不完全一样，而我们通过 html 生成的 dom 树结构千差万别，如和保证任意的 html dom 树可以映射到小程序渲染的 dom 树上呢？kbone 通过小程序自定义组件去做了这件事情。简单说下什么是自定义组件，既将特定的代码抽象成一个模块，可以组装和复用。以 react 为例，div、span 等标签是原生组件，通过 react.Component 将 div 和 span 组合成一个特定的 react 组件，在小程序中用自带的 view、image 等标签通过 Component 写法就能组合成小程序自定义组件。和大部分 web 框架的自定义组件类似，小程序自定义组件也能够自己递归地调用自己，通过将伪造的 dom 结构数据传给自定义组件作为子组件，然后再递归的调用，直到没有子节点为止，这样就完成了一个小程序 dom 树的生成。性能问题多层 dom 组合大量小程序自定义组件会有额外的性能损耗，kbone 在实现时提供了一些优化。其中最基本的一个优化是将多层小程序原生标签作为一个自定义组件。dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。以上逻辑就是通过 DOM_SUB_TREE_LEVEL 层级数对节点过滤，更新后，检测是否还有节点，再触发更新。节点缓存在页面 onUnload 卸载的过程中，kbone 会将当前节点放入缓存池中，方便下次初始化的时候优先从缓存中读取。kbone 接入与适配kbone 作为一种运行时兼容方案，适配成本相对于静态编译方案而言会低很多，总体来说对原代码侵入性非常少，目前接入过程比较顺利（期间遇到的坑，感谢 作者 june 第一时间帮忙更新发布 [玫瑰]）svg 资源适配小程序不支持 svg，对于使用 svg 标签作为图片资源的应用而言，需要从底层适配。在一开始我们想到的方案有通过 肝王的 cax 进行兼容，但评估后不太靠谱，cax 通过 解析 svg 绘制成 canvas，大量 icon 会面临比较严重的性能问题。那么最直接暴力的办法就是使用 webpack 构建过程直接把 svg 转 png？后面一位给力的小伙伴想到通过把 svg 标签转成 Data URI 作为背景图显示，最终实践验证非常可靠，具体可以参考 kbone svg 适配。网络层适配/cookie微信小程序环境拥有自己定义的一套 wx.request API， web 中的 XMLHttpRequest 对象是无法直接使用。由于我们代码中使用了 axios，所以在预言阶段直接简单通过 axios-miniprogram-adapter 进行适配器，后面发现部分业务没有使用 axios，兼容并不够彻底。于是直接从底层构建了一个 XMLHttpRequest 模块，将 web 网络请求适配到 wx.request。同时做了 cookie 的自动存取逻辑适配（小程序网络请求默认不带 cookie）。这一层等完善好了看是否能 pull request 到 kbone 代码仓库中。差异性 DOM/BOM API 适配部分 web 中的接口在小程序无法完全获得模拟，比如 getBoundingClientRect 在小程序中只能通过异步的方式实现。类似的有 removeProperty、stopImmediatePropagation等接口在 kbone 中没有实现，performance 等 web 特有的全局变量的需要兼容。这些扩展 API 可以通过 kbone 对外暴露的 dom/bom 扩展 API 进行兼容。getBoundingClientRect对于元素的的高度 height \\offsetHeight 获取，我们只能通过 $getBoundingClientRect 异步接口，如果是 body scroll-view 实现的，getBoundingClientRect 返回的是 scrollHeight。滚动web 的全局滚动事件默认是无法触发，需要通过配置 windowScroll 来监听，启用这个特性会影响性能。global: {\r\n    windowScroll: true\r\n},\r\n样式适配标签选择器kbone 样式有一个坑，就是它会将标签选择器转换成类选择器去适配小程序环境，比如span { } =>  .h5-span{  }\r\n这样带来的副作用就是选择器的权重会被自动提升，对选择器权重依赖的标签样式需要去手动调整兼容。其他适配点注意使用标准的 style 属性，比如有 webkit-transform 会不支持，及小程序样式和 web 差异性兼容等。  style: {\r\n      'WebkitTransform': 'translate(' + x + 'px, 0)' // 正确\r\n     // '-webkit-transform': 'translate(' + x + 'px, 0)' 报错\r\n  }\r\n路由适配在初始化路由阶段，曾经遇到过 Redux 更新 dom 后偶现节点销毁，最终定位到是 kbone 对 Location 等 BOM 实例化过晚，最终在 june 帮忙及时调整了顺序，更新了一个版本，现最新本所有 BOM 对象会在业务执行前准备好。//初始化dom\r\nthis.window.$$miniprogram.init()\r\n...\r\n//初始化业务\r\ninit(this.window, this.document)\r\n隐式全局变量兼容在模拟 XMLHttpRequest 模块的过程中遇到一个问题，什么时候初始化这个对象，我们可以选择在网络请求库初始化前引入它，挂载在仿造的 window 对象下。但仍然会出现一个问题，第三放库直接使用的是 XMLHttpRequest 对象，而非通过 window 访问。var request = new XMLHttpRequest() // 报错\r\n \r\nvar request = new window.XMLHttpRequest() // 正确\r\n在正常的 web 环境，window 是默认的顶层作用域，而小程序中隐式的使用 window 对象则会报错。为了解决这一问题，可以通过配置文件的 globalVars 字段，将 XMLHttpRequest 直接进行定义。 globalVars: [\r\n    ['XMLHttpRequest', 'require(\"libs/xmlhttprequest.js\")']\r\n]\r\n构建的过程中会在所有依赖前转成如下代码 ： var XMLHttpRequest = require(\"libs/xmlhttprequest.js\")\r\n这样做解决了隐式访问 window 作用域问题。但又面临另一个问题，那就是 xmlhttprequest 模块本身内部由依赖仿造 window 对象，比如 cookie 访问，而此时因为 require 的模块独立的作用域无法访问到其他模块的仿造 window 对象。于是最终通过导入一个 function 传入 window 作用域，然后初始化 xmlhttprequest。  globalVars: [\r\n      ['XMLHttpRequest', 'require(\"libs/xmlhttprequest.js\").init(window, document)']\r\n]\r\n多端构建小程序和 web 端需要的资源及部分逻辑是有差异，通过 webpck 配置进行差异化处理，具体可以参考文档编写 kbone webpack 配置。大概是这样的区分跨端配置：分离打包入口文件:小程序打包入口依赖的 dom 节点，需要主动创建。详细示例参照官方 demo.export default function createApp() {\r\n    initialize(function() {\r\n        let Root = require('./root/index').default;\r\n \r\n        const container = document.createElement('div')\r\n        container.id = 'pages';\r\n        document.body.appendChild(container);\r\n        render(<Root />, container)\r\n    })\r\n}\r\n由于小程序本身是没有真正 userAgent，kbone 内部是是根据当前环境进行仿造。//miniprogram-render/src/bom/navigator#45\r\nthis.$_userAgent = `${this.appCodeName}/${appVersion} (${platformContext}) AppleWebKit/${appleWebKitVersion} (KHTML, like Gecko) Mobile MicroMessenger/${this.$_wxVersion} Language/${this.language}`\r\n在业务中有需要区分小程序平台的场景，我们可以通过 webpack DefinePlugin 插件进行注入，然后通过定义变量进行判断。if (!process.env.isWxMiniProgram) {\r\n    render(\r\n        <Root />,\r\n        document.getElementById('pages')\r\n    );\r\n}\r\n小程序分包在腾讯文档的小程序中，有一个独立的小程序仓库。 而文档管理列表是另外一个独立的 H5 项目，嵌入到小程序 webview 动态加载。通过 kbone 转原生打包后，这部分代码需要继承到小程序仓库中。首先我们可以通过脚本，在 webpack 构建过程，将 kbone 编译后的包 copy 到独立小程序仓库的目录下，合并小程序相关配置，从而实现功能合并。这样遇到的一个问题是主包大小超过限制，通过小程序分包我们可以解决这个问题，将原小程序非首屏页面全部放分包之中，配置 preloadRule 字段再预加载分包。\"subpackages\": [\r\n    {\r\n      \"root\": \"packageA\",\r\n      \"pages\": [\r\n        \"pages/cat\"      ]\r\n    }\r\n  ]\r\n  \"preloadRule\": {\r\n    \"pages/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\"important\"]\r\n    }  \r\n}\r\n结通过对目前各种小程序同构方案的对比与实践，kbone 是一种非常值得推荐的新思路，新方法，兼具性能与灵活。唯一不足的地方就是目前仍有不少底层工作需要适配，更多的问题在继续探索中，相信随着不断迭代及采坑后的反馈，kbone 会变得越来稳定和成熟"}
{"title": "京喜首页（微信购物入口）跨端开发与优化实践 ", "author": "Rolan", "pub_time": "2019-12-4 00:45", "content": "随着今年的双十一落下帷幕，京喜（原京东拼购）也迎来了首捷。双十一前夕微信购物一级入口切换为京喜小程序，项目顺利通过近亿级的流量考验，在此与大家分享一点自己参与的工作。在接手项目前，京喜业务已在线上稳定运行较长时间。但经过一段时间迭代维护后，发现首页存在以下问题：H5 版本首页针对不同渠道开发了多套页面，对开发者维护和内容运营来说存在较大挑战，需投入大量人力成本；项目技术栈不统一，分别有传统 H5 开发、原生小程序开发、wqVue 框架开发，严重影响项目复杂度，迭代过程苦不堪言；H5、小程序以及 RN 三端存在各自构建和发布流程，涉及较多工具及复杂系统流程，影响业务交付效率。综上所述，京喜迎来一次改版契机。改版目标从前端角度来看，本次改版要实现以下目标：升级并统一项目技术栈，解决项目技术栈混乱的现状；使用一套代码，适配微信入口、手 Q 入口、微信小程序、京东 APP、京喜 APP、M 站六大业务场景，减少多套页面的维护成本，提升交付效率；通过让 RN 技术在业务上的落地，完善团队在 App 端的技术储备；优化页面性能及体验，为下沉市场用户提供优质的产品体验；技术选型京喜业务拥有非常丰富的产品形态，涵盖了 H5、微信小程序以及独立 APP 三种不同的端，对支持多端的开发框架有着天然的需求。在技术选型上，我们选择团队自研的 Taro 多端统一开发解决方案。Taro 是一套遵循 React 语法规范的多端开发解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ 小程序、快应用、H5、React-Native 等）运行的代码。选它有两个原因，一来是 Taro 已经成熟，内部和外部都有大量实践，内部有京东 7FRESH、京东到家等，外部有淘票票、猫眼试用等多个案例，可以放心投入到业务开发；二来团队成员都拥有使用 Taro 来开发内部组件库的经验，对业务快速完成有保障。开发实录由于首页改版的开发排期并不充裕，因此充分地复用已有基础能力（比如像请求、上报、跳转等必不可少的公共类库），能大量减少我们重复的工作量。话虽如此，但在三端统一开发过程中，我们仍遇到不少问题同时也带来解决方案，以下我们一一阐述。H5 篇我们所有的页面都依赖现有业务的全局公共头尾及搜索栏等组件，这就不可避免的需要将 Taro 开发流程融入到现有开发和发布流程中去。同时公共组件都是通过 SSI 的方式引入和维护的，为了能在运行 npm run dev:h5 时预览到完整的页面效果，需要对 index.html 模版中的 SSI 语法进行解析， index.html 模版文件代码结构大致如下：<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover\">\r\n  <title>京喜</title>\r\n  <!--#include virtual=\"/sinclude/common/head_inc.shtml\"-->\r\n</head>\r\n<body>\r\n  <div id=\"m_common_header\" style=\"display:none;\"></div>\r\n  <!--S 搜索框-->\r\n  <div id=\"search_block\" class=\"search_block\"></div>\r\n  <div id=\"smartboxBlock\" style=\"display:none;\"></div>\r\n  <!--E 搜索框-->\r\n  <div id=\"app\" class=\"wx_wrap\"></div>\r\n  <!--#include virtual=\"/sinclude/common/foot.shtml\"-->\r\n</body>\r\n</html>\r\n复制代码可以看到模版中存在很多类似 <!--#include virtual=\"...\" --> 格式的代码，这些就是通过 SSI 方式引入的 H5 公共组件，它的 virtual 属性指向的文件不存在于本地而是存在于服务器上的，所以我们遇到的第一个问题就是在本地解析这些文件，确保能预览到完整的页面效果，不然开发调试起来就非常的低效。好在 Taro 有暴露出 webpack 的配置，我们可以通过引入自定义加载器（这里就叫 ssi-loader ）来解析这些代码的路径，然后请求服务器上的文件内容并进行替换即可，要实现这个功能只需在项目的 config/dev.js 中加入如下代码即可：module.exports = {\r\n  h5: {\r\n    webpackChain(chain, webpack) {\r\n      chain.merge({\r\n        module: {\r\n          rule: {\r\n            ssiLoader: {\r\n              test: /\\.html/,\r\n              use: [\r\n                {\r\n                  loader: 'html-loader'\r\n                },\r\n                {\r\n                  loader: 'ssi-loader',\r\n                  options: {\r\n                    locations: {\r\n                      include: 'https://wqs.jd.com'\r\n                    }\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n复制代码这样就解决了本地开发调试难点，然后开开心心的进行页面开发。当页面开发完成之后，接下来遇到的问题就是如何将前端资源部署到测试和生产环境。由于现有开发和发布流程都是基于内部已有的平台，我们临时定制一套也不太现实，所以需要将它融入到 Taro 的流程中去，这里我们引入了 gulp 来整合各种构建和发布等操作，只要构建出符合发布平台规范的目录即可利用它的静态资源构建、版本控制及服务器发布等能力，这样我们就打通了整个开发和发布流程。这套拼凑起来的流程还存在不少的问题，对于新接手的同学有一点小繁琐，有着不少改善的空间，这也是接下来的重点工作方向。另外 Taro 的 H5 端之前是基于 SPA 模式，对于有着多页开发需求的项目来说不太友好，当时反馈给 Taro 团队负责 H5 的同学，很快得到了响应，目前 Taro 已支持 H5 多页开发模式，支持非常迅速。小程序篇由于开发完 H5 版之后，对应的业务逻辑就已经处理完了，接下来只需要处理小程序下的一些特殊逻辑（比如分享、前端测速上报等）即可，差异比较大的就是开发和发布流程。这里讲一下如何在一个原生小程序项目中使用 Taro 进行开发，因为我们的 Taro 项目跟已有的原生小程序项目是独立的两个项目，所以需要将 Taro 项目的小程序代码编译到已有的原生小程序项目目录下，第一步要做的就是调整 Taro 配置 config/index.js ，指定编译输出目录以及禁用 app 文件输出防止覆盖已有文件。const config = {\r\n  // 自定义输出根目录\r\n  outputRoot: process.argv[3] === 'weapp' ? '../.temp' : 'dist',\r\n  // 不输出 app.js 和 app.json 文件\r\n  weapp: {\r\n    appOutput: false\r\n  }\r\n}\r\n复制代码由于京喜以前是主购小程序的一个栏目，后面独立成了独立的小程序，但是核心购物流程还是复用的主购小程序，所以这让情况变得更加复杂。这里还是通过 gulp 来进行繁琐的目录文件处理，比如我们的小程序页面和组件都需要继承主购小程序的 JDPage 和 JDComponent 基类，所以在进行文件复制之前需要进行代码替换，代码如下：// WEAPP\r\nconst basePath = `../.temp`\r\nconst destPaths = [`${basePath}/pages/index/`, `${basePath}/pages/components/`]\r\nconst destFiles = destPaths.map(item => `${item}**/*.js`)\r\n\r\n/*\r\n * 基类替换\r\n */\r\nfunction replaceBaseComponent (files) {\r\n  return (\r\n    gulp\r\n      .src(files || destFiles, { base: basePath })\r\n      .pipe(\r\n        replace(\r\n          /\\b(Page|Component)(\\(require\\(['\"](.*? \"'\"\")\\/npm\\/)(.*)(createComponent.*)/,\r\n          function(match, p1, p2, p3, p4, p5) {\r\n            const type =\r\n              (p5 || '').indexOf('true') != -1 ||\r\n              (p5 || '').indexOf('!0') != -1\r\n                ? 'Page'\r\n                : 'Component'\r\n            if (type == 'Page') p5 = p5.replace('))', '), true)') // 新：page.js基类要多传一个参数\r\n            const reservedParts = p2 + p4 + p5\r\n            // const type = p1\r\n            // const reservedParts = p2\r\n            const rootPath = p3\r\n\r\n            const clsName = type == 'Page' ? 'JDPage' : 'JDComponent'\r\n            const baseFile = type == 'Page' ? 'page.taro.js' : 'component.js'\r\n\r\n            console.log(\r\n              `:full_moon_with_face: Replace with \\`${clsName}\\` successfully: ${this.file.path.replace(\r\n                /.*?wxapp\\//,\r\n                'wxapp/'\r\n              )}`\r\n            )\r\n            return `new (require(\"${rootPath}/bases/${baseFile}\").${clsName})${reservedParts}`\r\n          }\r\n        )\r\n      )\r\n      .pipe(gulp.dest(basePath))\r\n  )\r\n}\r\n\r\n// 基类替换\r\ngulp.task('replace-base-component', () => replaceBaseComponent())\r\n复制代码还有很多类似这样的骚操作，虽然比较麻烦，但是只需要处理一次，后续也很少改动。RN 篇对于 RN 开发，也是第一次将它落地到实际的业务项目中，所以大部分时候都是伴随着各种未知的坑不断前行，所以这里也友情提示一下，对于从未使用过的技术，还是需要一些耐心的，遇到问题勤查勤问。由于京喜 APP 是复用京东技术中台的基础框架和 JDReact 引擎，所以整个的开发和部署都是遵循 JDReact 已有的流程，画了一张大致的流程图如下：JDReact 平台是在 Facebook ReactNative 开源框架基础上，进行了深度二次开发和功能扩展。不仅打通了 Android/iOS/Web 三端平台，而且对京东移动端基础业务能力进行了 SDK 级别的封装，提供了统一、易于开发的 API。业务开发者可以通过 JDReact SDK 平台进行快速京东业务开发，并且不依赖发版就能无缝集成到客户端(android/iOS)或者转换成 Web 页面进行线上部署，真正实现了一次开发，快速部署三端。由于京喜 APP 的 JDReact 模块都是独立的 git 仓库，所以需要调整我们 Taro 项目配置 config/index.js 的编译输出路径如下：rn: {\r\n  outPath: '../jdreact-jsbundle-jdreactpingouindex'\r\n}\r\n复制代码这样，当我们运行 yarn run dev:rn 进行本地开发时，文件自动编译到了 JDReact 项目，接下来我们就可以用模拟器或者真机来进行预览调试了。当我们在进行本地开发调试的时候，最高效的方式还是推荐用 Taro 官方提供的 taro-native-shell 原生 React Native 壳子来启动我们的项目，详细的配置参照该项目的 README 进行配置即可。由于 React Native 官方提供的 Remote Debugger 功能非常弱，推荐使用 React Native Debugger 来进行本地 RN 调试，提供了更为丰富的功能，基本接近 H5 和小程序的调试体验。这样我们就拥有了一个正常的开发调试环境，接下来就可以进行高效的开发了，由于我们前面在 H5 和小程序版本阶段已经完成了绝大部分的业务逻辑开发，所以针对 RN 版本的主要工作集中在 iOS 和安卓不同机型的样式和交互适配上。在样式适配这块，不得不提下 Taro 针对我们常见的场景提供了一些最佳实践，可以作为布局参考：Image\r\nflex\r\nscalePx2dp\r\nTaro RN 最佳实践集锦在实际开发过程中也遇到不少兼容性问题，这里整理出来以供大家参考：文本要用 <Text> 标签包起来，因为 RN 没有 textNode 的概念；使用 Swiper 时在外面包一个 View，否则设置 margin 后会导致安卓下高度异常；Cannot read property 'x' of undefined ，Swiper 底层使用的 react-native-swiper 导致的问题，Disable Remote JS Debug 就不会出现。图片默认尺寸不对，RN 不会自动帮助设置图片尺寸，而是交给开发者自己处理，故意这样设计的；Image 组件上不可以设置 onClick实现基线对齐： vertical-align: baseline ，用 <Text> 把需要基线对齐的组件包住即可。<Text>\r\n  <Text style={{ fontSize: 20 }}>abc</Text>\r\n  <Text style={{ fontSize: 40 }}>123</Text>\r\n</Text>\r\n复制代码尽量避免使用 line-height ，在安卓和 iOS 下表现不一致，而且即使设置为与 fontSize 相同也会导致裁剪；android 调试生产环境的 bundle，摇手机，选 Dev Setting，取消勾选第一项 Dev 即可；iOS 调试生产环境的 bundle， AppDelegate.m 中增加一行语句关闭 dev 即可：[[RCTBundleURLProvider sharedSettings] setEnableDev:false];\r\n  // 找到这行，并在它的上面增加上面这行\r\n  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil];\r\n复制代码<Text> 与 <View> 支持的 style 属性不相同。> [Text Style Props](https://facebook.github.io/react-native/docs/text-style-props \"Text Style Props\") & [View Style Props](https://facebook.github.io/\r\n复制代码react-native/docs/view-style-props)render 方法中不要返回空字符串下面的代码在 android 下会报错（empty_string 内容为空字符串）<View>\r\n  {empty_string && <Text></Text>}\r\n</View>\r\n复制代码因为 empty_string && <Text></Text> 的返回值是空字符串，RN 尝试把字符串添加到 View 的 children 时在安卓环境下会报错：Error: Cannot add a child that doesn't have a YogaNode\r\n复制代码border-radius 导致背景色异常，单独给某个角设置圆角时，没有设置圆角的边会出现一块与背景色颜色相同，但半透明的色块。transform:tanslate()\r\n透明 View 无法点击的问题，给设置了 onClick 的元素添加透明背景色即可：style={{ backgroundColor: \"transparent\" }}\r\n复制代码不可以用 scss 写，只有写在 JSX 上的才有效，Taro 编译时可能把透明背景色忽略了。一像素缝隙问题可能是 RN 布局引擎的问题，或单位转换以及浏览器渲染中的精度损失问题。可以调整页面结构来绕过。 或者简单粗暴一点，设置负 margin 值盖住缝隙。跨平台开发JS 文件1、文件拆分的方式要\"完美\"的编译出三端代码，首先要解决的是公共类库的适配问题，好在兄弟业务团队已经沉淀有完成度较高的三端公共类库，利用 Taro 提供的跨平台开发能力，抹平三端方法名和参数不统一的情况，即可很好的解决公共类库的适配问题，如下所示：.\r\n├── goto.h5.js\r\n├── goto.rn.js\r\n├── goto.weapp.js\r\n├── request.h5.js\r\n├── request.rn.js\r\n├── request.weapp.js\r\n└── ...\r\n复制代码以 request 公共组件为例，三端代码如下：request.h5.jsimport request from '@legos/request'\r\nexport { request }\r\n复制代码request.rn.jsimport request from '@wqvue/jdreact-request'\r\nexport { request }\r\n复制代码request.weapp.js（由于小程序的公共组件没有发布至 npm，这里引用的本地项目源文件）import { request } from '../../../common/request/request.js'\r\nexport { request }\r\n复制代码如遇到需要适配的方法参数不一致或者增加额外处理的情况，可进行再包装确保最终输出的接口一致，如下：goto.rn.jsimport jump from '@wqvue/jdreact-jump'\r\n\r\nfunction goto(url, params = {}, options = {}) {\r\n  jump(url, options.des || 'm', options.source || 'JDPingou', params)\r\n}\r\n\r\nexport default goto\r\n复制代码文件引入的时候我们正常使用就好，Taro 在编译的时候为我们编译对应的平台的文件import goto from './goto.js'\r\n复制代码2、条件编译的方式解决了公共类库适配之后，接下来就可以专注于业务代码开发了，同样业务代码在三端也可能存差异的情况，可以用 Taro 提供的环境变量来达到目的，示例代码如下：if (process.env.TARO_ENV === 'h5') {\r\n  this.speedReport(8) // [测速上报] 首屏渲染完成\r\n} else if (process.env.TARO_ENV === 'weapp') {\r\n  speed.mark(6).report() // [测速上报] 首屏渲染完成\r\n} else if (process.env.TARO_ENV === 'rn') {\r\n  speed.mark(7).report() // [测速上报] 首屏渲染完成\r\n}\r\n复制代码CSS 文件以上是 js 的代码处理方式，对于 css 文件及代码，同样也有类似的处理。1、文件拆分的方式比如 RN 相对于 H5 和小程序的样式就存在比较大的差异，RN 支持的样式是 CSS 的子集，所以很多看起来很常见的样式是不支持的，可以通过以下方式进行差异化处理：├── index.base.scss\r\n├── index.rn.scss\r\n├── index.scss\r\n复制代码这里以 index.base.scss 作为三端都能兼容的公共样式（名字可以任取，不一定为 xxx.base.scss）， index.rn.scss 则为 RN 端独特的样式， index.scss 则为 H5 和小程序独特的样式，因为 H5 和小程序样式基本上没有什么差异，这里合为一个文件处理。2、条件编译的方式Taro 也支持样式文件内的条件编译，语法如下：/* #ifdef %PLATFORM% */\r\n// 指定平台保留\r\n/* #endif */\r\n\r\n/* #ifndef %PLATFORM% */\r\n// 指定平台剔除\r\n/* #endif */\r\n复制代码%PLATFORM% 的取值请参考 Taro 内置环境变量以下为示例代码：.selector {\r\n  color: #fff;\r\n  /* #ifndef RN */\r\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .1);\r\n  /* #endif */\r\n}\r\n复制代码编译为 H5 和小程序的样式为：.selector {\r\n  color: #fff;\r\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .1);\r\n}\r\n复制代码RN 的样式为：.selector {\r\n  color: #fff;\r\n}\r\n复制代码两种方式选其一即可，这样就能开开心心的编写业务代码了。有些许遗憾的是产品经理对这次新版首页有着明确的上线优先级：先 H5 版，再微信小程序版，最后是 RN 版，这就为后续 RN 版本跟 H5 和 小程序版本分道扬镳埋下了伏笔，条件允许的话建议优先以 RN 版本为基准进行开发，以免开发完成 H5 和小程序之后发现对结构和样式进行大的调整，因为 RN 对样式确实会弱一些。性能优化图片优化电商性质的网站，会存在大量的素材或商品图片， 往往这些会对页面造成较大的性能影响。得益于京东图床服务，提供强大的图片定制功能，让我们在图片优化方面省去大量工作。以引入商品图片 \"https://img10.360buyimg.com/mobilecms/s355x355_jfs/t1/55430/24/116/143859/5cd27c99E71cc323f/0e8da8810fb49796.jpg!q70.dpg.webp\" 为样本，我们对图片应用做了部分优化：根据容器大小适当裁剪图片尺寸：s355x355_jfs根据网络环境设置图片品质参数：0e8da8810fb49796.jpg!q70根据浏览器环境合理选择图片类型：0e8da8810fb49796.jpg!q70.dpg.webp为 Image 标签设置 lazyload 属性，这样可以在 H5 和小程序下获得懒加载功能。接口聚合直出起初京喜首页的首屏数据涉及的后端接口多达 20 余个，导致整体数据返回时间较长；为了解决此项痛点，我们联合后端团队，独立开发首屏专用的 聚合直出接口 。一方面，将众多接口请求合并成一个，减少接口联动请求带来的性能损耗；另一方面，将复杂的业务逻辑挪到后端处理，前端只负责视图渲染和交互即可，减少前端代码复杂度；通过此项优化，页面性能和体验得到极大改善。缓存优先策略由于京喜业务主要围绕下沉市场，其用户群体的网络环境会更加复杂，要保障页面的性能，减少网络延时是一项重要措施。为了提升用户二次访问的加载性能，我们决定采用 缓存优先策略 。即用户每次访问页面时所请求的主接口数据写入本地缓存，同时用户每次访问都优先加载缓存数据，形成一套规范的数据读取机制。通过优先读取本地缓存数据，可让页面内容在极短时间内完成渲染；另外，本地缓存数据亦可作为页面兜底数据，在用户网络超时或故障时使用，可避免页面空窗的情景出现。高性能瀑布流长列表首页紧接着首屏区域的是一个支持下滑加载的瀑布流长列表，每次滑到底部都会异步拉取 20 条数据，总计会拉取将近 500 条数据，这在 iOS 下交互体验还比较正常。但是在配置较低的安卓机型下，当滑动到 2 到 3 屏之后就开始出现严重卡顿，甚至会闪退。针对这种场景也尝试过用 FlatList 和 SectionList 组件来优化，但是它们都要求规则等高的列表条目，于是不得不自己来实现不规则的瀑布流无限滚动加载。其核心思路是通过判断列表的条目是否在视窗内来决定图片是否渲染，要优化得更彻底些得话，甚至可以移除条目内所有内容只保留容器，以达到减少内容节点以及内存占用，不过在快速进行滑动时比较容易出现一片白框，算是为了性能损失一些体验，整体上来说是可以接受得。由于 RN 下在获取元素坐标偏移等数据相对 H5 和小程序要麻烦得到，具体的实现细节可以查看抽离出来的简单实现 Taro 高性能瀑布流组件（for RN） 。写在最后这篇文章从技术选型、开发实录再到性能优化三个维度对京喜首页改版做了简单总结。整个项目实践下来，证实 Taro 开发框架 已完全具备投入大型商业项目的条件。虽在多端开发适配上耗费了一些时间，但仍比各端独立开发维护工作量要少；在前端资源匮乏的今天，选择成熟的开发工具来控制成本、提升效率，已是各团队的首要工作目标。 同时，京喜作为京东战略级业务，拥有千万级别的流量入口，我们对页面的体验优化和性能改进远不止于此，希望每一次微小的改动能为用户带来愉悦的感受，始终为用户提供优质的产品体验。欢迎关注凹凸实验室博客： aotu.io"}
{"title": "小程序解析excel表格并存储到云数据库 ", "author": "Rolan", "pub_time": "2019-12-4 00:52", "content": "最近一直比较忙，答应大家的小程序解析excel一直没有写出来，今天终于忙里偷闲，有机会把这篇文章写出来给大家了。老规矩先看效果图效果其实很简单，就是把excel里的数据解析出来，然后存到云数据库里。说起来很简单。但是真的做起来的时候，发现其中要用到的东西还是很多的。不信。。。。 那来看下流程图流程图通过流程图，我看看到我们这里使用了云函数，云存储，云数据库。 流程图主要实现下面几个步骤1，使用wx.chooseMessageFile选择要解析的excel表格 2，通过wx.cloud.uploadFile上传excel文件到云存储 3，云存储返回一个fileid 给我们 4，定义一个excel云函数 5，把第3步返回的fileid传递给excel云函数 6，在excel云函数里解析excel，并把数据添加到云数据库。 可以看到最神秘，最重要的就是我们的excel云函数。 所以我们先把前5步实现了，后面重点讲解下我们的excel云函数。一，选择并上传excel表格文件到云存储这里我们使用到了云开发，使用云开发必须要先注册一个小程序，并给自己的小程序开通云开发功能。这个知识点我讲过很多遍了，还不知道怎么开通并使用云开发的同学，去翻下我前面的文章，或者看下我录的讲解视频《5小时入门小程序云开发》1，先定义我们的页面 页面很简单，就是一个按钮如下图，点击按钮时调用chooseExcel方法，选择excel对应的wxml代码如下2，编写文件选择和文件上传方法上图的chooseExcel就是我们的excel文件选择方法。 uploadExcel就是我们的文件上传方法，上传成功以后会返回一个fildID。我们把fildID传递给我们的jiexi方法，jiexi方法如下3 把fildID传递给云函数二，解下来就是定义我们的云函数了。1，首先我们要新建云函数如果你还不知道如何新建云函数，可以翻看下我之前写的文章，也可以看我录的视频《5小时入门小程序云开发》 如下图所示的excel就是我们创建的云函数2，安装node-xlsx依赖库如上图所示，右键excel，然后点击在终端中打开。 打开终端后， 输入 npm install node-xlsx 安装依赖。可以看到下图安装中的进度条这一步需要你电脑上安装过node.js并配置npm命令。 3，安装node-xlsx依赖库完成三，编写云函数我把完整的代码贴出来给大家const cloud = require('wx-server-sdk')cloud.init()var xlsx = require('node-xlsx');const db = cloud.database()exports.main = async(event, context) => {  let {    fileID  } = event  //1,通过fileID下载云存储里的excel文件  const res = await cloud.downloadFile({    fileID: fileID,  })  const buffer = res.fileContent  const tasks = [] //用来存储所有的添加数据操作  //2,解析excel文件里的数据  var sheets = xlsx.parse(buffer); //获取到所有sheets  sheets.forEach(function(sheet) {    console.log(sheet['name']);    for (var rowId in sheet['data']) {      console.log(rowId);      var row = sheet['data'][rowId]; //第几行数据      if (rowId > 0 && row) { //第一行是表格标题，所有我们要从第2行开始读        //3，把解析到的数据存到excelList数据表里        const promise = db.collection('users')          .add({            data: {              name: row[0], //姓名              age: row[1], //年龄              address: row[2], //地址              wechat: row[3] //wechat            }          })        tasks.push(promise)      }    }  });  // 等待所有数据添加完成  let result = await Promise.all(tasks).then(res => {    return res  }).catch(function(err) {    return err  })  return result}上面代码里注释的很清楚了，我这里就不在啰嗦了。 有几点注意的给大家说下1，要先创建数据表2，有时候如果老是解析失败，可能是有的电脑需要在云函数里也要初始化云开发环境四，解析并上传成功 如我的表格里有下面三条数据点击上传按钮，并选择我们的表格文件上传成功的返回如下，可以看出我们添加了3条数据到数据库添加成功效果图如下到这里我们就完整的实现了小程序上传excel数据到数据库的功能了。再来带大家看下流程图如果你有遇到问题，可以在底部留言，我看到后会及时解答。后面我会写更多小程序云开发实战的文章出来。也会录制本节的视频出来，敬请关注。"}
{"title": "小程序不同页面的异步回调，callback和promise的使用讲解 ", "author": "Rolan", "pub_time": "2019-12-5 00:23", "content": "发个扫盲贴，大神请绕道。最近好多同学问我如何再请求数据成功后直接使用数据。我们通常的做法就是在请求成功后，再调用我们定义的方法，进而使用数据。如下代码  onLoad() {    let that=this    wx.cloud.database().collection(\"users\").get({      success(res) {        that.setData(res.data)      },      fail(res) {      }    })  },  showData(dataList) {    //.........做数据处理  },我们这样写其实也没什么不对，但是如果数据请求和使用是在两个不同的页面呢。 比如我们在app.js里请求位置，获取用户信息。然后在首页index.js里要使用这些数据，那么我们这么写就有问题了。下面就来教大家两种方式来很好的解决这个问题。一，通过callback回调。先看下代码，然后我再具体给大家讲解下原理。app.js里定义如下方法然后再index.js 里这么使用这时候，其实就可以看到了，我们在首页index.js里调用了app.js里的请求数据的方法，并且可以在index.js里直接使用数据。原理讲解 原理其实很简单，就是我们在app.js里的获取数据的方法里定义一个参数。而这个参数和普通参数唯一不同的地方，就是这个参数是个function方法我们上图的callback参数，其实就是下图 function(result){}把function方法作为一个参数传递进去的目的，就是为了下面的回调。我们这个callBack参数，可以在请求数据成功或者失败的时候作为一个方法调用。这样就可以把请求到的数据，回传回去了。 讲的有点绕，不知道大家有没有被绕晕。这在java开发中，其实就相当于监听者模式。说白了就是在一个页面里监听另外一个页面的动作，如获取数据成功，当监听到数据获取成功这个动作以后，就可以直接把数据回传回来了。 如果觉得这种方法有点绕，不好使用，我们就用下面的这个第二种方式。二，promisepromise的好处就是可以不用那个层层传递，不用那么绕。 还是先看代码，后面结合代码给大家讲下原理 app.js里定义如下方法index.js里这么调用用句通俗的话说，就是通过promise让我们的数据请求和使用看上去是在同一个页面完成。怎么实现的呢 1，在app.js里把数据请求封装到promise里，然后把promise返回到我们的首页index.js里 2，在首页里使用这个promise 实现数据的获取和使用。 在具体些就是下面这几步 promise基础用法1、new 一个Promise对象 2、请求数据的异步代码写在promise的函数中 3、promise接受两个参数，一个resolve(已成功success)，一个reject(已失败fail) 4、promise有三种状态pendding(进行中，当new了promise就是pendding的状态)、fulfilled(已成功)、rejected(已失败)，当成功的时候调用resolve将状态改为已成功，当失败的时候调用reject将状态改为已失败，一旦状态发生改变之后，状态就凝固了，后面就无法改变状态了，成功会将成功的数据返回，失败会将失败的信息返回。 5、在需要获取数据的地方通过promise.then()的方式获取，这里面接受两个参数，都是匿名函数，第一个是接受成功的函数，第二个是失败时候的函数好了，到这里我们两种不同页面的异步回调就给大家将完了。代码就完整的给大家贴出来吧，方便大家日后使用app.js//app.jsApp({  //第二种，通过promise  promiseGetData() {    let promise = new Promise(function(success, fail) {      wx.cloud.database().collection(\"users\").get({        success(res) {          success(res)        },        fail(res) {          fail(res)        }      })    })    return promise;  },  //第一种，通过callback的方式来实现回调  callBackGetData(callBack) {    wx.cloud.database().collection(\"users\").get({      success(res) {        callBack(res)      },      fail(res) {        callBack(res)      }    })  },})index.js// 异步调用，callbackconst app = getApp()Page({  clickBtn() { //按钮点击    //callback方式    // app.callBackGetData(function(result) {    //   console.log(\"dataList\", result)    // })    //promise方法    let promise = app.promiseGetData()    promise.then((res) => { //获取成功的结果，res中存着获取成功时的数据      console.log(\"成功\", res)    }, (error) => { // 获取数据失败时      console.log(\"失败\", error)    })  },})"}
{"title": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 ... ", "author": "Rolan", "pub_time": "2019-12-5 00:31", "content": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 在做小程序的时候，要实现下面的搜索历史界面下面的搜索很明显的想到是用flex布局，然后把justify-content设置为justify-content: flex-start; 代码如下：<view class=\"flex\"><button class=\"item\">1</button><button class=\"item\">2</button><button class=\"item\">3</button><button class=\"item\">4</button><button class=\"item\">5</button><button class=\"item\">6</button><button class=\"item\">7</button></view>.flex{  display: flex;  flex-wrap: wrap;   justify-content: flex-start;}.flex .item{  width: 216rpx;  background-color: red;  margin-bottom: 34rpx;}可效果却不尽人意，发现justify-content不起作用，无论怎么设置都是space-around的效果。 经过排查，发现原因是小程序button中的默认样式中的margin-left: auto;margin-right: auto;所引起的。flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自探秘 flex 上下文中神奇的自动 margin原因找到了，具体修改就容易多了，我们可以覆盖button的margin-left和margin-right的默认值，或者在button外面包裹一层view。在遇到这个问题之前，我也没想到过flex和margin之间还能这么用，涨姿势了"}
{"title": "微信小程序|CSS的内边距和圆框 ", "author": "Rolan", "pub_time": "2019-12-9 00:02", "content": "本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述在制作小程序的时候会经常用到浮动来设计各种组件的排版，微信小程序对排版的要求很高。 光有浮动是远远不够的，如果一个板块内的组件过多就会变得混乱。 所以就需要用设置内边框来调整位置。 微信小程序中会有很多的头像设置，所以就会用到圆框。 那么如何来设置css盒子的内边框和头像的圆框呢？解决方案跟网页一样小程序也是用很多标签来定义的。 需要用css盒子来设置解决问题，并调用来实现问题。（1）内边距我们需要用到margin这个标签代表内边距，用rpx来设置距离单位。 在.wxss中设置，然后在wxml中调用就可以了。margin-left： 离左边的距离margin-right： 离右边的距离margin-top： 离上边的距离margin-bottom： 离下边的距离margin-top: 100rpx;margin-left: 10rpx（2）框 用border来定义框线的宽度，用width和heigth来设置框的长宽。solid来定义颜色。 跟内边距一样在.wxss中设置，然后在wxml中调用。.view4{margin-top: 0rpx;margin-left: 0rpx;width: 800rpx;height: 115rpx;border: 5rpx solid whitesmoke}（3）圆框border-radius： rpx定义圆框。.view3{margin-top: 350rpx;margin-left: -190rpx;height: 60rpx;width: 220rpx;float: left;background-color: rgb(131, 178, 240);border-radius: r5px}（4）圆框头像跟上面的圆框一样也是用border-radius来定义，但不同的是后面的设置： %。 就是一个圆的弧度不同，rpx是将框的四角成为圆弧而%是成为一个圆。.view1{float: left;margin-left: 290rpx;margin-top: 120rpx;border-radius: 50%}结语对标签的正确使用和调用， 最麻烦的是对标签后面的单位设置，必须充满耐心，你需要不断地调才能调到你需要的位置，才能使界面美观。END实习编辑 | 王文星责 编 | 江汪霖where2go 团队微信号： 算法与编程之美"}
{"title": "解决小程序渲染复杂长列表，内存不足问题 ", "author": "Rolan", "pub_time": "2019-12-9 00:12", "content": "问题回顾：我们有一个列表展示页，是无限瀑布流式的，展示的元素我们封装成了单个组件，暂且叫它Item组件。这个瀑布流包含若干个Item组件，并且这个Item组件也比较复杂，包含各种展示样式（根据不同类型，大概有9种吧，反正渲染节点很多），在进行滑动的过程中，item大概加载30-40个以后，就会造成小程序内存不足而退出，蓝瘦香菇......【干货在最后，小程序代码片段奉上】\r\n\r\n解决思路：\r\n将超出屏幕一定部分的列表内的组件进行不渲染的处理（也就是用wx:if卸载掉组件），当到达渲染临界点时再开始渲染；保证每次少量的数据展示。\r\n\r\n我们的项目中是保持15条Item，我们是每次分页请求5条，按照前5条，中间5条和后5条来划分，如果不在这个范围，则用一个等高度的骨架代替，并且卸载这些组件\r\n\r\n初期实现方式（后面有更优化的方式）\r\n使用曝光监听，当一个Item曝光时，记录Item高度，并放到数组里面，作为骨架的填充高度，如果已经记录了高度，则不再重复记录；曝光时向外传递一个当前渲染范围的中心值（比如当前Item所属页码，或者当前Item索引），以此进行处理；\r\n\r\n这里有一点要注意，如果你的列表item组件比较复杂，需要在ready的时候将记录的高度设置为item最小高度，不然组件重新装载时会有一定的渲染时间，在临界点会造成跳屏【此处已经通过骨架组件解决，可以忽略，只是作为踩坑记录】\r\n\r\n此时优化点\r\n\r\n为避免频繁setData和渲染，做了防抖函数，时间是600ms\r\n\r\n此时缺点\r\n\r\n滑动特别快时，会出现白屏，是因为曝光监听是在组件里面，而超快速滚动时，组件没有装载进来，也无法进行曝光监听，所以无法触发，这里考虑用骨架组件进行二次监听曝光\r\n\r\n优化迭代\r\n\r\n将骨架组件作为外壳套在Item外面（用slot），并对骨架进行监听曝光，可以解决上面缺点\r\n给骨架组件做一个常规骨架屏样式，而不是纯白色，看起来更优雅\r\n\r\n继续发现问题\r\n经过一系列的实践，上面的方案有些问题，其中最麻烦的就是，需要对外传递一个当前index，然后控制前后数据展示；这里对于每个用到skeleton组件的页面来说，都要重复的写一个方法来承接这个index，然后渲染页面对应的数据。\r\n优化\r\n依然是监听skeleton曝光，这里监听的方案变为出现在屏幕上下n屏的内容块进行展示，此范围外的内容块就卸载掉。\r\n如图所示\r\n\r\n核心代码\r\n     // 修改了监听是否显示内容的方法，改为前后showNum屏高度渲染\r\n     // 监听进入屏幕的范围relativeToViewport({top: xxx, bottom: xxx})\r\n      let info = SystemInfo.getInfo() //获取系统信息\r\n      let { windowHeight = 667 } = info.source.system\r\n      let showNum = 2 //超过屏幕的数量，目前这个设置是上下2屏\r\n      let listItemContainer = this.createIntersectionObserver()\r\n      listItemContainer.relativeToViewport({ top: showNum * windowHeight, bottom: showNum * windowHeight })\r\n        .observe(`#list-item-${this.data.skeletonId}`, (res) => {\r\n        \t// 此处来控制slot展示，详见代码片段\r\n        })\r\n       \r\n复制代码干货\r\n话不多说，干货放后面，点击获取代码片段\r\n最后，还是尽量减少节点数，优化代码"}
{"title": "微信小程序setData复杂数组的更新、删除、添加、拼接 ", "author": "Rolan", "pub_time": "2019-12-9 00:20", "content": "众所周知，微信小程序里所有对数据的修改只有在setData里修改才会在页面上渲染。在此分享小程序里复杂数组的更新、删除、添加、拼接 初始数据数组嵌套对象data: {\r\n    cartList = [{ id: 1, goods: {id: 1, name: 'wechat'}, checked: true }, { id: 2, goods: {}, checked: false }, { id: 3, goods: {}, checked: true }]\r\n }, 索引部分删除1 let index = 2;\r\n2 let cartList = this.data.cartList\r\n3 cartList.splice(index, 1)\r\n4 this.setData({\r\n5         cartList: cartList\r\n6       }) 内部部分修改只修改数据内某项里的某属性。但此方法对于有引用到被修改的数据的wxs不会刷新页面显示，尚未清楚是bug还是小程序本身就不支持。let index = 2\r\nlet updateTodo = `cartList[${index}].checked`\r\nthis.setData({\r\n          [updateTodo]:  true\r\n        })用一个变量接收要修改的数组，修改好后再整体setData赋值，如果原数据很大的话可能会影响性能。1 let index = 2\r\n2 let cartList = this.data.cartList;\r\n3 cartList[index].checked = res.data.checked\r\n4 this.setData({\r\n5           cartList: cartList\r\n6         }) 添加、拼接push和concat 1 // push改变原数组\r\n 2 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n 3 let cartList = this.data.cartList;\r\n 4 cartList.push(...newList);\r\n 5 this.setData({\r\n 6           cartList: cartList\r\n 7         })\r\n 8 \r\n 9 // concat返回添加后的副本，并不会修改原有数组\r\n10 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n11 let cartList = this.data.cartList;\r\n12 this.setData({\r\n13           cartList: cartList.concat(newList)\r\n14         })"}
{"title": "解决微信小程序安卓机器上 backgroundAudioManager 的一个坑 ", "author": "Rolan", "pub_time": "2019-12-9 10:32", "content": "一句话来说，问题的根源就在于安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate背景在做的小程序中要做的一个功能是 AB 定次重复：重复播放音频中 A 秒到 B 秒的声音 N 次。根据我的需求，理想中流程是通过 backgroundAudioManager 的绑定事件完成功能（这里先不讨论 B == backgroundAudioManager.duration 的情况）。设定backgroundAudioManager的title和srcbackgroundAudioManager.seek(A)backgroundAudioManager.onSeeking()backgroundAudioManager.onSeeked()\t4.a backgroundAudioManager.play();backgroundAudioManager.onTimeUpdate\t5.a 如果 backgroundAudioManager.currentTime >= B, backgroundAudioManager.pause()\t5.a.1 如果没达到重复次数，回到步骤2\t5.b 如果 backgroundAudioManager.currentTime < B，回到步骤5问题在几次摸索后 iOS 上可以完美完成，但是安卓上会跳次数，比如希望一共播放3次，在播放完第一次之后会直接跳过第二次进行第三次的播放，最后一共只播放了两次。解决我在网上搜的时候发现有人写到了\tbackgroundAudioManager中的一些坑 ，其中提到暂停状态下跳转到指定位置，在 onSeeked() 回调中，Android 的 currentTime 是跳转前的时间，而 iOS 是跳转后的时间。一开始我以为完全是这个原因，seek 后第一次 onTimeUpdate 时 currentTime >= B导致直接跳次数，所以我就加上一个 boolean 变量，在 onSeeked 中将它赋值为 true，用它判断是否刚执行 seek，如果否再进行 currentTime 的判断。但是改来改去问题还是存在。在加了一堆 console.log，反复和 iOS的结果比较后为发现了问题的根本所在。安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate找到了问题解决起来就比较简单啦，在 onTimeUpdate 中先判断 backgroundAudioManager.paused 是否为 true，只有在 backgroundAudioManager.paused == false 时才进行步骤5的流程。结论backgroundAudioManager 和 innerAudioContext 写起来，测试起来都好痛苦。同样的代码 innerAudioContext 在 2.6.1 可以在开发工具中完成我要的效果，但是后面的版本就不行了。而且 iOS，Android 还有开发者工具上的行为都不一样，每次改一点就要用两个手机扫码预览还是挺不方便的。希望官方可以优化一下。这篇文章我原本发在微信小程序交流专区https://developers.weixin.qq.com/community/develop/article/doc/00086c3f998a603d51899109151013"}
{"title": "小程序开发中的一些实践和踩坑 ", "author": "Rolan", "pub_time": "2019-12-10 00:23", "content": "在公司小程序也开发了一段时间了，中间遇到过很多问题，特此记录几个比较典型的问题和解决方案。01—textarea 的高层级问题此问题提供源码demo，可导入微信开发者工具查看。复制到电脑上打开：https://github.com/dunizb/CodeTest/tree/master/Wechat/textarea-test 症状（表现）textarea 是小程序的原生组件，它的一个表现就是优先级很高，这导致了一些困扰，比如我们有一个表单页面，最下面就是一个textarea和一个保存按钮，这会导致textarea的文字会浮现在按钮上。如下图：它最大的问题是会导致保存按钮可能点击无效或者会弹出键盘，并且开发者工具模拟器和真机表现不一样，这真是个坑！诊断（实验）模拟器中，针对 position:fixed 定位的按钮，我们加一个 z-index:10 即可， z-index 等于多少合适不清楚，试了等于1是不行的，10就可以，其余的值没试过。.submit-cls {  position: fixed;  left: 30px;  right: 30px;  bottom: 300px;  text-align: center;  background-color: green;  color: #fff;  z-index: 10;}模拟器中的表现：然儿，真机上（Android）依然无效！如下图：于是我想到了 cover-view 标签，cover-view 是微信提供的一个原生组件，它是覆盖在原生组件之上的文本视图，可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher之上，只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。用 cover-view 标签包裹 button 如何呢？郁闷的事情发生了，真机上按钮不见了！。。。这方法貌似不行。。<cover-view>  <button class=\"submit-cls\" id='button' bindtap=\"onClick\"> Button z-index: 10 </button></cover-view>那我直接用 cover-view 标签作为按钮呢？<cover-view class=\"cover-view-clas\" id='cover-view' bindtap=\"onClick\"> cover-view z-index: 10 </cover-view>.cover-view-clas {  position: fixed;  height: 40px;  line-height: 40px;  left: 30px;  right: 30px;  bottom: 250px;  text-align: center;  background-color: orangered;  color: #fff;}结果在模拟器里不行但是真机上表现很好。于是我也加了一个 z-index: 10 ，这样模拟器和真机表现就一致。药方（总结）综上所述，要解决这个问题似乎只有一个办法，那就是用 cover-view + z-index:10 ，然儿这样会导致一个的副作用，没法使用微信的开放能力比如 open-type。02—setData优化我们知道，与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。然而当 setData 传递大量的新数据、频繁的执行 setData 操作、过多的页面节点数时会影响渲染性能。区分数据类别意思是， setData 只用来通知页面更新，只有需要通知页面更新的时候，页面引用了某个 data 字段时才使用，其它字段数据我们有时候可能只是为了让 js 方便使用。比如如下数据data: {    form: {        name: 'xxxx',        ... ...    },    index: 0}假如 页面上根本没用到 index 来展示，只是我们的逻辑变量，那么我们在赋值的时候就直接 this.data.index = xxx 即可，不要用 setData 去赋值了。合理利用局部更新setData 是支持使用 数据路径 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景：list 列表是从后台获取的数据，并展示在页面上，当 list 列表的第一项数据的 src 字段需要更新时，一般情况下我们会从后台获取新的 list 列表，执行 setData 更新整个 list 列表。// 后台获取列表数据const list = requestSync(); // 更新整个列表this.setData({ list });实际上，只有个别字段需要更新时，我们可以这么写来避免整个 list 列表更新:// 后台获取列表数据const list = requestSync(); // 局部更新列表this.setData({   'list[0].src': list[0].src});善用自定义组件小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似：在页面引用自定义组件后，当初始化页面时，Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用，这是组件化带来的好处。基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。03—大表单交互的一点实践经验在项目中，有一个预约模块，字段忒多，保险业务嘛，需要用户填写各种数据的，为了用户体验拆成了多个步骤，如图一开始，业务上要求切换tab的时候数据要缓存，跟Vue的 keep-alive 一样，但是小程序没有这样的机制，所以利用小程序的 hidden 属性，也就是 Vue 中的 v-show，组件始终会被渲染，只是简单的控制显示与隐藏。关于wx:if 和 hidden。这样的导致页面节点太多，在低性能手机上会出现卡死的现象，直接无法渲染或者渲染太慢。后来改为 wx:if 来切换<view wx:if=\"{{current === 0}}\">......</view><view wx:if=\"{{current === 1}}\">......</view><view wx:if=\"{{current === 2}}\">......</view>... ...这样一来一次渲染节点太多的问题解决了，但是怎么实现tab切换的时候输入的内容杯缓存呢？其实我们的笨办法就是切换的时候把前一个表单内容保存到 localStorage 或 gloabData 中，切换回去的时候再取出来填充，这中间会有一个明显的渲染过程，肉眼可见，没办法，目前只能牺牲一点点体验了。对于这种大型表单，数据处理和逻辑交互的时候要非常注意，很容易出现性能问题。这次就说这么多吧，文章如有什么错误，或有什么想法，请留言，不吝赐教！"}
{"title": "Kbone原理解析 & 小程序技术选型 ", "author": "Rolan", "pub_time": "2019-12-12 00:24", "content": "转载自微信开放社区： https://developers.weixin.qq.com/community/develop/article/doc/0006a6326b8d38e56b998833456813官方介绍“Kbone 是一个致力于微信小程序和 Web 端同构的解决方案。”Web端框架基本原理首先我们来看下普通Web端框架，以Vue框架为例，一份Vue模板对应一个组件，在代码构建阶段编译成调用Dom接口的JS函数，执行此JS函数就会创建出组件对应的Dom树，从而渲染到浏览器页面上。然而，小程序是双线程的，并没有Dom树的概念，逻辑层和视图层完全分离，逻辑层是一个纯粹的JSCore,开发者可以编写JS脚本，但是无法直接调用Dom/Bom的api, 没有任何浏览器相关的实现。在小程序中，视图层和逻辑层的交互是通过数据和时间驱动的。因此，要实现跨端同构，问题是：怎么将web端代码转为小程序代码？业界常规做法目前业界流行的第三方跨端框架们，常规做法都是：静态编译兼容。原理是把代码语法分析一遍，然后将其中的模板部分翻译成对应的跨端需求的模板（微信小程序、支付宝小程序、H5、APP等）。静态编译最大的局限性是无法保证转换的完整性，因为Vue模板和WXML模板的语法并不是直接对等的，Vue的特性设计也和小程序的设计无法划等号，这自然就导致了部分Vue特性的丢失。比如像Vue中的v-html指令、ref获取Dom节点、过滤器等就通通用不了。除了Vue自身的特性外，一些原本依赖Dom/Bom接口的Vue插件页无法使用，例如Vue-Router。Kbone的做法Kbone是通过提供 适配器 的方式来实现同构，即运行时兼容，而非静态编译。Kbone的适配器核心包含两个部分：miniprogram-render： 仿造Dom/Bom接口，构造仿造Dom树；miniprogram-element: 监听仿造Dom树变化，渲染到页面，同时监听用户行为，触发事件。仿造Dom树和浏览器的运行时对比：仿造Dom树：利用内置组件和自定义组件的自引用来进行递归，创建组件树。如图，自定义custom-dom为递归自引用组件：递归的终止条件是遇到特定节点、文本节点或者children空节点。在创建出组件树猴，将Dom节点和自定义组件实例进行绑定，以便后续的Dom更新和操作。kbone这里还对节点数进行了优化：如果一个dom节点对应一个自定义组件的话，就会创建很多自定义组件，这样会很浪费开销，这里做了子树的合并，也就是说3层才创建一个自定义组件，节省开销。优化前：17个dom=17个自定义组件； 优化后：17个dom=4个自定义组件，蓝色那个是单节点，会合并到上面的树；dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。一棵很大的 Dom 树，一次性 setData 到视图层，可能会超过 setData 的大小限制（1024kB），拆分成多棵子 Dom 树，然后分批的 setData 到视图层，可以节省开销。事件监听小程序的事件是视图层到逻辑层的通讯方式，事件绑定在组件上，当被触发时，就会执行逻辑层中对应的事件处理函数。小程序的捕获冒泡是在视图层view端，因此逻辑层在整个捕获冒泡流程中各个节点接收到的事件不是同一个对象，小程序事件的捕获冒泡和阻止冒泡等操作必须在WXML模板中生命，无法使用接口实现。为了能够让web端和小程序端的事件系统行为一致，kbone除了仿造了一份Dom树外，也把整个事件系统仿造了一份，即在仿造Dom树上进行捕获冒泡。当自定义组件监听到用户的操作后，就将事件发往仿造Dom树，后续自定义组件监听到的同一个事件的冒泡就直接忽略。当触发改节点，仿造Dom树接收到事件后，再进行捕获和冒泡，让事件在各个节点触发。Kbone的优势支持多个前端框架：Vue、React、Preact 等支持更为完整的前端框架特性： Vue 中的 v-html 指令、Vue-router 插件等提供了常用的 dom/bom 接口可以使用小程序本身的特性： live-player 内置组件、分包功能等提供一些 Dom 扩展接口：getComputedStyle 接口等Kbone实践脚手架kbone-cli官方已经提供了kbone-cli可以用来快速开发：用npm全局安装kbone-cli可以根据自己的技术栈选择不同的开发模板：React/Vue/Omi/Preact然后就可以愉快的进行开发啦~生成的demo项目结构如下：demo中包含了多页跳转、vue-router、vuex等的使用示例，以及mp-webpack-plugin的配置示例。对于多页面的应用，在 Web 端可以直接通过 a 标签或者 location 对象进行跳转，但是在小程序中则行不通。同时 Web 端的页面 url 实现和小程序页面路由也是完全不一样的。Demo示例对比其中，有一部分两端差异的业务逻辑功能，也给出了3中不同的解决方案：利用vue-improve-loader，在构建时对dom树节点进行删减，在需要提出的节点加上check-reduce属性 利用reduce-loader，将业务中不需要被打包的代码进行去除，使用行内loader和环境变量来判断 使用样式隐藏，即设置不需要显示的节点样式为 display:none其他问题在实际开发中，还会碰到一些细节，例如：多页面开发：修改webpack和mp-webpack-plugin配置小程序内置组件： 部分用html标签代替，其他用wx-component + behavior标签小程序自定义组件：修改mp-webpack-plugin配置，补充wxCustomComponents字段，将自定义组件放入组件根目录，使用自定义组件自定义app.js和app.wxss：监听app的生命周期，修改webpack配置补充app.js的构建入口，修改插件配置的generate.app字段，补充app.js扩展dom/bom对象和API：使用 window.$$extend追加方法代码优化：用reduce-loader做体积精简，dom树精简用vue-improve-loader区分环境实现不同功能：process.env.isMiniprogram更新迭代kbone由于目前在快速发展期，更新迭代非常迅速，以下特性是对比了8月份的版本和11月份版本，可以看出已经解决了近2/3的问题。小程序技术选型详细了解了kbone之后，我们来分析下小程序技术框架到底应该怎么选？kbone & 小程序原生已有web版，需要小程序版：kbone跨平台需求（web + 小程序）：kbone对性能特别苛刻 or 追求稳定 or 要用最新功能：小程序原生页面节点数量特别多（ 1000 节点以上），且对渲染性能要求高：静态模板转义方案（第三方框架：mpvue/taro等）第三方框架MpVue ：不推荐再用了，坑越来越多，内部也表示之后不会投入太多维护WePY 1.7.x ：不推荐再用了：1.7.x 的版本在最初的设计上的缺陷导致遗留了很多比较严重的问题WePY 2.0：现在还是 alpha 阶段，内外部有一些小程序在跑，体验和反馈还可以。但依然 issue 比较多。害怕踩坑的也不推荐使用Taro: 也还是有不少问题，但相对来说应该是比 mpVue 和 WePY 更稳定一点Uni-app：mpvue的衍生版，跨端 (官方示例有6端) 支持的很好，在H5端实现了一套微信模拟器，可以尝试，是目前唯一支持app端的商用方案，有独立的编辑器HBuildXChameleon: 统一的多态协议，渐进式跨端，提供脚手架命令工具，规划比较宏大Omi ：基于Taro完成的框架，kbone有支持omi的模板Nanachi: 基于react的编译期间的转义框架总结没有跨端需求，只需要微信小程序 ==> 小程序原生web端转小程序 or 两端 or 想要尝鲜 ==> kbone多端 or Vue 技术栈 ==> uni-app多端 or React 技术栈 ==> taro不介意学习新技术栈 ==> wepy 2.0 or chaemeleon写在最后小程序在非常快速的更新迭代，就算是原生框架也还是有一些坑的，因此没有哪种框架是百分之百完美，需要根据业务具体需求以及自身技术栈偏好来进行选择。文章中提及到的部分第三方框架只是参考了官方文档，没有逐个一一尝试，有问题麻烦指出，鞠躬~~"}
{"title": "微信小程序极致的scroll-view的下拉刷新扩展组件 ", "author": "Rolan", "pub_time": "2019-12-13 00:11", "content": "其实原理很简单，和普通H5以及市面上有的下拉刷新没有特别大的区别，都是基于 touch 手势检测事件来实现下拉刷新的。 touchstart 的时候记录当前触摸点， touchmove 的时候开始计算移动方向和移动距离, touchend 的时候计算是否要进行下拉刷新操作。如图所示：实现方法调研了一些实现方法，目前大部分都是通过js计算，然后setData来改变元素的 transform 值实现下拉刷新。考虑到性能问题，此处使用了 wxs 的响应式能力来实现整个计算逻辑，不用通过逻辑层和视图层通信，直接在视图层进行渲染。具体文档请参考 wxs响应事件 。这里在 list 组件(由 scroll-view 组成)下抽出了一个 scroll.wxs 作为响应事件的事件处理函数集合，源码基本上就在 scroll.wxs 和 list 组件。scroll.wxs 定义了如下变量和函数：var moveStartPosition = 0     //开始位置\r\nvar moveDistance = 0          //移动距离\r\n\r\nvar moveRefreshDistance = 60  //达到刷新的阈值\r\nvar moveMaxDistance = 100     //最大可滑动距离\r\nvar isRefreshMaxDown = false  //是否达到了最大距离， 用来判断是否要震动提示\r\n\r\nvar loading = false           //是否正在loading\r\n\r\n... ...\r\n\r\nmodule.exports = {\r\n  touchStart: touchStart, //手指开始触摸事件\r\n  touchMove: touchMove, //手指移动事件\r\n  touchEnd: touchEnd, //手指离开屏幕事件\r\n  loadingTypeChange: loadingTypeChange, //请求状态变化监听，监听刷新请求开始和请求完成\r\n  triggerRefresh: triggerRefresh //主动触发刷新操作，比如点击页面上一个按钮，重新刷新list，这就需要用到这个方法\r\n}\r\n复制代码touchStart 和 touchMove 就不用说了，代码注释都很明白，普通的监听移动和处理逻辑。touchEnd 主要是判断移动距离是否达到了阈值，然后根据结果，调用监听实例的 callMethod 方法触发 refreshStart 或者 refreshCancel 方法，这两个方法都是写到 list 组件里面的，用来触发刷新方法或者取消刷新。loadingTypeChange 方法主要是监听刷新是否完成，以此来触发动画效果。triggerRefresh 通过监听主动触发的变量来处理。如果需要主动触发刷新，则调用 list 组件内部的 forceRefresh 方法，具体使用示例在 index/index/js 的 onLoad 函数有: this.selectComponent('.list').forceRefresh()scroll.wxs 里面还有一个未导出的方法，叫 drawTransitionY ，这个方法主要是因为 ios12对于 transition 动画效果支持的不好，所以自己写了个Y轴方向的动画（ linear 线性的），大佬们可以自己往上添加各种 ease-in-out 效果。里面具体的实现可以查看代码注释哦~使用好了，前面讲了实现的原理和方法，那么在代码里面，应该怎么直接使用呢？如下代码所示：<!-- 使用示例 -->\r\n<list class=\"list\" refresh-loading=\"{{refreshLoading}}\" loading=\"{{loading}}\" bindrefresh=\"initList\" bindloadmore=\"loadmore\">\r\n  <!-- your code -->\r\n</list>\r\n复制代码refresh-loading 属性用来通过外部loading态来控制刷新动画的开始结束，因为每当变化 refresh-loading 的值时，会将变化同步到组件内的 showRefresh 属性， wxs 通过监听 showRefresh 来处理动画逻辑。loading 属性是上拉加载更多的时候触发的loading态展示，跟刷新无关bindrefresh 是刷新触发时绑定的函数，下拉刷新动画成功开始后触发这个函数bindloadmore 透传 scroll-view 的加载更多方法当然，源码里面也包含了一个 list-item 组件，这个跟本文没太大关系，是用来做瀑布流长列表内容太多时的内存不足问题解决方案的，具体请看 解决小程序渲染复杂长列表，内存不足问题"}
{"title": "捕获web与小程序JS异常的方法 ", "author": "Rolan", "pub_time": "2019-11-26 00:50", "content": "前段时间，我们发现小程序异步代码里的错误没有上报到异常监控平台，经过排查这部分小程序没法直接监听到，需要我们手动上报。再者，开发过程中，异常处理一直是不太受重视且容易遗漏的模块。本文总结了JS异常的类型及捕获方法，最后针对小程序给出错误处理经验。JS异常分类Error：常规异常，一般为用户自定义的异常，如 new Error(\"error message\")，这类自定义的错误用来统计异常数据，直接上报即可；RangeError：数值溢出越界异常，当 Number 类型变量超过指定的范围，如var pi = 3.14159;  pi.toFixed(100000);d（toFixed()方法参数只能接受 0~100） ；ReferenceError：引用异常，当不存在的变量被使用的时候，这类错误一般在编码检查阶段就会暴露；SyntaxError：语法错误，作为解释型语言的 JavaScript 只有到执行的时候才能识别出语法错误，这类错误在编码检查和构建阶段就会暴露；TypeError：类型错误，当调用不存在的对象方法或对象不存在时，例如：var foo = {}; foo.bar();为了避免这类错误出现，可使用防御式编程，但如若数据有误则应抛出异常；URIError：encodeURI() 和 decodeURI() 方法参数不正确抛出的异常，例如：decodeURIComponent(\"%\");EvalError：eval() 方法参数不正确抛出的异常；Web端对异常的捕获能力了解了异常的分类后，我们还需要知道浏览器如何捕获到这些异常。1）try-catchJavaScript 里有 try-catch 语法块，可用于异常捕获处理。try-catch 可以成功捕获大部分错误，但对于 SyntaxError 语法错误 和 异步代码中的错误，则无法捕获。例如：SyntaxError 语法错误try {\r\n    var p = \r\n} catch(e) { \r\n    console.log('caught error: ', e.message)\r\n}\r\n\r\n// 输出：Uncaught SyntaxError: Unexpected token '}'复制代码例如：异步代码中的错误try {\r\n    setTimeout(function() {\r\n        var p = error + 1\r\n    }, 0)\r\n} catch(e) {\r\n    console.log('caught error:', e.message)\r\n}\r\n\r\n// 输出：Uncaught ReferenceError: error is not defined复制代码2）error 事件try-catch 针对我们预感到可能会有问题的代码，捕获异常进行处理，而对于一些我们未知的错误，可以使用 window 对象的 error 事件进行监听。error 事件可以捕获到同步或异步（非 Promise ）代码中的非语法错误。例如：异步代码中的错误window.addEventListener('error', e => {\r\n  console.log('caught error', e.message);\r\n  e.preventDefault();\r\n});\r\nsetTimeout(function() {\r\n    var p = error + 1\r\n}, 0)\r\n\r\n// 输出：caught error Uncaught ReferenceError: error is not defined复制代码需要注意的是：e.preventDefault() 在 error 监听事件中调用，可以阻止报告异常给浏览器，别让浏览器默认地在控制台输出错误。另外，文档中也提到关于资源加载失败的错误：When a resource (such as an <img> or <script>) fails to load, an error event using interface Event is fired at the element that initiated the load, and the onerror() handler on the element is invoked. These error events do not bubble up to window, but (at least in Firefox) can be handled with a window.addEventListener configured with useCapture set to True.对于图片或脚本资源加载失败，这类错误不会冒泡给 window，但可以在捕获阶段进行处理，即addEventListener 最后一个参数置为 true：window.addEventListener('error', e => {\r\n    console.log('资源加载失败');\r\n}, true)复制代码3）unhandledRejection 与 rejectionhandled 事件error 事件可以捕获到非 Promise 的异步错误，而针对 Promise，window对象有专门的事件来处理这类错误。当异步错误没被 catch 住时，触发 unhandledRejection 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\n\r\n// 输出：caught unhandledrejection ReferenceError: error is not defined复制代码而当异步错误一开始未被 catch 住，过后才被 catch 的情况，会先触发 unhandledRejection 事件，当被 catch 的时候，会触发 rejectionhandled 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nwindow.addEventListener('rejectionhandled', e => {\r\n    console.log('caught rejectionhandled', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\nsetTimeout(() => {\r\n    p.catch(e => console.log('catch', e.message))\r\n}, 1000)\r\n\r\n// 输出：\r\n// caught unhandledrejection ReferenceError: error is not defined\r\n// （1s后）\r\n// catch error is not defined\r\n// caught rejectionhandled ReferenceError: error is not defined复制代码也就是说未处理的异常增加时会触发 unhandledRejection，而未处理的异常（被处理后）减少时会触发 rejectionhandled，这在上报异常中可以避免上报那些已经被处理过的异常。关于兼容性，截止至本文成稿，移动端的支持程度还是可以的，iOS主流版本 和 Chrome 都支持：（图来源：unhandledrejection/rejectionhandled events，caniuse.com/#search=unh…）小程序端对异常的捕获能力小程序的 App 对象中有 onError 方法，相当于 web 端的 error 事件，可以捕获到同步或异步（非 Promise ）代码中的非语法错误。而对于 Promise，小程序并没有如 window 对象中的 unhandledRejection 与 rejectionhandled 事件，无法像 web 端那样统一处理异常。不过，既然都是 Promise 相关的错误，那么，我们可以改写或覆盖 Promise 对象，将其进行封装把所有错误都 catch 住也就可以了。推荐 promise-polyfill 这个轻量级的 promise 实现包，其中提供了 _unhandledRejectionFn 方法，用于捕获那些未被处理的 Promise 异常。import Promise from 'promise-polyfill';\r\nPromise._unhandledRejectionFn = function(rejectError) {\r\n    // 处理异常或上报\r\n}\r\n复制代码总结关于JS的异常总结已经差不多了，之前一直觉得这部分知识不够系统，一来自己重视程度不够，二来也是知识点不多但都较零散。经过这段时间收集资料，捋清思路，编码实现还算有所收获，便总结成文，若有不尽不祥不对之处烦请各位读者多多指点。参考文献Exceptional Exception Handling in JavaScript前端代码异常监控实战GlobalEventHandlers.onerrorPromise rejection events in Using Promisespromise-polyfill"}
{"title": "微信小程序：扭蛋抽奖机-css3动画实现 ", "author": "Rolan", "pub_time": "2019-11-26 00:59", "content": "最近快速上线一个抽奖活动，又不想用canvas做，思考了很久，还是决定使用css3的动画来做，只要小球动得快，就没人发现我这些个小球的运动路径都是一样的了。先上动图。扭蛋机抽奖.gifwxml文件：<view class=\"ball-box\">      <image class=\"ball ball_1 {{start?'weiyi_1':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_2 {{start?'weiyi_2':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_3 {{start?'weiyi_3':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_4 {{start?'weiyi_4':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_5 {{start?'weiyi_5':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_6 {{start?'weiyi_6':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_7 {{start?'weiyi_7':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_8 {{start?'weiyi_8':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_9 {{start?'weiyi_9':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_10 {{start?'weiyi_10':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball4.png\"></image>      <image class=\"ball ball_11 {{start?'weiyi_11':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball4.png\"></image></view>这个做得我头皮发麻，但是写这篇文章时突然想到，为啥不用个for循环来做呢？！<view class=\"ball-box\">  <image wx:for=\"ballList\" wx:for-index=\"i\" class=\"ball ball_{{i}} {{start?'weiyi_{{i}}':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball{{i}}.png\"></image></view>这样看起来是不是舒服多了，因为是这段代码现场手写，如果有啥bug也不好说。wxss文件：.weiyi_1 {  animation: around1 1.5s linear infinite;  -webkit-animation: around1 1.5s linear infinite;}简单的动画/* 位移 */@-webkit-keyframes around1 {  0% {    -webkit-transform: translate(0rpx, 0rpx)  }  20% {    -webkit-transform: translate(100rpx, -250rpx)  }  40% {    -webkit-transform: translate(200rpx, -100rpx)  }  60% {    -webkit-transform: translate(50rpx, -230rpx)  }  80% {    -webkit-transform: translate(300rpx, -50rpx)  }  100% {    -webkit-transform: translate(0, 0)  }}@keyframes around1 {  0% {    transform: translate(0rpx, 0rpx)  }  20% {    transform: translate(100rpx, -250rpx)  }  40% {    transform: translate(200rpx, -100rpx)  }  60% {    transform: translate(50rpx, -230rpx)  }  80% {    transform: translate(300rpx, -50rpx)  }  100% {    transform: translate(0, 0)  }}简单的位移 其他就不一一列出来了，反正都差不多，改变一下运动轨迹就行了。js文件：相比丧病的样式，js文件就简单多了。_this.setData({  start: true})控制抽奖开始setTimeout(() => {        _this.setData({          start: false,          end: true        })      //其他代码部分      //time是接口请求开始到结束的时间}, Math.ceil(time / 1500) * 1500 - time)这里用了一个setTimeout，用于设置动画结束时间，优化一下动画，不让结束看起来太突兀。 1500是wxss里这是的动画时间。总结：简单的扭蛋机，有时间用canvas来做做。"}
{"title": "Taro+react自定义导航条/Tabbar菜单 ", "author": "Rolan", "pub_time": "2019-11-27 00:38", "content": "基于taro自定义导航栏Navbar|仿微信顶部导航|taro自定义tabbar这几天研究taro发现，官网提供的都是H5、小程序案例，至于RN案例甚少。恰好之前有过react及react-native项目经验，经过一番探究，终于实现能编译到多端，不过采坑不少，尤其是在RN环境下的样式问题。react仿微信web版聊天室： blog.csdn.net/yanxinyun19…如下图：在H5/小程序/RN效果均测试通过项目中用到的图标都是阿里iconfont字体图标，下载好后将fonts文件夹拷贝到项目目录下。import './styles/fonts/iconfont.scss' 在h5、小程序下 这种写法即可： <Text className=\"iconfont icon-back\"></Text>不过为了兼容RN，只能通过Unicode方式这样写： <Text className=\"iconfont\">&#xe84c;</Text>如果是通过变量传递： let back = '\\ue84c' <Text>{back}</Text>Taro自定义导航栏在App.js配置navigationStyle，将设置为custom，就可以自定义导航栏class App extends Component {\r\n    config = {\r\n        pages: \r\n            'pages/index/index',\r\n            ...\r\n        ],\r\n        window: {\r\n            backgroundTextStyle: 'light',\r\n            navigationBarBackgroundColor: '#fff',\r\n            navigationBarTitleText: 'Taro',\r\n            navigationBarTextStyle: 'black',\r\n            navigationStyle: 'custom'\r\n        },\r\n        ...\r\n    }\r\n    \r\n    ...\r\n}\r\n复制代码components目录下新建导航栏Navbar组件/*\r\n * @desc   Taro自定义导航条navbar组件\r\n * @about  Q：282310962  wx：xy190310\r\n */\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { View, Text, Input, Image } from '@tarojs/components'\r\nimport classNames from \"classnames\";\r\nimport './index.scss'\r\n \r\nexport default class NavBar extends Taro.Component {\r\n    // 默认配置\r\n    static defaultProps = {\r\n        isBack: false,\r\n        leftIcon: '\\ue84c',\r\n        title: ' ',\r\n        background: '#6190e8',\r\n        color: '#fff',\r\n        center: false,\r\n        search: false,\r\n        searchStyle: '',\r\n        fixed: false,\r\n        headerRight: [],\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            searchText: '',\r\n        }\r\n    }\r\n\t\r\n\t...\r\n \r\n    render() {\r\n        const { isBack, leftIcon, title, background, color, center, search, searchStyle, fixed, height, headerRight } = this.props\r\n        const { searchText } = this.state\r\n        \r\n        let weapp = false\r\n        if (process.env.TARO_ENV === 'weapp') {\r\n            weapp = true\r\n        }\r\n \r\n        return (\r\n            <View className={classNames('taro__navbar', fixed && 'taro__navbar--fixed', fixed && weapp && 'taro__navbar-weapp--fixed')}>\r\n                <View className={classNames('taro__navbar-wrap', fixed && 'taro__navbar-wrap--fixed', weapp && 'taro__navbar-wrap__weapp')} style={{backgroundColor: background}}>\r\n                    {/* 返回 */}\r\n                    <View className={classNames('taro__navbar-left__view', isBack && 'taro__navbar-left__view--isback')}>\r\n                    {isBack &&\r\n                        <TouchView activeOpacity={.5} onClick={this.handleNavigateBack}>\r\n                            <View className=\"taro__navbar-icon__item\"><Text className=\"iconfont taro__navbar-iconfont\" style={{color: color}}>{leftIcon}</Text></View>\r\n                        </TouchView>\r\n                    }\r\n                    </View>\r\n                    \r\n                    {/* 标题 */}\r\n                    {!search && center && !weapp ? <View className=\"flex1\" /> : null}\r\n                    {search ? \r\n                    (\r\n                        <View className=\"taro__navbar-search flex1\">\r\n                            <Input className=\"taro__navbar-search__input\" placeholder=\"搜索...\" onInput={this.updateInputText} style={{color: color, ...searchStyle}} />\r\n                        </View>\r\n                    )\r\n                    :\r\n                    (\r\n                        <View className={classNames('taro__navbar-title flex1', center && !weapp && 'taro__navbar-title--center')}>\r\n                            {title && <Text className=\"taro__navbar-title__text\" style={{color: color}}>{title}</Text>}\r\n                        </View>\r\n                    )\r\n                    }\r\n \r\n                    {/* 右侧 */}\r\n                    <View className=\"taro__navbar-right__view\">\r\n                    {headerRight.map((item, index) => (\r\n                        <TouchView activeOpacity={.5} key={index} onClick={()=>item.onClick && item.onClick(searchText)}>\r\n                            <View className=\"taro__navbar-icon__item\">\r\n                                {item.icon && <Text className=\"iconfont taro__navbar-iconfont\" style={{color: color, ...item.style}}>{item.icon}</Text>}\r\n                                {item.text && <Text className=\"taro__navbar-iconfont__text\" style={{color: color, ...item.style}}>{item.text}</Text>}\r\n                                {item.img && <Image className=\"taro__navbar-iconfont__img\" src={item.img} mode='aspectFit' />}\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__navbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__navbar-badge--dot\"></Text>}\r\n                            </View>\r\n                        </TouchView>\r\n                    ))\r\n                    }\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码在页面引入组件即可： import NavBar from '@components/navbar'支持自定义背景、颜色、左侧图标、标题居中、搜索框，右侧按钮支持图标/文字/图片，还可以设置样式，红点提示、事件处理<NavBar title='Taro标题栏' fixed\r\n    headerRight={[\r\n        {icon: '\\ue614', style: {color: '#e93b3d'}},\r\n        {img: require('../../assets/taro.png'), dot: true, onClick: this.handleCallback},\r\n        {icon: '\\ue600', style: {marginRight: 10}},\r\n    ]} \r\n/>复制代码<NavBar isBack leftIcon={'\\ue69f'} title='搜索栏' background='#42b983' color='#fcc' search\r\n    searchStyle={{\r\n        backgroundColor:'rgba(255,255,255,.6)', borderRadius: Taro.pxTransform(50), color: '#333'\r\n    }}\r\n    headerRight={[\r\n        {icon: '\\ue622', style: {color: '#6afff9'}},\r\n        {icon: '\\ue63a'},\r\n    ]} \r\n/>复制代码Taro自定义底部Tabbarimport Taro from '@tarojs/taro'\r\nimport { View, Text } from '@tarojs/components'\r\nimport classNames from 'classnames'\r\nimport './index.scss'\r\n \r\nexport default class TabBar extends Taro.Component {\r\n    // 默认参数配置\r\n    static defaultProps = {\r\n        current: 0,\r\n        background: '#fff',\r\n        color: '#999',\r\n        tintColor: '#6190e8',\r\n        fixed: false,\r\n        onClick: () => {},\r\n        tabList: []\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            updateCurrent: props.current\r\n        }\r\n    }\r\n    ...\r\n \r\n    render() {\r\n        const { background, color, tintColor, fixed } = this.props\r\n        const { updateCurrent } = this.state\r\n        \r\n        return (\r\n            <View className={classNames('taro__tabbar', fixed && 'taro__tabbar--fixed')}>\r\n                <View className={classNames('taro__tabbar-list', fixed && 'taro__tabbar-list--fixed')} style={{backgroundColor: background}}>\r\n                    {this.props.tabList.map((item, index) => (\r\n                        <View className=\"taro__tabbar-item taro__tabbar-item--active\" key={index} onClick={this.updateTabbar.bind(this, index)}>\r\n                            <View className=\"taro__tabbar-icon\">\r\n                                <Text className=\"iconfont taro__tabbar-iconfont\" style={{color: updateCurrent == index ? tintColor : color}}>{item.icon}</Text>\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__tabbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__tabbar-badge--dot\"></Text>}\r\n                            </View>\r\n                            <Text className=\"taro__tabbar-title\" style={{color: updateCurrent == index ? tintColor : color}}>{item.title}</Text>\r\n                        </View>\r\n                    ))}\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码自定义tabbar也支持自定义背景、颜色、图标，点击选项事件返回索引值<TabBar current={currentTabIndex} background='#f8f8f8' color='#999' tintColor='#6190e8' fixed onClick={this.handleTabbar}\r\n    tabList={[\r\n        {icon: '\\ue627', title: '首页', badge: 8},\r\n        {icon: '\\ue61e', title: '商品'},\r\n        {icon: '\\ue605', title: '个人中心', dot: true},\r\n    ]}\r\n/>\r\n复制代码好了，今天就介绍到这里，后续会考虑使用Taro技术开发个多端实战项目。ReactNative聊天APP实战|仿微信聊天/朋友圈/红包界面"}
{"title": "微信小程序推送消息简单Demo ", "author": "Rolan", "pub_time": "2019-11-27 00:45", "content": "在开始前，你需要准备：注册微信小程序一个简单的springBoot 项目微信开发者工具正式微信小程序发送消息主要通过WxMaTemplateMessage 类来推送public class WxMaTemplateMessage implements Serializable {\r\n    private String toUser;       // 给谁推送(用户openId)\r\n    private String templateId;  // 消息ID\r\n    private String page;    // 用户点开消息跳转到对应的小程序界面\r\n    private String formId;  // 表单formId\r\n    private List<WxMaTemplateData> data; // 消息的数据列表\r\n    private String emphasisKeyword;  \r\n...\r\n复制代码所以我们在推送前需要构造这些信息，formId 和toUser(openId) 是从前端传过来的。formId 可以通过表单或者支付来获取，表单比较简单，只需要把report-submit 设置为true 就可以获得。简单通过微信开发者工具来获取formId(openId 数据库存了)先建立一个前端项目，AppID 就是小程序的id，在微信公众号后台可以看到。修改index/index.js 和index.wxml (百度某位同学的)，通过表单来获取formId ，并发送到后台。// index.wxml\r\n<form bindsubmit='registerFormSubmit' report-submit='true'>\r\n  <view class='buttons'>\r\n    <button class='confirmbtn' form-type='submit'>确定</button>\r\n  </view>\r\n\r\n</form>\r\n<view>formid： {{formid}}</view>\r\n<button bindtap='push'>\r\n    发送\r\n</button>\r\n\r\n复制代码//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  \r\n  data: {\r\n    formid: \"\"\r\n  },\r\n  //事件处理函数\r\n  registerFormSubmit: function (e) {\r\n    //    打印formId\r\n    console.log(e.detail.formId);\r\n    this.setData({\r\n      formid: e.detail.formId\r\n    })\r\n   },\r\n  //测试推送\r\n push() {\r\n    let formid = this.data.formid;\r\n   let openid = 'oT-H-40ZHdRX1REZFKQhPg3jJZoQ';\r\n    wx.request({\r\n      url: 'http://localhost:8080/push?openId=' + openid + \"&formId=\" + formid,\r\n      success(res) {\r\n        console.log(\"推送结果：\", res)\r\n      },\r\n      fail(err) {\r\n        console.log(\"推送失败：\", err)\r\n      }\r\n    })\r\n  }\r\n})\r\n\r\n复制代码这里formid 在测试的时候获取不到，调到真机调试，或者用预览就行了。请求后台接口来发送消息（ctrl c v 百度某同学）import cn.binarywang.wx.miniapp.api.WxMaService;\r\nimport cn.binarywang.wx.miniapp.api.impl.WxMaServiceImpl;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateData;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateMessage;\r\nimport cn.binarywang.wx.miniapp.config.WxMaInMemoryConfig;\r\nimport me.chanjar.weixin.common.error.WxErrorException;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@RestController\r\npublic class PushController {\r\n\r\n    @GetMapping(\"/push\")\r\n    public String push(@RequestParam String openId, @RequestParam String formId) {\r\n        //1,配置小程序信息\r\n        WxMaInMemoryConfig wxConfig = new WxMaInMemoryConfig();\r\n        wxConfig.setAppid(\"你的appId\");\r\n        wxConfig.setSecret(\"你的secret\");\r\n\r\n        WxMaService wxMaService = new WxMaServiceImpl();\r\n        wxMaService.setWxMaConfig(wxConfig);\r\n\r\n        //2,设置模版信息（keyword1：类型，keyword2：内容）\r\n        List<WxMaTemplateData> templateDataList = new ArrayList<>(2);\r\n        WxMaTemplateData data1 = new WxMaTemplateData(\"keyword1\", \"获取老师微信\");\r\n        WxMaTemplateData data2 = new WxMaTemplateData(\"keyword2\", \"2501902696\");\r\n        WxMaTemplateData data3 = new WxMaTemplateData(\"keyword3\", \"2501902696\");\r\n        WxMaTemplateData data4 = new WxMaTemplateData(\"keyword4\", \"2501902696\");\r\n        templateDataList.add(data1);\r\n        templateDataList.add(data2);\r\n        templateDataList.add(data3);\r\n        templateDataList.add(data4);\r\n\r\n        //3，设置推送消息\r\n        WxMaTemplateMessage templateMessage = WxMaTemplateMessage.builder()\r\n                                                  .toUser(openId)\r\n                                                  .formId(formId)\r\n                                                  .templateId(\"你的消息id\") // 在微信公众号后台可以申请消息模版\r\n                                                  .data(templateDataList)\r\n                                                  .page(\"pages/index/index\")\r\n                                                  .build();\r\n\r\n        //4，发起推送\r\n        try {\r\n            wxMaService.getMsgService().sendTemplateMsg(templateMessage);\r\n        } catch (WxErrorException e) {\r\n            System.out.println(\"推送失败：\" + e.getMessage());\r\n            return e.getMessage();\r\n        }\r\n        return \"推送成功\";\r\n    }\r\n\r\n}\r\n复制代码"}
{"title": "记《高校考勤系统》小程序（1） ", "author": "Rolan", "pub_time": "2019-11-28 00:03", "content": "引言这是我自学小程序并上线的第一个算是完整的项目(其实是♀朋友的毕业设计需求 )，前端萌新一枚.其中肯定会有许多不合理或需要改进的地方请大家指出，谢谢！:sunglasses::sunglasses:(前期准备工作就不介绍啦，我们直接进入正题)一.功能需求整理，思路规划1.用户注册登录.2.教师及学生课程表信息关联、课程表信息查看.3.校园信息发布、签到任务发布、请假管理、用户管理.4.自己顺手加的天气，海报生成功能.拿到需求想了想除了注册登录，主要划分两大块，一为普通学生用户功能，二为管理员教师功能.因为要在一个小程序中全部展示，所以思考在用户注册时添加‘status’字段作为后续用户权限判断依据来展示相对应的页面及功能。(也不知道这样做对不对:cry:，头大)根据理解画了流程图二.项目整体布局搭建小程序主要划分为四块，所以首先我们在app.json中创建对应的tabbar.其中素材用到了阿里巴巴图标库 ( www.iconfont.cn )实现效果：三.用户注册登录在此前我们需要开通云开发并在数据库中创建存储用户信息的集合.引入Vant Weapp 和ColorUI组件库（组件丰富，上手方便，色彩搭配beautiful:+1:） youzan.github.io/vant-weapp/… www.color-ui.com/这里我新建了三张页面分别为启动动画过渡页、登录页、注册页.启动动画过渡页:点击查看js代码Page({\r\n    data: {\r\n            openid: '', //获取用户_openid\r\n            panduan: '', //判断用是否存在\r\n            arr: []\r\n    },\r\n    onLoad: function(options) {\r\n            wx.cloud.callFunction({ //获取用户openid\r\n            name: 'login',\r\n            data: {},\r\n        }).then(res => {\r\n            this.openid = res.result.openid\r\n        }).then(res => {\r\n            const db = wx.cloud.database({ \r\n                env: 'env-urae8'  //数据库环境名\r\n            })\r\n            db.collection('users').get().then(res => { //获取用户数据\r\n                this.arr = res.data\r\n                for (let i = 0; i < this.arr.length; i++) { //循环判断用户数据中是否存在用户\r\n                    if (this.openid == this.arr[i]._openid) {\r\n                        this.panduan = 'true'\r\n                    }\r\n                }\r\n            }).then(res => {\r\n                if (this.panduan == 'true') { //存在用户跳转登录页面\r\n                    wx.reLaunch({\r\n                        url: '/pages/index/index',\r\n                    })\r\n                } else if (this.data.panduan == '') {\r\n                    wx.redirectTo({\r\n                        url: '/pages/login/login' //不存在用户跳转登录页\r\n                    })\r\n                }\r\n            })\r\n            }).catch(err => {\r\n                wx.showToast({\r\n                    icon: 'none',\r\n                    title: '用户信息获取失败，请检查网络',\r\n                })\r\n            })\r\n    }\r\n})\r\n复制代码用户登录页:点击查看js代码Page({\r\n    data: {\r\n        userid:'',\r\n        haveuserid:'no',\r\n        openid: '',\r\n        errMsg:''\r\n    },\r\n    onGotUserInfo(e){\r\n        this.data.errMsg = e.detail.errMsg\r\n        if (e.detail.errMsg == 'getUserInfo:ok'){\r\n        this.setData({\r\n            userBtn: true,\r\n            trueBtn:false\r\n        })\r\n    }\r\n    },\r\n    useridInput(e){\r\n        this.userid = e.detail.value\r\n    },\r\n    loginBtn(){\r\n        this.data.haveuserid = 'no'  //清除判断是否存在用户名\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').get().then(res => {\r\n            for (let i = 0; i < res.data.length; i++) {\r\n                if (res.data[i].userid === this.userid && res.data[i]._openid == this.openid) {\r\n                    this.data.haveuserid = 'yes'\r\n                }\r\n            }\r\n            var pattern = /^\\d{6,12}$/\r\n            if(this.userid == '000001'){\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }else if (pattern.test(this.userid) && this.data.haveuserid == 'yes' && this.data.errMsg == 'getUserInfo:ok'){\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }else if (this.data.errMsg == 'getUserInfo:fail auth deny' || this.data.errMsg == '') {\r\n                wx.showToast({\r\n                    title: '请授权后再登录',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n            }else if (!pattern.test(this.userid)) {  //判断是否符合用户名\r\n                wx.showToast({\r\n                    title: '请输入6-12位数字',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n            }else if (this.data.haveuserid == 'no') {\r\n                wx.showToast({\r\n                    title: '学号或工号错误或不存在,请重新输入或注册',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n            } \r\n        })\r\n    },\r\n    registerBtn(){\r\n        wx.redirectTo({\r\n            url: '/pages/register/register'\r\n        })\r\n    },\r\n    onLoad: function (options) {\r\n        this.setData({\r\n            trueBtn:true  //用户授权框样式\r\n        })\r\n        wx.cloud.callFunction({ //获取用户openid\r\n            name: 'login',\r\n            data: {},\r\n            success: res => {\r\n                this.openid = res.result.openid\r\n            },\r\n            fail: err => {\r\n                wx.showToast({\r\n                    icon: 'none',\r\n                    title: '用户信息获取失败，请检查网络',\r\n                })\r\n            }\r\n        })\r\n    }\r\n})\r\n复制代码<view class=\"title\">登录</view>\r\n<view>\r\n    <view class=\"input\">\r\n        <image src=\"../../images/userimg.png\"></image>\r\n        <input class=\"inputBtn\" bindinput=\"useridInput\" placeholder=\"请输入学号或工号\"></input>\r\n    </view>\r\n    <view class=\"userBtn\">\r\n        <button hidden=\"{{ userBtn }}\" open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"\r\n            class=\"onGotUserInfo\"></button>\r\n        <image hidden=\"{{ trueBtn }}\" class=\"true\" src=\"../../images/true.png\"></image>\r\n        <text class=\"userTit\">用户授权</text>\r\n    </view>\r\n    <button class=\"loginBtn shadow bg-blue\" bindtap=\"loginBtn\">登 录</button>\r\n    <button class=\"registerBtn shadow bg-blue\" bindtap=\"registerBtn\">注 册</button>\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    position: relative;\r\n    background-color: white;\r\n}\r\n.title {\r\n    margin-top: 200rpx;\r\n    text-align: center;\r\n    font-size: 40rpx;\r\n}\r\n.input{\r\n    width: 60%;\r\n    margin: 0 auto;\r\n    margin-top: 120rpx;\r\n    padding: 20rpx;\r\n    border-radius: 10rpx;\r\n    background-color: #f6f6f6;\r\n    display: flex;\r\n    justify-content: start;\r\n}\r\n.input image{\r\n    width: 30rpx;\r\n    height: 30rpx;\r\n    margin-top: 6rpx;\r\n    display: block;\r\n}\r\n.inputBtn {\r\n    width: 100%;\r\n    height: 40rpx;\r\n    margin-left: 20rpx;\r\n}\r\n.loginBtn, .registerBtn {\r\n    width: 400rpx;\r\n    margin: 0 auto;\r\n    background-color: #07c160;\r\n    color: white;\r\n    font-weight: 600;\r\n}\r\n.loginBtn {\r\n    margin-bottom: 60rpx;\r\n    margin-top: 60rpx;\r\n}\r\n.userBtn {\r\n    margin-top: 160rpx;\r\n    margin-left: 190rpx;\r\n    display: flex;\r\n    justify-content: flex-start;\r\n}\r\n.onGotUserInfo {\r\n    width: 44rpx;\r\n    height: 44rpx;\r\n    border-radius: 20rpx;\r\n    padding: 0;\r\n    margin: 0;\r\n    border: 6rpx solid #07c160;\r\n}\r\n.true{\r\n    width: 44rpx;\r\n    height: 44rpx;\r\n}\r\n.userTit{\r\n    margin-left: 12rpx;\r\n}\r\n复制代码用户注册页:点击查看js代码const app = getApp()\r\nwx.cloud.init();\r\nPage({\r\n    data: {\r\n        steps: [{\r\n                text: '第一步',\r\n                desc: '授权登录'\r\n            },\r\n            {\r\n                text: '第二步',\r\n                desc: '输入信息'\r\n            },\r\n            {\r\n                text: '第三步',\r\n                desc: '完成注册'\r\n            }\r\n        ],\r\n        active: 0,\r\n        nextOne: true, //第一个下一步\r\n        hiddenName: false, //授权登录\r\n        userid: '', // 用户学号或者工号\r\n        nickName: '', //用户名\r\n        avatarUrl: '', //用户头像\r\n        userStatus: '0', //用户注册状态\r\n        step: 1,\r\n        openid: '',\r\n        haveuserid:'no'//判断是否存在用户名\r\n    },\r\n    nextOne() {\r\n        this.setData({\r\n            active: 1, //状态为步骤2\r\n            firstBoxHide: true, //隐藏步骤1框\r\n            secondBoxHide: false //显示步骤2框\r\n        })\r\n    },\r\n    onGotUserInfo(e) {\r\n        this.setData({\r\n            nickName: e.detail.userInfo.nickName, //获取用户名\r\n            avatarUrl: e.detail.userInfo.avatarUrl, //获取头像\r\n            nextOne: false, //下一步按钮显示\r\n            hiddenName: true, //授权按钮隐藏\r\n            firstHide: false //显示用户信息\r\n        })\r\n        this.nickName = e.detail.userInfo.nickName\r\n        this.avatarUrl = e.detail.userInfo.avatarUrl\r\n    },\r\n    useridInput(e) {\r\n        this.userid = e.detail.value\r\n    },\r\n    secondBtn() {\r\n        this.data.haveuserid = 'no'  //清除判断是否存在用户名\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').get().then(res => {\r\n            for(var i = 0;i < res.data.length ; i++){\r\n                if (res.data[i].userid === this.userid || res.data[i]._openid == this.openid){\r\n                    this.data.haveuserid = 'yes'\r\n                }\r\n            }   \r\n            var pattern = /^\\d{6,12}$/\r\n            if (!pattern.test(this.userid)) {  //判断是否符合用户名\r\n                wx.showToast({\r\n                    title: '请输入6-12位数字',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n            } else if (this.data.haveuserid == 'yes') {  //判断数据库是否存在用户名\r\n                wx.showToast({\r\n                    title: '用户已存在,请直接登录',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n                this.setData({\r\n                    backBtn: false, //显示返回登录按钮\r\n                })\r\n            } else {\r\n                this.setData({\r\n                    secondBtn: true, //隐藏确定按钮\r\n                    nextTwo: false //显示second框下一步按钮\r\n                })\r\n            }\r\n        })\r\n    },\r\n    backBtn(){ //返回登录页面\r\n        wx.redirectTo({\r\n            url: '/pages/login/login'\r\n        })\r\n    },\r\n    nextTwo() {\r\n        this.setData({\r\n            userid: this.userid,\r\n            nickName: this.nickName,\r\n            avatarUrl: this.avatarUrl,\r\n            secondBoxHide: true, //隐藏second框\r\n            thirdBoxHide: false, //显示third框\r\n            nextTwo: true, //隐藏下一步2按钮\r\n            active: 3, //初始状态为步骤3\r\n        })\r\n    },\r\n    thirdBtn() { //完成注册按钮\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').add({\r\n            data: {\r\n                userid: this.userid,\r\n                nickName: this.nickName,\r\n                userStatus: this.data.userStatus\r\n            },\r\n            success: res => {\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }\r\n        })\r\n    },\r\n    onLoad: function(options) {\r\n        this.setData({\r\n            active: 0, //初始状态为步骤1\r\n            nextOne: true, //隐藏下一步按钮\r\n            firstHide: true, //隐藏用户框信息\r\n            firstBoxHide: false, //\r\n            secondBoxHide: true, //隐藏步骤2框\r\n            nextTwo: true, //隐藏second框下一步按钮\r\n            thirdBoxHide: true, //显示third框\r\n            backBtn:true,  //隐藏返回登录按钮\r\n        })\r\n        //获取用户openid\r\n        if (this.data.step === 1 && !this.data.openid) {\r\n            wx.cloud.callFunction({\r\n                name: 'login',\r\n                data: {},\r\n                success: res => {\r\n                    app.globalData.openid = res.result.openid\r\n                    this.step = 2,\r\n                    this.openid = res.result.openid\r\n                },\r\n                fail: err => {\r\n                    wx.showToast({\r\n                        icon: 'none',\r\n                        title: '用户信息获取失败，请检查网络',\r\n                    })\r\n                }\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码<view class=\"cont\">\r\n    <view class=\"title\">注册</view>\r\n    <view class=\"cont_box\">\r\n        <van-steps class=\"van-steps\" steps=\"{{ steps }}\" active=\"{{ active }}\" active-color=\"#07c160\"\r\n            inactive-icon=\"../../images/true.png\" />\r\n    </view>\r\n    <view class=\"first\" hidden=\"{{ firstBoxHide }}\">\r\n        <view class=\"user_box\" hidden=\"{{ firstHide }}\">\r\n        <image class=\"avatarUrl\" src=\"{{ avatarUrl }}\"></image>\r\n    </view>\r\n    <view class=\"nickName\" hidden=\"{{ firstHide }}\">{{ nickName }}</view>\r\n        <button hidden=\"{{hiddenName}}\" open-type=\"getUserInfo\" lang=\"zh_CN\"\r\n            bindgetuserinfo=\"onGotUserInfo\" class=\"loginBtn shadow bg-blue\">微信授权</button>\r\n        <button class=\"nextOne shadow bg-blue\" bindtap=\"nextOne\" hidden=\"{{ nextOne }}\">下一步</button>\r\n    </view>\r\n    <view class=\"second\" hidden=\"{{ secondBoxHide }}\">\r\n        <input class=\"useridInput\" bindinput=\"useridInput\" placeholder=\"请输入学号或工号\"></input>\r\n        <button class=\"secondBtn shadow bg-blue\" bindtap=\"secondBtn\" hidden=\"{{ secondBtn }}\">确定</button>\r\n        <button class=\"nextTwo shadow bg-blue\" bindtap=\"nextTwo\" hidden=\"{{ nextTwo }}\">下一步</button>\r\n        <button class=\"backBtn shadow bg-blue\" bindtap=\"backBtn\" hidden=\"{{ backBtn }}\">返回登录</button>\r\n    </view>\r\n    <view class=\"third\" hidden=\"{{ thirdBoxHide }}\">\r\n        <view class=\"user_box\" >\r\n            <image class=\"avatarUrl\" src=\"{{ avatarUrl }}\"></image>\r\n        </view>\r\n        <view class=\"nickName\">微信名：{{ nickName }}</view>\r\n        <view class=\"userid\">学号：{{ userid }}</view>\r\n        <button class=\"thirdBtn shadow bg-blue\" bindtap=\"thirdBtn\">完成注册</button>\r\n    </view>\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n    background-color: white;\r\n}\r\n.register_bg {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n.cont {\r\n    width: 100%;\r\n    margin-top: 200rpx;\r\n    color: black;\r\n    z-index: 1;\r\n    display: flex;\r\n    justify-content: start;\r\n    flex-direction: column;\r\n}\r\n.cont .title {\r\n    font-size: 46rpx;\r\n    text-align: center;\r\n    margin-bottom: 60rpx;\r\n}\r\n.van-steps {\r\n    width: 82%;\r\n    margin: 0 auto;\r\n}\r\n.first, .second, .third {\r\n    width: 100%;\r\n    height: 500rpx;\r\n    position: relative;\r\n    text-align: center;\r\n}\r\n.first .user_box, .third .user_box {\r\n    width: 160rpx;\r\n    height: 160rpx;\r\n    border-radius: 80rpx;\r\n    margin: 0 auto;\r\n    margin-top: 50rpx;\r\n    position: relative;\r\n    overflow: hidden;\r\n    box-shadow:0 2rpx 4rpx rgba(0, 0, 0, .3);\r\n}\r\n.nickName{\r\n    height: 40rpx;\r\n    line-height: 40rpx;\r\n    margin-top: 26rpx;\r\n    font-size: 30rpx;\r\n}\r\n.first .avatarUrl, .third .avatarUrl {\r\n    width: 160rpx;\r\n    height: 160rpx;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n.first .success {\r\n    margin-top: 20rpx;\r\n}\r\n.loginBtn, .nextOne, .nextTwo, .backBtn,.secondBtn,.thirdBtn {\r\n    width: 240rpx;\r\n    height: 80rpx;\r\n    background-color: #07c160;\r\n    color: white;\r\n    line-height: 80rpx;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    font-weight: 600;\r\n    border: none;\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: calc(50% - 120rpx);\r\n}\r\n.secondBtn{\r\n    bottom: 260rpx;\r\n}\r\n.backBtn {\r\n    bottom: 130rpx;\r\n}\r\n/* 清除button样式 */\r\nbutton {\r\n    font-size: 28rpx;\r\n    background-color: transparent;\r\n    border: none;\r\n    padding: 0;\r\n    margin: 0;\r\n    line-height: 1;\r\n}\r\nbutton::after {\r\n    border: none;\r\n    background-color: transparent;\r\n}\r\n.button-hover {\r\n    color: rgba(0, 0, 0, 0.8);\r\n    background-color: transparent;\r\n}\r\n.second .useridInput {\r\n    width: 60%;\r\n    height: 40rpx;\r\n    padding: 20rpx;\r\n    border-radius: 12rpx;\r\n    margin: 50rpx auto;\r\n    text-align: left;\r\n    background-color: #f6f6f6;\r\n}\r\n.third .userid {\r\n    margin-top: 30rpx;\r\n}\r\n复制代码三.首页页面搭建天气数据来自阿凡达数据，也是比较了许多接口，这个相对返回数据比较可观且收费也在承受范围之内 www.avatardata.cn/ .UI样式参考了许多其他小程序（墨迹天气、小天气等）; 天气小模块参考 juejin.im/post/5d2f3f… ; 腾讯地图api lbs.qq.com/qqmap_wx_js… ; 感谢他们给予的帮助及参考:+1::+1::+1:先来看看完成后的效果图1.获取当前定位城市信息.前期需要注册腾讯地图并认证，获取key，在项目中引入微信小程序JavaScript SDK，具体步骤可以参考腾讯地图api:point_up_2:（链接见上）getUserLocation() {\r\n    var qqmapsdk;\r\n    var _this = this;\r\n    wx.getSetting({ //判断是否授权\r\n    success(res) {\r\n    wx.getLocation({\r\n      type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n      success(res) {\r\n        // console.log('已授权')\r\n        qqmapsdk = new QQMapWX({\r\n          key: \"****\", //自己申请的key\r\n        })\r\n        qqmapsdk.reverseGeocoder({\r\n          location: {\r\n            latitude: res.latitude,\r\n            longitude: res.longitude\r\n          },\r\n          success(addressRes) {\r\n            // console.log(addressRes) //这里就可以获取到当前经纬度所在城市的详细信息\r\n            _this.city = addressRes.result.ad_info.city; //获取当前所在城市\r\n            })\r\n          },\r\n          fail(res) {\r\n            console.log(res)\r\n          }\r\n        })\r\n      },\r\n      fail(res) {\r\n        // console.log('未授权')\r\n      }\r\n    })\r\n  }\r\n})\r\n},\r\n复制代码2.根据定位获取到的城市信息，调用天气接口获取当前城市天气数据.wx.request({\r\n    url: 'https://api.avatardata.cn/Weather/Query?key=你注册后的key值&cityname=' + 定位获取到的城市名,\r\n    header: {\r\n        'content-type': 'application/json' // 默认值\r\n    },\r\n    success(res) {\r\n        //返回城市天气数据\r\n    }\r\n})\r\n复制代码3.根据当前天气状况判断天气模块的显示隐藏. 例如：if (res.data.result.weather[i].info.day[1].indexOf('晴') >= 0) { //判断条件为接口返回数据\r\n        //晴天天气模块显示其他隐藏\r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('阴') >= 0 || \r\n    res.data.result.weather[i].info.day[1].indexOf('云') >= 0) {\r\n        //多云或阴天天气模块显示其他隐藏\r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('小雨') >= 0) {\r\n        //小雨气模块显示其他隐藏 \r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('大雨') >= 0) {\r\n        //大雨气模块显示其他隐藏           \r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('雪') >= 0) {\r\n        //下雪天气模块显示其他隐藏            \r\n    }\r\n复制代码4.因为返回的接口数据有些是自己不想要的，或者想自己添加一些新的图片文字，所以将数据重新编写成对象数组的形式，最后渲染出来就可以了.例如下面这个模块let weather = []\r\nweather.push({\r\n    date: date,\r\n    week: res.data.result.weather[i].week, //星期\r\n    daywea: res.data.result.weather[i].info.day[1], //白天天气\r\n    daytemp: res.data.result.weather[i].info.day[2], //白天温度\r\n    daywind: daywind, //风向\r\n    daywindli: res.data.result.weather[i].info.day[4], //风力\r\n    nightwea: res.data.result.weather[i].info.night[1], //晚上天气\r\n    nighttemp: res.data.result.weather[i].info.night[2], //晚上温度\r\n})\r\nconsloe.log(weather)//打印结果\r\n//(5) [{…}, {…}, {…}, {…}, {…}]\r\n//0: {date: \"11-27\", week: \"三\", daywea: \"小雨\", daytemp: \"10\", daywind: \"西风\",\r\n        daywindli: \"4-5级\"，nighttemp: \"8\"，nightwea: \"小雨\"，week: \"三\"}\r\n//1: {date: \"11-28\", week: \"四\", daywea: \"多云\", daytemp: \"10\", daywind: \"西风\", …}\r\n//2: {date: \"11-29\", week: \"五\", daywea: \"阴\", daytemp: \"11\", daywind: \"东北风\", …}\r\n//3: {date: \"11-30\", week: \"六\", daywea: \"小雨\", daytemp: \"13\", daywind: \"无风\", …}\r\n//4: {date: \"12-01\", week: \"日\", daywea: \"阴\", daytemp: \"11\", daywind: \"西风\", …}\r\n复制代码先写到这里，如果有什么写的不好的地方，请大家多多包涵，之后会继续分享后面的内容。大家也可以提前扫码查看小程序，欢迎指出不足，谢谢"}
{"title": "小程序包大小优化(uni-app) ", "author": "Rolan", "pub_time": "2019-11-28 00:24", "content": "在开发微信小程序的过程中，随着业务逻辑日渐庞大之后，突显了一些问题。首先我们发现在 dev mode 时，本地包大小已经达到了 4m+，这种情况下，已经无法在 dev mode 使用真机调试了。其次此时，小程序 build 后也有 1.8M 左右。而且后续还有相当多的业务需求需要开发，包大小肯定会更大。这时候就想要优化小程序包大小。下面分享一下我的定位过程和解决思路。尽管我们使用 uni-app 开发，但思路是通用的，希望能给大家一些帮助吧。如何减小包大小代码分析首先分析包大在哪儿了。打开本地代码目录查看文件大小。可以发现 common/vendor.js 和 page,components 中 js 占了大部分。在 build 编译模式下，代码压缩已经启用了，需要思考别的优化方式。这时候可以使用\twebpack-bundle-analyzer 插件\t。它可以帮助分析 vendor.js 中都有哪些 js 模块，哪些模块比较大，以便我们进一步优化代码通过这个插件，发现了下面两个问题。问题一: uni-app 自定义组件模式编译 tree shaking 无效如果不是使用 uni-app 开发可以跳过这一段通过代码分析发现有些模块应该被 tree shaking 但却被打包进来了。基本确定是 tree shaking 没有生效。同样是 webpack4 + babel7。在不使用 uni-app，直接使用 vue-cli create 项目的前提下，tree shaking 是没有问题的。而使用 uni-app 去新建项目，tree shaking 却无效。排查 babel 配置时发现是由于 uni-app 在创建项目的时候，设置了 modules: 'commonjs'导致。修改后，demo 的 tree shaking ok。但是回到项目里一编译，又出错了。继续定位发现是\tuni-app 自定义组件模式编译问题 。目前uni-app\t已经修复 了我提的bug，虽然还未正式发布。当然你不使用 uni-app 自定义组件模式编译也可以解决，uni-app 还支持\ttemplate模板模式 ，但是会有一些开发差异和性能差距，有兴趣可以看下\t这篇文章问题二：部分库不支持 tree shaking有些库(比如 lodash)本身并没有使用 import/export，所以 webpack 并不能对它们 tree shaking。这些库我们可以分情况优化。首先可以找下网上是否有库对应的 esm 版本可以替代，如 lodash-es。其次可以从代码分析中看出，如果库的每个模块都在不同文件中，入口文件只是一个统一入口，那么我们就可以通过修改写法按需加载，如import add from \"lodash/add\";\r\nimport Button from 'ant-design-vue/lib/button';\r\n复制代码我们也可以使用\tbabel-plugin-import 插件针对那些库统一实现按需加载，它的本质是在编译时统一按配置修改加载路径，不需要自己手动去修改代码。最后如果都不行，那要么接受，要么自己重写为社区做贡献~规范模块开发为了免除无法 tree shaking 的烦恼，我们在开发 npm 模块的时候也需要遵循一定的规范，从而减少模块打包后的大小。同时支持 commonjs 和 es module我们的模块需要同时支持 commonjs 和 es module。这样才能既满足 commonjs 开发的用户，又支持 tree shaking。如何实现呢？如果你的代码是 typescript,以@sentry/browser 为例，可以在编译时编译 cjs 和 esm 两种规范代码，如下// package.json\r\n\"build\": \"run-s build:dist build:esm build:bundle\",\r\n\"build:bundle\": \"rollup --config\",\r\n\"build:dist\": \"tsc -p tsconfig.build.json\",\r\n\"build:esm\": \"tsc -p tsconfig.esm.json\",\r\n复制代码然后在 package.json 中指定两个入口以及无副作用标识\"main\": \"dist/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"sideEffects\": false,\r\n复制代码这样当 webpack 解析模块(\t解析规则 )，就会按需优先解析 esm 目录。并且当识别到无副作用时进行 tree shaking。如果你的代码本身就是 es6，你也可以这样\"module\": \"src/index.js\",\r\n复制代码第三方自定义组件如果使用了第三方\t微信自定义组件 ，由于引用是在 json 文件，所以 webpack 在编译时并不能通过 entry 分析到相关文件，因此不会对其进行编译、压缩等。这时候就需要我们自己处理。而且由于 webpack 不处理，tree shaking 自然也无法支持，因此建议\t尽量避免 这种方式引用组件。分包小程序分包 也是一种常规的优化方案。通过分析后，可以将一些较大的页面划分为子包。如果有单页依赖第三方自定义组件，而且第三方组件还挺大，也可以考虑将该页面划分为子包。也因此\t尽量避免将第三方自定义组件放在 globalStyle ，不然没法将它放到子包去。大图不要打包小程序中的大图，尽量避免打包进来，应该放到 CDN 通过 url 加载。我们的做法是在开发时加载本地图片，在 CI/CD 环节自动化发布图片，并改写地址。如何解决真机调试问题首先还是查看编译后的文件，发现\tcommon/vendor.js 巨大，足有 1.5M。其次\tpages 和\tcomponents 也有 1.4M，而这其中占了 js 的大小又占了绝大部分。为什么 js 文件这么大呢？主要是因为在 dev mode 默认并没有压缩，当然也没有 tree shaking。我的选择是\t修改编译配置，在 dev mode 压缩 js 代码 。本地代码减少到了 2M。预览大小则是减少到了 1.4M。参考配置如下：// vue.config.js\r\n    configureWebpack: () => {\r\n        if (isDev && isMp) {\r\n            return {\r\n                optimization: {\r\n                    minimize: true,\r\n                },\r\n            }\r\n        }\r\n    }\r\n复制代码这看上去并不是个好方案，但确实简单有效。也考虑过分包，但分包并不能解决 common/vendor.js 巨大的问题，预览时包还是很大。如果有其它好的办法也欢迎留言~"}
{"title": "记《高校考勤系统》小程序（2） ", "author": "Rolan", "pub_time": "2019-11-29 00:12", "content": "这是其他几篇的地址：记《高校考勤系统》小程序（1）前面讲了用户注册和首页天气功能，下面讲讲课程表页的实现.五.课程表页这里参考了简书上面 轩辕夜空 位作者的案例,以及其参考 极乐叔 的课程表的思路.同样制作课程表需要用到云开发来存储数据，以及结合云函数对数据的修改，后面会讲到为什么要用到云函数.先来看看完成后的效果图1.先搭建整体结构头部和左侧因为样式是一样的，可以将数据写入data中，再通过for循环渲染出来，这里就直接展示了.（偷个懒:blush::blush:）<!-- 星期 -->\r\n<view class=\"top\">  \r\n    <view class=\"top-text\">\r\n        <text>节\\日</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>一</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>二</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>三</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>四</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>五</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>六</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>日</text>\r\n    </view>\r\n</view>\r\n<!-- 课程 -->\r\n<view class=\"cont\">\r\n    <view class=\"cont-left\">\r\n        <view class=\"left\"> 1 </view>\r\n        <view class=\"left\"> 2 </view>\r\n        <view class=\"left\"> 3 </view>\r\n        <view class=\"left\"> 4 </view>\r\n        <view class=\"left\"> 5 </view>\r\n        <view class=\"left\"> 6 </view>\r\n        <view class=\"left\"> 7 </view>\r\n        <view class=\"left\"> 8 </view>\r\n    </view>\r\n    <view class=\"cont-right\">\r\n    </view>\r\n</view>\r\n<view class=\"bottom\">\r\n    ————<text>读万卷书 行万里路</text>————\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n.top {\r\n    padding: 16rpx 0;\r\n    border-top: 1px solid #e9e9e9;\r\n    border-bottom: 1px dashed #d3d3d3;\r\n    display: flex;\r\n    justify-content: flex-start;\r\n}\r\n.top-text {\r\n    width: 12.5%;\r\n    text-align: center;\r\n    font-size: 32rpx;\r\n    font-weight: 600;\r\n    align-items: center;\r\n}\r\n.top .top-text {\r\n    border-left: 1px dashed #d3d3d3;\r\n}\r\n.top .top-text:nth-child(1) {\r\n    font-size: 24rpx;\r\n    border-left: none;\r\n    line-height: 46rpx;\r\n}\r\n.cont {\r\n    display: flex;\r\n    justify-content: start;\r\n}\r\n.cont-left {\r\n    display: inline-block;\r\n}\r\n.left {\r\n    width: 90rpx;\r\n    height: 120rpx;\r\n    justify-content: center;\r\n    display: flex;\r\n    align-items: center;\r\n    border-bottom: 1px dashed #d3d3d3;\r\n    box-sizing: border-box;\r\n    color: #666;\r\n    font-size: 28rpx;\r\n    font-weight: 600;\r\n}\r\n.cont-right {\r\n    width: calc(100% - 90rpx);\r\n}\r\n.bottom {\r\n    width: 100%;\r\n    text-align: center;\r\n    position: absolute;\r\n    bottom: 20rpx;\r\n    font-size: 24rpx;\r\n    color: #ddd;\r\n    display: inline-block;\r\n}\r\n.bottom text {\r\n    margin-left: 20rpx;\r\n    margin-right: 20rpx;\r\n    color: #9b9b9b;\r\n}\r\n复制代码2.结合云开发编写课程表.这里需要考虑到云开发中单次获取数据上限是20条，所以我将课程表数据分为两部分（上午和下午），当然你可以直接使用云函数来提高获取数据的上限，在后面会有介绍，这里就先不做过多的解释了，上代码.单个数据结构{\r\n    //\"_id\": \"296065c95da529b2055b57301b5afa75\",  云开发导入数据会直接生成_id,这里不用自己编写\r\n    \"data_name\": \"Java高级开发技术(JavaEE)\",  //课程名\r\n    \"address\": \"@康庄行知楼301\",              //地点\r\n    \"weekNum\": \"10-15周\",                     //周数\r\n    \"pitchNum\": \"3-4\",                        //节数\r\n    \"teacher\": \"赵老师\",                      //任课老师\r\n    \"_openid\": \"oQnNa5NJfKqSZntKFLGZWnZuXNbo\"  //修改者的openid,本来是想做判断，后面使用了云函数，发现可有可无\r\n}\r\n复制代码下面是从云开发数据库中获取我们编写好的课程表数据,如果对操作不熟悉可以查看 官方文档. 1.打开云开发控制台. 2.创建两个集合对应上午下午课程表. 3.导入我们已经编写好的数据 (一个星期早上和下午的课程分别为14节，所以导入数据时需要注意，如果想要当前课程没有信息，也是需要导入空的字段数据来占一格) . 4.打开权限管理. 5.选中第一个.其中最后两个步骤一定不能忘记！点击查看js代码data: {\r\n    colorArr: [\"rgb(229,188,76, 0.8)\", \"rgb(104,172,246, 0.8)\", \"rgb(183,135,242, 0.8)\", \"rgb(149,226,48, 0.8)\", \"#ff7070\",\r\n        \"#e54d42\", \"#0081ff\", \"#7DC67D\", \"#E17572\", \"#C35CFF\", \"#33BCBA\", \"#FF8533\", \"#6E6E6E\", \"#ebd4ef\",\r\n        \"#428BCA\", \"#39b54a\", \"#FF674F\", \"#e03997\", \"#00CED1\", \"#9F79EE\", \"#FFC125\", \"#32CD32\", \"#00BFFF\", \"#8799a3\",\"#FF69B4\"\r\n    ],\r\n    // 存储随机颜色\r\n    randomColorArr: [],\r\n    randomColorArr2: [],\r\n    i: 25,\r\n    random: '',\r\n    random2: '',\r\n},\r\nonLoad: function(options) {\r\n    this.data.randomColorArr = [] // 重置颜色数组1为空\r\n    this.data.randomColorArr2 = [] // 重置颜色数组2为空\r\n    const db = wx.cloud.database({\r\n        env: '*****'  //你的云开发环境名\r\n    })\r\n\r\n    //获取课程表上午数据\r\n    db.collection('数据集合中你的表名').get().then((res) => {\r\n        this.kechengbiao = res.data\r\n        for (let j = 0; j <= 13; j++) { //for循环判断课名和地名为空则不加颜色\r\n            if (this.kechengbiao[j].data_name == '' && this.kechengbiao[j].address == '') {\r\n                this.random = 'none'\r\n                this.data.randomColorArr.push(this.random)\r\n            } else {\r\n                this.random = this.data.colorArr[Math.floor(Math.random() * this.data.i)] //随机颜色\r\n                this.data.randomColorArr.push(this.random)\r\n            }\r\n        }\r\n        this.setData({\r\n            loding: true,\r\n            kechengbiao: this.kechengbiao,\r\n            randomColorArr: this.data.randomColorArr\r\n        })\r\n    })\r\n    //获取课程表下午\r\n    db.collection('数据集合中你的表名').get().then((res) => {\r\n        this.kechengbiao2 = res.data\r\n        for (let j = 0; j <= 13; j++) { //for循环判断课名和地名为空则不加颜色\r\n            if (this.kechengbiao2[j].data_name == '' && this.kechengbiao2[j].address == '') {\r\n                this.random2 = 'none'\r\n                this.data.randomColorArr2.push(this.random2)\r\n            } else {\r\n                this.random2 = this.data.colorArr[Math.floor(Math.random() * this.data.i)] //随机颜色\r\n                this.data.randomColorArr2.push(this.random2)\r\n            }\r\n        }\r\n        this.setData({\r\n            kechengbiao2: this.kechengbiao2,\r\n            randomColorArr2: this.data.randomColorArr2\r\n        })\r\n    })\r\n},\r\n复制代码<view class=\"cont-right\">\r\n    <view>\r\n        <view class='appointent-date'>  //上午\r\n            <view class=\"appointent-date-div\" bindtap=\"select_date\" wx:for=\"{{kechengbiao}}\" wx:key=\"{{index}}\" data-key='{{index}}' style=\"background-color:{{randomColorArr[index]}}\">\r\n                <view class=\"flex-item\" >\r\n                    <text class='data_name'>{{item.data_name}}</text>\r\n                    <text class='address'>{{item.address}}</text>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class='appointent-date'>  //下午\r\n            <view class=\"appointent-date-div\" bindtap=\"select_date2\" wx:for=\"{{kechengbiao2}}\" wx:key=\"{{index}}\" data-key='{{index}}' style=\"background-color:{{randomColorArr2[index]}}\">\r\n                <view class=\"flex-item\">\r\n                    <text class='data_name'>{{item.data_name}}</text>\r\n                    <text class='address'>{{item.address}}</text>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码点击查看wxss代码.appointent-date {\r\n    display: flex;\r\n    justify-content: space-around;\r\n    flex-wrap: wrap;\r\n}\r\n.appointent-date-div {\r\n    height: 236rpx;\r\n    border-radius: 10rpx;\r\n    margin-bottom: 6rpx;\r\n    color: white;\r\n}\r\n.flex-item {\r\n    display: flex;\r\n    justify-content: flex-start;\r\n    flex-direction: column;\r\n    width: 76rpx;\r\n    height: 212rpx;\r\n    font-size: 24rpx;\r\n    padding: 6rpx;\r\n    border: 1rpx solid transparent;\r\n    text-align: left;\r\n    border-radius: 10rpx;\r\n    cursor: pointer;\r\n    overflow: hidden;\r\n}\r\n.data_name {\r\n    display: inline-block;\r\n}\r\n.address {\r\n    display: inline-block;\r\n}\r\n复制代码3.对课程实现增删改查首先来做最简单的 查 吧，我们需要在for循环中加入 data-='{{index}}' ，如上代码所示:point_up_2:我加了data-key='{{index}}'，其中key可以自定义，目的是为了在点击课程时，可以获取相循环中对应的下标，这样我就可以在数据库中搜索到当前点击的数据并渲染出来.查//点击课程内容弹出详细框\r\nselect_date: function(e) {\r\n  this.id = e.currentTarget.dataset.key //获取当前点击课程的下标\r\n  const db = wx.cloud.database({\r\n    env: '****'\r\n  })\r\n  db.collection('***').get().then(res => {\r\n    console.log(res.data[this.id])   //获取点击时课程表数据\r\n  })\r\n},\r\n复制代码获取到数据后我们可以根据自己的需求渲染在页面上，这里我结合了vant的tab组件，左上角为返回，右上角为删除课程表信息，下面就讲 删 除课程信息.这里的删除不是说真的将数据从我们的数据库中删除，而是将数据赋值为“”也就是空值，这样就做到了删除的功能，在此结合 云函数 来实现，因为云开发中的操作权限无法满足我们对数据操作的要求.删首先我们在云函数中创建一个新的 云函数 ，修改index.js文件这里会有一个问题也就是为什么我们要使用云函数，而不直接用云开发对数据进行处理，是因为云开发中的操作权限只能对自己提交到数据库中的数据进行修改，如果是别人那么就无法修改.正常情况下，管理员肯定不止一位，所以对数据操作不能只限定一个人.//修改课程表\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n    env: '***',//你的开发环境\r\n    traceUser: true\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => { // 云函数入口函数\r\n    try {\r\n        return await db.collection('***').doc(event.id).update({  //需要修改的数据库\r\n            data: {\r\n                data_name: event.data_name,\r\n                address: event.address,\r\n                weekNum: event.weekNum,\r\n                pitchNum: event.pitchNum,\r\n                teacher: event.teacher\r\n          },\r\n        })\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n    return {\r\n        event,\r\n        openid: wxContext.OPENID,\r\n        appid: wxContext.APPID,\r\n        unionid: wxContext.UNIONID,\r\n    }\r\n}\r\n复制代码然后在js文件中编写对应的代码tapDialogButton(e) { //从课表删除课程\r\n    wx.cloud.callFunction({\r\n        name: '***',// 你的云函数名称\r\n        data: {\r\n          id: this._id,  //将数据进行空值赋值\r\n          data_name: \"\",\r\n          address: \"\",\r\n          weekNum: \"\",\r\n          pitchNum: \"\",\r\n          teacher: \"\"\r\n        },\r\n        success: res => {\r\n          // 关闭当前点击课程详情\r\n        }\r\n    })\r\n},\r\n复制代码改，增做完了删其实对改和增的实现应该也变得相对简单，这里也是需要用到云函数，道理和上面讲的一致.在获取当前点击的数据时先将此条数据存储在data中，需要修改时，可以将数据赋值给input的value,在通过云函数来修改数据库中对应的数据.增也是同样的道理.这里就拿改为例.wxml<!-- 编辑页 -->\r\n<view class=\"edit\" hidden=\"{{ editShow }}\">\r\n    <van-nav-bar title=\"编辑课程\" right-text=\"完成\" left-arrow bind:click-left=\"editLeft\" bind:click-right=\"editRight\" />\r\n    <view class=\"label className\">\r\n        <text>课名</text>\r\n        <input  value=\"{{ nowClass.data_name }}\" bindinput=\"bindKeyInput1\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>教室</text>\r\n        <input  value=\"{{ nowClass.address }}\" bindinput=\"bindKeyInput2\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>周数</text>\r\n        <input  value=\"{{ nowClass.weekNum }}\" bindinput=\"bindKeyInput3\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>节数</text>\r\n        <input  value=\"{{ nowClass.pitchNum }}\" bindinput=\"bindKeyInput4\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>老师</text>\r\n        <input  value=\"{{ nowClass.teacher }}\" bindinput=\"bindKeyInput5\"></input>\r\n    </view>\r\n</view>\r\n复制代码新建修改课程表数据的云函数//修改课程表\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n    env: '***',//你的开发环境\r\n    traceUser: true\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => { // 云函数入口函数\r\n    try {\r\n        return await db.collection('***').doc(event.id).update({  //你要操作的数据库\r\n            data: {\r\n                data_name: event.data_name,\r\n                address: event.address,\r\n                weekNum: event.weekNum,\r\n                pitchNum: event.pitchNum,\r\n                teacher: event.teacher\r\n            },\r\n        })\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n    return {\r\n        event,\r\n        openid: wxContext.OPENID,\r\n        appid: wxContext.APPID,\r\n        unionid: wxContext.UNIONID,\r\n    }\r\n}\r\n复制代码js//  1.首先获取输入框的值，存在data中\r\nbindKeyInput1(e) { //课名\r\n    this.editClassName = e.detail.value\r\n},\r\nbindKeyInput2(e) { //教室\r\n    this.editAddress = e.detail.value\r\n},\r\nbindKeyInput3(e) { //周数\r\n    this.editWeekNum = e.detail.value\r\n},\r\nbindKeyInput4(e) { //节数\r\n    this.editPitchNum = e.detail.value\r\n},\r\nbindKeyInput5(e) { //老师\r\n    this.editTeacher = e.detail.value\r\n},\r\neditRight() { //  2.编辑完成，点击提交按钮时将输入框的值赋值给对应的字段名\r\n  wx.cloud.callFunction({\r\n    name: '***',// 修改课程表数据的云函数名称\r\n    data: {\r\n      id: this._id,\r\n      data_name: this.editClassName,\r\n      address: this.editAddress,\r\n      weekNum: this.editWeekNum,\r\n      pitchNum: this.editPitchNum,\r\n      teacher: this.editTeacher\r\n    },\r\n    success: res => {\r\n    },\r\n    fail: console.error\r\n  })\r\n\r\n},\r\n复制代码到这里课程表功能就做完了，如果有什么不懂得地方欢迎留言，或者写的不好的地方，请大家指出一起探讨，之后会继续分享后面的内容。大家也可以提前扫码查看小程序，欢迎指出不足，谢谢"}
{"title": "最近很火的 倒放挑战 - ReverseVoice (微信小程序版 前后端源码) Ts Node Taro ... ... ", "author": "Rolan", "pub_time": "2019-11-29 00:21", "content": "项目地址: https://github.com/smackgg/reversevoice整个项目其实很简单，从本人在抖音和 B 站看到火起来到最终小程序上线也就几天的下班时间就搞定了，11月16日上线至今用户量还是蛮多的(主要当时做的快此类 app 比较少)，现在已经出现了大量的更简约更好的倒放挑战 app，本项目开源仅供大家学习~拥抱 TypeScript ~顺便小声吐槽一下 Taro 对 Ts 的支持还是不够啊，希望大家多去给 Taro 提 dts 的 PR ~体验小程序二维码挑战分享海报 (这个海报暂时有问题，修复代码因为资质问题还没有提交审核)功能介绍/实现原理功能及实现原理简述小程序端用户录音并保存本地录音后将录音文件上传至后端进行倒放处理，并返回处理后的音频 url小程序端下载 url 文件，提示用户反转成功，将数据做本地 map用户点击分享，生成分享链接，并将该分享正放、倒放视频均传至后端保存至七牛云同时新建分享 room 保存用户信息，返回 roomId用户分享（海报分享 canvas 动态生成分享码海报）其它用户参加挑战，存储原理同 4，只是增加将挑战者信息了存入 room 的逻辑音频倒放使用 ffmpeg 进行音频倒放，核心代码：// 详见 ./server/src/controllers/file.ts => function reverseVoice\r\nimport ffmpegPath from '@ffmpeg-installer/ffmpeg'\r\nimport ffprobePath from '@ffprobe-installer/ffprobe'\r\nimport ffmpeg from 'fluent-ffmpeg'\r\nffmpeg.setFfprobePath(ffprobePath.path)\r\nffmpeg.setFfmpegPath(ffmpegPath.path)\r\n\r\nffmpeg(filepath)\r\n    .format('mp4')\r\n    // 反转\r\n    .outputOptions([\r\n      '-vf reverse',\r\n      '-af areverse',\r\n      '-preset',\r\n      'superfast',\r\n      '-y',\r\n    ])\r\n    .on('progress', (progress) => {\r\n      // send upload progress\r\n      console.log('upload-file-progress', progress.percent)\r\n    })\r\n    .on('error', (err) => {\r\n      console.log(`Ffmpeg has been killed${err.message}`)\r\n    })\r\n    .toFormat('mp3')\r\n    // 保存\r\n    .save(publicPath + saveFilePath)\r\n    .on('end', () => {\r\n      // 获取音频信息（时长等）\r\n      ffmpeg.ffprobe(publicPath + saveFilePath, (err, metadata) => {\r\n        console.log(metadata.format.duration)\r\n      })\r\n    })小程序录音小程序录音使用官方 api，详细逻辑见 ./wechatapp/pages/index/index.tsx录音海报生成利用 canvas 动态合成分享海报 /wechatapp/pages/sharePoster需要动态请求页面小程序码，涉及微信AccessToken鉴权等，详见 /server/src/controllers/wechat.ts, 下面贴出部分核心代码// 画图\r\nconst draw = async () => {\r\n  // 绘制之前 loading\r\n  Taro.showLoading({\r\n    title: '海报生成中...',\r\n    mask: true,\r\n  })\r\n  // 获取图片信息\r\n  const [productImgInfo, qrcodeImgInfo] = await Promise.all([\r\n    this.getImageInfo(sharePoster), // 获取主图\r\n    this.getQrImgInfo(), // 获取二维码图片\r\n  ])\r\n\r\n  // product image 宽高\r\n  const pW = CANVAS_WIDTH\r\n  const pH = (pW / productImgInfo.width) * productImgInfo.height\r\n\r\n  // canvas 高度\r\n  let canvasHeight = pH\r\n\r\n  const ctx = Taro.createCanvasContext('canvas', null)\r\n\r\n  ctx.fillStyle = '#fff'\r\n  ctx.fillRect(0, 0, CANVAS_WIDTH, canvasHeight)\r\n\r\n  // 绘制背景图片\r\n  ctx.drawImage(sharePoster, 0, 0, pW, pH)\r\n\r\n  // 绘制二维码 （因为有角度，需要旋转画布，再旋转回来）\r\n  ctx.rotate(-Math.PI / 32)\r\n  ctx.translate(-25 * ratio, 10 * ratio)\r\n  ctx.drawImage(qrcodeImgInfo.path, QR_LEFT, QR_TOP, QR_WIDTH, QR_WIDTH)\r\n  ctx.rotate(Math.PI / 32)\r\n  this.setState({\r\n    canvasStyle: {\r\n      ...this.state.canvasStyle,\r\n      height: canvasHeight,\r\n    },\r\n  })\r\n  ctx.stroke()\r\n  setTimeout(() => {\r\n    Taro.hideLoading()\r\n    ctx.draw()\r\n  }, 500)\r\n}微信分享 HOC 函数 ./wechatapp/components/@withShare// 微信小程序每个页面几乎都需要配置分享的参数，并且需要动态更改分享参数\r\n// 所以抽离 HOC 组件，方便页面使用\r\nimport { ComponentClass } from 'react'\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { connect } from '@tarojs/redux';\r\nimport defaultShareImg from '@/assets/images/share.png'\r\n\r\ntype Options = {\r\n  title?: string\r\n  imageUrl?: string\r\n  path?: string\r\n}\r\n\r\nconst defalutOptions: Options = {\r\n  title: '你能听懂我说啥么？最近很火的反转录音来啦~',\r\n  imageUrl: defaultShareImg,\r\n  path: 'pages/index/index',\r\n}\r\n\r\nfunction withShare() {\r\n  return function demoComponent(Component: ComponentClass) {\r\n    @connect(({ user }) => ({\r\n      userInfo: user.userInfo\r\n    }))\r\n    class WithShare extends Component {\r\n      $shareOptions?: Options\r\n      async componentWillMount() {\r\n        Taro.showShareMenu({\r\n          withShareTicket: true,\r\n        })\r\n\r\n        if (super.componentWillMount) {\r\n          super.componentWillMount()\r\n        }\r\n      }\r\n\r\n      // 点击分享的那一刻会进行调用\r\n      onShareAppMessage() {\r\n        // const sharePath = `${path}&shareFromUser=${userInfo.shareId}`\r\n        let options = defalutOptions\r\n        if (this.$shareOptions) {\r\n          options = {\r\n            ...defalutOptions,\r\n            ...this.$shareOptions,\r\n          }\r\n        }\r\n        return options\r\n      }\r\n\r\n      render() {\r\n        return super.render()\r\n      }\r\n    }\r\n\r\n    return WithShare\r\n  }\r\n}\r\n\r\nexport default withShare使用@withShare()\r\nclass Room extends Component {\r\n  /**\r\n * 指定config的类型声明为: Taro.Config\r\n *\r\n * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型\r\n * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string\r\n * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型\r\n */\r\n  config: Config = {\r\n    navigationBarTitleText: '首页',\r\n  }\r\n\r\n  $shareOptions = {\r\n    title: '倒放挑战！你能听懂我倒立洗头~',\r\n    path: 'pages/index/index',\r\n    imageUrl: '',\r\n  }\r\n\r\n  /**\r\n    ....\r\n  */\r\n}\r\n微信用户登录流程微信官方文档登录流程具体实现可以去看源码项目运行 - 后端准备需要提前安装:Install Node.jsInstall MongoDB开始克隆项目并进入后端目录cd server安装依赖npm install设置 mongoDB# create the db directory\r\nsudo mkdir -p /data/db\r\n# give the db correct read/write permissions\r\nsudo chmod 777 /data/db\r\n\r\n# starting from macOS 10.15 even the admin cannot create directory at root\r\n# so lets create the db diretory under the home directory.\r\nmkdir -p ~/data/db\r\n# user account has automatically read and write permissions for ~/data/db.启动 mongoDB (Start your mongoDB server (you'll probably want another command prompt)mongod\r\n\r\n# on macOS 10.15 or above the db directory is under home directory\r\nmongod --dbpath ~/data/db打包并运行项目npm run build\r\nnpm start项目运行 - 小程序端准备需要提前安装:Install 微信开发者工具开始克隆项目并进入小程序目录cd wechatapp安装依赖npm install新建 .env 文件在 wechatapp/src/utils 目录下克隆 env.example.ts 文件至同目录命名为 .env.ts 文件\r\n此文件两个参数分别代表本地开发和线上部署的请求地址运行项目npm run dev:weapp // development mode\r\n或者 npm run build:weapp // production mode微信开发者工具选择导入项目，并选择 wechatapp/dist 目录\r\n若本地开发，需要在开发者工具中设置开启“不校验合法域名“LicenseMIT"}
{"title": "如何使用不到50行代码实现一个小而美的依赖收集库？ ", "author": "Rolan", "pub_time": "2019-12-2 00:02", "content": "现代web开发，大多数都遵循着视图与逻辑分离的开发原则，一反面使得代码更加易懂且易扩展，另一方面带来的问题就是如何优雅的管理数据。因而，社区诞生了很多优秀的状态管理库，比如为React而生的 Redux ，专为 Vue 服务的 Vuex ，还有不限定框架的 Mobx 等等。在为使用这些库提升开发效率而叫好的同时，我觉得我们也应该从内部去真正的了解它们的核心原理，就比如今天这篇文章的主题 依赖收集 ，就是其中的一个很大的核心知识。这篇文章将会带您一步一步的以最少的代码去实现一个小而美的依赖收集库，同时给您展现如何将这个库运用到小程序中去实现跨页面的状态共享。二 实现过程1. 基本原理依赖收集的基本原理可以概括为以下3步：创建一个可观察（observable）对象视图或者函数（effect）引用这个对象的某个属性，触发依赖收集改变数据，视图或者函数自动更新或运行我们要实现的例子：import { observable, observe } from \"micro-reaction\";\r\n\r\nconst ob = observable({\r\n    a: 1\r\n});\r\n\r\nobserve(() => console.log(ob.a));\r\n\r\n// logs: 1\r\n// logs: 2\r\nob.a = 2;\r\n复制代码下面开始我将一步一步的进行实现过程讲解2. 创建一个可观察对象首先，我们需要创建一个可观察对象，其本质就是将传入的对象进行代理，并且返回这个代理对象，这里我们使用 es6 的 Proxy 来修改对象的一些行为，从而实现在返回真正对象前作一些拦截操作。我们定义了一个名叫 observable 方法来代理对象，代码如下：export function observable(obj = {}) {\r\n    return createObservable(obj)\r\n}\r\n\r\nfunction createObservable(obj) {\r\n    const proxyObj = new Proxy(obj, handlers());\r\n    return proxyObj\r\n}\r\n复制代码可以看到 observable 方法内部就是通过 new Proxy（obj,handler） 生成一个代理对象，传参分别是原始对象和代理操作方法 handlers ， handlers 返回一个对象，定义了对象的原始方法，例如 get 、 set ，通过重新定义这两个方法，我们可以修改对象的行为，从而完成代理操作，我们来看看 handlers 方法。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            return result\r\n        },\r\n        set: (target, key, value, receiver) => {\r\n            const result = Reflect.set(target, key, value, receiver);\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码如上，我们在 get 和 set 方法里面没有做任何操作，取值赋值操作都是原样返回。3. 关联副作用函数effect完成了对数据的初始定义，我们明确下我们的目的，我们的最终目的是数据改变，副作用函数 effect 自动运行，而这其中的关键就是必须有个地方引用我们创建的代理对象，从而触发代理对象内部的 get 或者 set 方法，方便我们在这两个方法内部做一些依赖收集和依赖执行的工作。因而，这里我们定义了一个 observe 方法，参数是一个 Function ，我们先看看这个方法的实现：export function observe(fn) {\r\n    <!--这一行可以先忽略，后面会有介绍-->\r\n    storeFns.push(fn);\r\n    <!--Reflect.apply()就相当于fn.call(this.arguments)-->\r\n    Reflect.apply(fn, this, arguments)\r\n}\r\n复制代码可以看到，内部执行了传入的函数，而我们传入的函数是 () => console.log(ob.a.b) ，函数执行，输出 ob.a ，引用了代理对象的 a 属性值，就触发了代理对象内部的 get 方法。 在 get方法内部我们就可以进行依赖收集。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            <!--触发依赖收集-->\r\n            depsCollect({ target, key })\r\n            return result\r\n        },\r\n        set: (target, key, value, receiver) => {\r\n            const result = Reflect.set(target, key, value, receiver);\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码depsCollect 依赖收集方法需要做的操作就是将当前的依赖也就是 () => console.log(ob.a)这个函数 fn 保存起来，那 fn 怎么传过来呢？ get 方法本身的入参是没有这个 fn 的，回顾之前的 observe 方法，这个方法有传入 fn ，其中内部有个 storeFns.push(fn) 这样的操作，就是通过一个数组将当前依赖函数临时收集起来。可光收集没用，我们还要和对应的属性进行映射，以便后续某个属性变化时，我们能够找出对应的 effect ，故我们定义了一个 Map 对象来存储相应的映射关系，那需要怎样的一个映射关系呢？一个对象有多个属性，每个属性可能都有对应的 effect ，结构看起来应该是这样的：{\r\n    obj:{\r\n        \"key-1\":fn1,\r\n        \"key-2\":fn2,\r\n        ....\r\n    }\r\n}\r\n复制代码我们定义了一个全局变量 storeReactions 来存储整个映射关系，它的 key 是 obj ，就是原始对象， obj 的值也是个 Map 结构，存储了其属性和 effect 的映射关系。我们的最终目的其实也就是建立一个这样的关系。理清楚了数据存储，再来看看我们的 depsCollect 方法，其实就是将临时保存在 storeFns 里面的函数取出和属性 key 映射。// 存储依赖对象\r\nconst storeReactions = new WeakMap();\r\n// 中转数组，用来临时存储当前可观察对象的反应函数，完成收集之后立即释放\r\nconst storeFns = [];\r\nfunction depsCollect({ target, key }) {\r\n    const fn = storeFns[storeFns.length - 1];\r\n    if (fn) {\r\n        const mapReactions = storeReactions.get(target);\r\n        if (!mapReactions.get(key)) {\r\n            mapReactions.set(key, fn)\r\n        }\r\n    }\r\n}\r\n复制代码至此，我们的依赖收集算是完成了，接下来就是要实现如何监听数据改变，对应 effect 自动运行了。4. 数据变更，effect自动运行数据变更，就是重新设置数据，类似 a=2 的操作，就会触发代理对象里面的 set 方法，我们只需要在 set 方法里面取出对应的 effect 运行即可。set: (target, key, value, receiver) => {\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        executeReactions({ target, key })\r\n        return result\r\n    }\r\n    \r\nfunction executeReactions({ target, key }) {\r\n    <!-- 一时看不懂的，回顾下我们的映射关系 -->\r\n    const mapReactions = storeReactions.get(target);\r\n    if (mapReactions.has(key)) {\r\n        const reaction = mapReactions.get(key);\r\n        reaction();\r\n    }\r\n}\r\n复制代码ok，我们的例子的实现过程讲解完了，整个实现过程还是很清晰的，最后看看我们的整个代码，去掉空行不到50行代码。const storeReactions = new WeakMap(),storeFns = [];\r\n\r\nexport function observable(obj = {}) {\r\n  const proxyObj = new Proxy(obj, handlers());\r\n  storeReactions.set(obj, new Map());\r\n  return proxyObj\r\n}\r\n\r\nexport function observe(fn) {\r\n  if (storeFns.indexOf(fn) === -1) {\r\n    try {\r\n      storeFns.push(fn);\r\n      Reflect.apply(fn, this, arguments)\r\n    } finally {\r\n      storeFns.pop()\r\n    }\r\n  }\r\n}\r\n\r\nfunction handlers() {\r\n  return {\r\n    get: (target, key, receiver) => {\r\n      depsCollect({ target, key })\r\n      return Reflect.get(target, key, receiver)\r\n    },\r\n    set: (target, key, value, receiver) => {\r\n      Reflect.set(target, key, value, receiver)\r\n      executeReactions({ target, key })\r\n    }\r\n  }\r\n}\r\n\r\nfunction depsCollect({ target, key }) {\r\n  const fn = storeFns[storeFns.length - 1];\r\n  if (fn) {\r\n    const mapReactions = storeReactions.get(target);\r\n    if (!mapReactions.get(key)) {\r\n      mapReactions.set(key, fn)\r\n    }\r\n  }\r\n}\r\n\r\nfunction executeReactions({ target, key }) {\r\n  const mapReactions = storeReactions.get(target);\r\n  if (mapReactions.has(key)) {\r\n    const reaction = mapReactions.get(key);\r\n    reaction();\r\n  }\r\n}\r\n复制代码5. 多层级数据结构到目前为止，我们实现的还只能观察单级的对象，如果一个对象的层级深了，类似 ob.a.b 的结构，我们的库就无法观察数据的变动， effect 也不会自动运行。那如何支持呢？核心原理就是在 get 方法里面判断返回的值，如果返回的值是个对象，就递归调用 observable 方法，递归调用完，接着运行 observe 方法就会构建出完整的一个属性 key 和反应 effect 的映射关系。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            depsCollect({ target, key })\r\n            if (typeof result === 'object' && result != null && storeFns.length > 0) {\r\n                return observable(result)\r\n            }\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码回到 ob.a.b 这样的结构，此时实际的代理对象应该是这样的 {proxy(proxy(c))} ，如果这个时候我们去修改数据，比如 ob.a.b = 2 这样。ob.a.b = 2 的运行过程会是怎样？要知道js这门语言是先编译后执行的，所以js引擎首先会去分析这段代码（编译阶段），先分析左边的表达式 ob.a.b ，故先会编译 ob.a ，触发了第一次 get 方法，在 get 方法中， result 得到的值是个对象，如果按照上述代码，又去重新观察这个对象，会导致 observe 方法中构建好的映射关系丢失，其中就是对象 {b:1} 中 key 为 b 对应的 fn 丢失，因为我们存储 fn 是在 observe 方法中执行的，那怎么办呢？方法是我们应该在第一次 observable 方法执行的时候，将每一个 key 对应的代理对象都保存起来，在赋值操作再一次触发 get 方法的时候，如果已经代理过，直接返回就行，不需要重新代理。// 存储代理对象\r\nconst storeProxys = new WeakMap();\r\nexport function observable(obj = {}) {\r\n    return storeProxys.get(obj) || createObservable(obj)\r\n}\r\nfunction createObservable(obj) {\r\n    const proxyObj = new Proxy(obj, handlers());\r\n    storeReactions.set(obj, new Map())\r\n    storeProxys.set(obj, proxyObj)\r\n    return proxyObj\r\n}\r\nfunction handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            depsCollect({ target, key })\r\n            <!--如果代理存储中有某个key对应的代理直接返回即可-->\r\n            const observableResult = storeProxys.get(result);\r\n            if (typeof result === 'object' && result != null && storeFns.length > 0) {\r\n                return observable(result)\r\n            }\r\n            return observableResult || result\r\n        }\r\n    }\r\n}\r\n复制代码如此， ob.a.b = 2 ，控制台就会依次输出 1 和 2 ，另外说一句，数组也是对象，故动态增加数组的值或者赋值操作都能触发响应的 effect 。const ob = observable({\r\n  a: {\r\n    b: 1,\r\n    c: []\r\n  }\r\n});\r\n\r\nobserve(() => console.log(ob.a.c.join(\", \")));\r\n//logs: 2\r\nob.a.c.push(2);\r\n复制代码三 如何结合小程序使用全部完整代码我已发布到我的github中，名字叫做 micro-reaction ，这个库完全无依赖的，纯粹的，故可以为其它界面框架状态管理提供能量，由于小程序跨页面状态共享相关的库不多，故这里以小程序举例，如何结合 micro-reaction 实现跨页面状态共享。1. 核心原理描述下场景，有两个页面 A 和 B ，全局数据 C ， A 和 B 都引用了 C ，之后，页面 A 中某个交互改变了 C ， A 和 B 都需要自动渲染页面。结合我们的库， C 肯定是需要 observable的， observe 方法传入的 fn 是会动态执行的，小程序渲染页面的方式是 setData 方法，故 observe 方法里面肯定执行了 setData() ，因而只要我们在 observe 方法里面引用 C ，就会触发依赖收集，从而在下次 C 改变之后， setData 方法重新运行渲染页面。2. 关键步骤首先，我们需要拿到每个小程序页面的 this 对象，以便自动渲染使用，故我们需要代理 Page方法里面传入的参数，我们定一个了 mapToData 方法来代理，代码如下：<!--全局数据-->\r\nimport homeStore from \"../../store\"\r\n<!--将数据映射到页面，同时出发依赖收集，保存页面栈对象-->\r\nimport { mapToData } from \"micro-reaction-miniprogram\"\r\nconst connect = mapToData((store) => ({ count: store.credits.count }), 'home')\r\n\r\nPage(connect({\r\n  onTap(e) {\r\n    homeStore.credits.count++\r\n  },\r\n  onJump(e) {\r\n    wx.navigateTo({\r\n      url: \"/pages/logs/logs\"\r\n    })\r\n  }\r\n}))\r\n复制代码mapToData 方法返回一个函数， function mapToData(fn,name){return function(pageOpt){}}，这里用到了闭包，外部函数为我们传入的函数，作用是将全局数据映射到我们的页面 data 中并触发依赖收集，内部函数传入的参数为小程序页面本身的参数，里面包含了小程序的生命周期方法，因而我们就可以在内部重写这些方法，并拿到当前页面对象并存储起来供下一次页面渲染使用。import { STORE_TREE } from \"./createStore\"\r\nimport { observe, observable } from 'micro-reaction';\r\n\r\nfunction mapToData(fn, name) {\r\n  return function (pageOpt) {\r\n    const { onLoad } = pageOpt;\r\n    pageOpt.onLoad = function (opt) {\r\n      const self = this\r\n      const dataFromStore = fn.call(self, STORE_TREE[name], opt)\r\n      self.setData(Object.assign({}, self.data, dataFromStore))\r\n\r\n      observe(() => {\r\n        <!--映射方法执行，触发依赖收集-->\r\n        const dataFromStore = fn.call(self, STORE_TREE[name], opt)\r\n        self.setData(Object.assign({}, self.data, dataFromStore))\r\n      })\r\n\r\n      onLoad && onLoad.call(self, opt)\r\n    }\r\n    return pageOpt\r\n  }\r\n}\r\n\r\nexport { mapToData, observable }\r\n复制代码然后，页面 A 改变了数据 C ， observe 方法参数 fn 自动执行，触发 this.setData 方法，从而页面重新渲染，完整代码点击 micro-reaction-miniprogram ，也可以点击查看 在线Demo。四 总结希望我的文章能够让您对依赖收集的认识更深，以及如何举一反三的学会使用，此外，最近在学习周爱民老师的《JavaScript核心原理解析》这门课程，其中有句话对我触动很深，引用的是金庸射雕英雄传里面的文本： 教而不得其法，学而不得其道 ，意思就是说，传授的人没有用对方法，学习的人就不会学懂，其实我自己对学习的方法也一直都很困惑，前端发展越来越快，什么 SSR ，什么 serverless ，什么 前端工程化 ，什么 搭建系统 各种知识概念越来越多，不知道该怎么学习，说不焦虑是不可能的，但坚信只有一个良好的基础，理解一些技术的本质，才能在快速发展的前端技术浪潮中，不至于被冲走，与局共勉！最后，在贴下文章提及的两个库，欢迎star试用，提pr，感谢~依赖收集库 micro-reaction小程序状态管理库 micro-reaction-miniprogram"}
{"title": "从0到1开发一个小程序cli脚手架（三） --自定义命令 ", "author": "Rolan", "pub_time": "2019-11-29 00:52", "content": "本文主要讲述关于如何实现自定义命令\r\ngithub地址：github.com/jinxuanzhen…\r\n觉得有用的朋友帮忙给项目一个star，谢谢\r\n\r\n系列内容，推荐从第一篇开始阅读：从0到1开发一个小程序cli脚手架（一）--创建页面/组件模版篇从0到1开发一个小程序cli脚手架（二） --版本发布/管理篇从0到1开发一个小程序cli脚手架（三） --自定义命令\r\n\r\n背景\r\n在写不同小程序的时候，突然发现每个小程序面临的场景和需求或多或少会有些差异化，比如说程序A会有生成doc的功能，程序B会有开启数据埋点的debug模式等等\r\n为了保证脚手架的通用性，我们并不能将这些差异化的功能一一实现，这时候就需要让用户实现自定义了\r\n\r\n准备工作\r\n最好看过之前的两篇文章并搭建过demo，里面有介绍一些项目的结构，实现思路，第三方包使用相关的东西\r\n\r\n开始\r\n\r\n梳理大概流程\r\n这里不多说了，老套路: config注册方法 -> 脚手架路由读取注册方法 -> 执行回调函数\r\n\r\n注册自定义命令\r\n既然是给开发者在实际项目中进行配置，那么自然在配置文件 xdk.config.js 文件中动手了，在配置文件中预留出一个口子，方便我们读取配置文件时获取json，因为开发者可能会注册多个自定义命令，我这里字段类型直接给的数组类型\r\n\r\n将字段customScripts配置好后，就开始配置自定义命令了，首先确定需要的属性\r\n\r\n[name], 命令名称肯定是要的\r\n[desc], 描述本质上可有可无，不影响功能，但是比较方便记忆\r\n[callback], 输入完命令之后要执行什么(回调函数主体)\r\n\r\n\r\n大概是这个样子，后续我会以生成sass文档为例来写一个自定义命令\r\n\r\n读取配置项\r\n回到xdk-cli这个项目，找到入口文件index.js，如果看过前面两篇文章，会知道首先要配置路由，这里调用第三方包commander来解析命令\r\n\r\n配置路由\r\n\r\n这里先看第一行，我用了前缀 run <cmd> 来解析，也就是说我们使用的时候必须输入xdk-cli run <cmd>，那么为什么不直接xdk-cli <cmd>呢？\r\n主要是为扩展考虑，避免命名重复导致功能被覆盖，而且自定义指令本质上只是xdk-cli脚手架诸多功能中的一项，放在第一层级实在有些不合时宜\r\n有些情况下，不太清楚当前项目下的自定义命令都有哪些，可以直接xdk-cli -h查看\r\n\r\n加装方法\r\n通过run 命令我们可以准确到达当前的action，接下来要做什么？\r\n自然是执行自定义命令的回调，在执行之前我们可以给他加装一系列方法，更利于去二次开发，我这里采用的是改变this指向的方法，将当前函数作用于绑定到originPrototype上\r\n\r\n\r\n方法库列表\r\n我这里道导出了封装好log的开启子进程方法，log方法，还有交互命令行方法，当然也可以导出更多，主要看自己的需求\r\n\r\n到这里为止，这样一套流程就跑通了，下面我写一个小例子\r\n\r\n案例：生成sass文档\r\n可以看到我调用的子进程，和日志都是通过接口公开出来已经在脚手架进行过统一处理的方法，并没有去多做事情\r\n当然你也可以使用交互命令，让自定义命令更加友好，例如：\r\n\r\n配合package.json\r\n可以在package.json的scripts里注册命令，简化我们的调用\r\n直接可以简写为npm start\r\n\r\n最后\r\n这篇比较简单，基本上只是针对回调方法做了包装与回传，目标是为了方便让开发者去定制一些功能\r\n到此为止，三篇文章下来整个小程序开发脚手架的大概逻辑和框架已经非常清晰明了，后续的话有可能会针对npm支持, 和npm包的开发模板进行更新，觉得有帮助的同学可以关注下~~"}
{"title": "小程序图像处理：图片配色分析 ", "author": "Rolan", "pub_time": "2019-12-2 00:10", "content": "背景\r\n小程序的canvas是微信基于原生组件自行封装的，因此接口跟web的canvas有不少区别，早期更是没有支持像素级的处理能力。\r\n在18年初的小程序基础库1.9.0版本更新中，出现了wx.canvasGetImageData和wx.canvasPutImageData两个重要的API，补全了像素处理能力，因此，小程序在客户端进行图片处理成为了可能。\r\n具体可以参考：\r\n偷偷迭代的重磅功能---小程序的像素处理能力\r\nwx.canvasGetImageData\r\n图片配色分析小程序：小色卡\r\n为了尝试小程序的图像处理能力，我做了个用于图片配色分析的小程序-小色卡。\r\n功能主要是：用户选择一张图片，程序会分析图片的配色，并把配色展示为一张色卡给用户。用户可以保存、编辑、复制自己的色卡。这个功能对初级的UI设计师有一定的帮助（可能吧...）。\r\n源码：github：mini-color-card\r\n体验小程序：\r\n\r\n原理\r\n小程序实现配色分析主要步骤如下：\r\n\r\n用户选择图片，拿到imgPath后绘制到canvas上。\r\n通过wx.canvasGetImageData这个接口读取图片数据\r\n对图片数据进行预处理，剔除alpha比较小并且不是白色的点。（非必要）\r\n对图片像素数据进行聚类。每个像素的颜色可以作为一个三维向量来看。\r\n\r\n基本逻辑如下：\r\nwx.chooseImage({\r\n  count: 1,\r\n  sizeType: ['original', 'compressed'],\r\n  sourceType: ['album', 'camera'],\r\n  success: (res) => {\r\n    wx.getImageInfo({\r\n      src: res.tempFilePaths[0],\r\n      success: (imgInfo) => {\r\n        let {\r\n          width,\r\n          height,\r\n          imgPath\r\n        } = imgInfo;\r\n        let ctx = wx.createCanvasContext(this.canvasID);\r\n        ctx.drawImage(imgPath,0,0,width,height);\r\n        ctx.draw(false,()=>{\r\n          wx.canvasGetImageData({\r\n            canvasId: this.canvasID,\r\n            x: 0,\r\n            y: 0,\r\n            width: width,\r\n            height: height,\r\n            success(res) {\r\n              var pixels = res.data;\r\n              var pixelCount = width*height;\r\n              var pixelArray = [];\r\n              // 对像素数据进行预处理\r\n              for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\r\n                offset = i * 4;\r\n                r = pixels[offset + 0];\r\n                g = pixels[offset + 1];\r\n                b = pixels[offset + 2];\r\n                a = pixels[offset + 3];\r\n                if (a >= 125) {\r\n                  if (!(r > 250 && g > 250 && b > 250)) {\r\n                    pixelArray.push([r, g, b]);\r\n                  }\r\n                }\r\n              }\r\n              var cmap = MMCQ.quantize(pixelArray, colorCount);//聚类，MMCQ是个用于图像分析的库\r\n              var palette = cmap ? cmap.palette() : null;\r\n              console.log('配色为：',palette);\r\n            }\r\n          })\r\n        })\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码小结\r\n一开始我是不想把canvas显示出来的，只想用它获取图像内容，但是实践下来是不可行的。小程序的canvas并不允许离屏渲染，想要用它进行图片处理，就要老老实实用它进行展示。\r\n这里只实践了wx.canvasGetImageData读取数据进行图像分析，不过结合wx.canvasPutImageData，滤镜之类的图像处理应该都是可以做了。小程序的想象空间还是挺大的。"}
{"title": "微信小程序把base64的图片保存到手机相册 ", "author": "Rolan", "pub_time": "2019-12-2 00:17", "content": "var file = wx.getFileSystemManager();\r\nconsole.log('1')\r\nfile.writeFile({\r\n    //读写文件路径filePath需要使用wx.env.USER_DATA_PATH + '/tmp.txt'才可以读写成功。\r\n    filePath:  wx.env.USER_DATA_PATH + '/poster.png',\r\n    data: self.preurl.slice(22),\r\n    encoding:'base64',\r\n    success:async()=>{\r\n        console.log('123')\r\n        const res2 = await wepy.saveImageToPhotosAlbum({\r\n            filePath: wx.env.USER_DATA_PATH + '/poster.png'\r\n        })\r\n        wepy.$toast('图片已保存到相册，赶紧晒一下吧~')\r\n        self.isShow = false\r\n        self.$apply();\r\n    },\r\n    fail:function(e){\r\n        console.log(e)\r\n    }\r\n})wx.getFileSystemManager()  是获取文件管理器对象；aa.writeFile  是写文件，详细参数可\t点击查看 官方文档说明。String wx.env.USER_DATA_PATH文件系统中的用户目录路径wx.env.USER_DATA_PATH +'/test.png'  这里是创建一个临时文件的文件名。that.data.scene.slice(22)   这里是把 data:image/png;base64这一段去除，需要注意的是去除这一段之后 base64 编码之间放到image组件的src里面是不能显示图片的。"}
{"title": "最简单的小程序状态管理方案! - mobx-mini ", "author": "Rolan", "pub_time": "2019-12-2 09:15", "content": "写在前面\r\n状态管理可以说是现代前端开发中最核心的一环。为了解决前端应用的复杂度，生态圈里诞生了各式各样的状态管理方案，按编程范式分类有函数式（redux），响应式（rxjs），透明的函数响应式（mobx），按状态存储分类有单 store 和 多 store 的，有专门处理异步代码的（rxjs），还有连异步都不处理的（redux）.....，基本上可以满足各种场景的前端应用。\r\n然而受制于小程序封闭的生态，各种状态方案的绑定库都无法在小程序内使用。已有的绑定库不能用？那就写一个呗。\r\n\r\n状态管理的目标\r\n在迈入正文前，先说一下我们对状态管理方案的一些诉求：\r\n\r\n基于已有的状态管理方案，redux, mobx, rxjs，最大程度复用现有生态\r\nTypescript 友好（ts 真香）\r\nAPI 简单清晰，性能基线高，无需手动优化就能达到不错的性能。\r\n少模板代码，代码敲多了手疼（说的就是 redux）\r\n\r\nrxjs 学习曲线过于陡峭，也没定义状态如何存储，划掉；redux 概念挺多，模板代码和概念一样多，不要。那就剩下 mobx 了。\r\n\r\nAPI\r\n首先定义 store，并连接到页面。\r\n\r\nobserver(context, mapState)\r\nimport { observable } from 'mobx';\r\nimport { observer } from 'mobx-mini';\r\nconst rootStore = observable({\r\n  title: 'mobx-app'\r\n});\r\nconst store = observable({\r\n  count: 0,\r\n  get isOdd() {\r\n    return this.seconds % 2 === 1;\r\n  },\r\n  tick() {\r\n    this.count += 1;\r\n  }\r\n});\r\nconst mapState = () => ({\r\n  count: store.count,\r\n  seconds: store.isOdd,\r\n  title: rootStore.title,\r\n});\r\n// page\r\nPage({\r\n  add() {\r\n    store.tick();\r\n  },\r\n  onLoad() {\r\n    observer(this, mapState);\r\n  },\r\n});\r\n复制代码直接在 axml 中使用吧\r\n<view>count</view>\r\n复制代码\r\n实现原理\r\n如果你还没有对 mobx 有所了解，建议看一下它的中文文档 了解一下前置知识。原理就是 observer  APi 会对参数 mapState 中的 observable 对象注册 autorun 函数，在 autorun 内部，监听到 observable 变动后，直接对页面  setData 。小程序的 data 就会动态更新了。\r\n\r\n总结\r\n提醒一下，暂时只支持支付宝小程序，且未在生产环境中使用过。源码在这里，只有100行不到。github.com/luv-sic/mob…\r\n\r\n参考\r\ncn.mobx.js.org/github.com/b5156/mobx-…"}
{"title": "小程序  点击按钮后修改颜色(样式) ", "author": "Rolan", "pub_time": "2019-12-3 00:32", "content": "需实现的功能：点击按钮后，按钮的颜色会加深效果展示：原按钮 点击后按钮思路：给按钮设置一个点击事件，点击了按钮后，修改按钮的样式。代码：test.wxml文件 <view wx:if=\"{{sty==0}}\">  <view class=\"score\" style=\"background-color:{{score}};\" catchtap='score'>    <text>按钮一</text>  </view></view><view wx:if=\"{{sty==1}}\">  <view class=\"score\" style=\"background-color:{{score}};\" catchtap='score'>    <text>按钮一</text>  </view></view>test.js文件Page({  /*** 页面的初始数据*/  data: {    sty:0,    score: '#fff5df',   }, score: function (e) {   //点击按钮，样式改变   let that = this;   that.setData({     sty: 1,     score: 'rgba(252,178,22, 0.3)'   });  },)}test.css文件.score{  width:335rpx;  border-radius:10rpx 0rpx 0rpx 10rpx;}.score text{  color: #FCB216;}"}
{"title": "云开发如何实现管理员通知消息 ", "author": "Rolan", "pub_time": "2019-11-19 00:03", "content": "需求描述小程序目前的主要能力还都在小程序端实现，但是我们在进行开发的小程序不可能只有小程序端能力，我们也会有一些管理端能力。比如说，当用户在小程序中提交了消息以后，我们的小程序应该可以通知到小程序的管理员，以便让管理员进行下一步操作。解决方案架构说明由于小程序本身不支持长久性的消息通知能力，因此，我们可以考虑借助一些第三方的服务和能力，来完成我们自己的需求。这个需求很适合使用小程序新发布的 长期订阅消息 能力，但是目前该能力开放的类目还不足以支持我们的需要。一般而言，使用短信是我们目前到达率比较高的能力，且更为普遍的能力，其他通道的能力大多受限或不符合国情，为了确保通知信息的到达率，我们这篇文章就使用短信来完成需求。架构图示具体操作1. 开通腾讯云短信服务并获取配置信息我们想要发送短信，就需要先有一个短信服务，用于发送短信，这里我们可以使用腾讯云提供的云短信服务来发送短信。开通腾讯云短信，并创建应用首先，你需要访问 https://console.cloud.tencent... ,点击开通腾讯云·云短信。在开通完成后，点击界面中的【 添加应用 】，添加一个新的短信应用，你可以根据自己的实际情况，添加短信应用的名称和简介。获取 AppID、App Key添加完成后，点击你创建好的应用，进入到应用详情页,在应用的详情页中的应用信息栏目中，你可以找到 AppID 和 AppKey ，复制并保存这两个值，稍候我们会用到。2. 配置短信模板、短信签名开通了腾讯云短信服务以后，我们需要去创建短信模板，以及短信签名短信签名则是原来让收到短信的用户知道他所收到的短信来自于他的那一个服务，一般来说，设置为产品的品名。在腾讯云控制台中，进入到【云短信】控制台创建短信签名首先，点击【 国内短信 】，进入到短信的页面，点击【 创建签名 】，然后在弹出的窗口中输入你的签名的具体信息，比如这里我就是以公众号【程序百晓生】来创建签名。签名创建完成后，你需要等待腾讯云官方的审核，审核通过以后，你添加的签名才可以被使用。创建短信模板创建完签名，你需要创建一个短信的正文模板，用于发送短信。输入模板名称、短信类型，然后选择标准模板中的模板，这里我们选择“您有新的{1}订单，请注意查收！”这个模板。除了使用标准模板，你也可以自己编写一个模板，为了方便文章撰写，这里使用标准模板。然后点击提交，等待审核就可以了。3.编写云函数发送短信在完成了基础的配置后，我们在微信开发者工具中实现一个云函数，用于调用腾讯云的短信服务，实现具体的通知。首先，我们创建一个新的云函数，名为 notifyAdmin ，意为用于通知管理员的云函数。然后，选择我们刚刚创建的 notifyAdmin 云函数，在函数上右击，选择【在终端中打开】，进入到控制台，并输入如下命令，安装所需的短信 SDK。npm install --save sms-node-sdk然后，修改云函数的 index.js ，加入如下代码// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst {\r\n  SmsClient\r\n} = require('sms-node-sdk');\r\n\r\n\r\nconst AppID = 1400286810;  // SDK AppID是1400开头\r\n\r\n// 短信应用SDK AppKey ，替换为你自己的 AppKey\r\nconst AppKey = 'xxxx';\r\n\r\n// 需要发送短信的手机号码\r\nconst phoneNumber = '10000000';\r\n\r\n// 短信模板ID，需要在短信应用中申请\r\nconst templId = 476457;\r\n// 签名，替换为你自己申请的签名\r\nconst smsSign = '程序百晓生';\r\n\r\n// 实例化smsClient\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  let orderId = event.orderId;\r\n  let smsClient = new SmsClient({ AppID, AppKey });\r\n  return await smsClient.init({\r\n    action: 'SmsSingleSendTemplate',\r\n    data: {\r\n      nationCode: '86',\r\n      phoneNumber,\r\n      templId: templId,\r\n      params: [orderId],\r\n      sign: smsSign // 签名参数未提供或者为空时，会使用默认签名发送短信\r\n    }\r\n  })\r\n}完成代码的修改后，就可以部署你的云函数了，右键你的云函数，选择【上传并部署云函数：云端安装依赖】4. 在小程序端触发短信在前面我们提到，在一些特定的场景下，我们希望用户的操作可以给管理员发送消息通知。在具体的实现的时候，我们可以根据自己的实际业务需求，来设定我们的通知发送的条件，比如说，在用户支付成功后发送消息，则相关代码如下：let orderId = 'this is a orderId';\r\nwx.requestPayment({\r\n    success:res => {\r\n        console.log(\"User Payment Success\");\r\n        // 调用云函数发送短信\r\n        wx.cloud.callFunction({\r\n            name:\"notifyAdmin\",\r\n            data:{\r\n                orderId: orderId\r\n            }\r\n        });\r\n    }\r\n})总结经过本次的分享，我们了解到了如何借助短信服务，实现云开发的后台通知能力，实际上，除了短信服务，你还可以借助一些其他的工具，比如邮件、企业微信机器人等能力，实现后台管理信息的推送。明天，我们将分享 如何借助通过微信发送订单消息 。"}
{"title": "简单说说微信小程序的底层原理 ", "author": "Rolan", "pub_time": "2019-11-19 00:12", "content": "小程序选择了 Hybrid 的渲染方式，将UI渲染跟 JavaScript 的脚本执行分在了两个线程。双线程模型小程序的渲染层和逻辑层分别由两个线程管理：渲染层：界面渲染相关的任务全都在\tWebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个\tWebView 线程。逻辑层：采用\tJsCore 线程运行JS脚本，在这个环境下执行的都是有关小程序业务逻辑的代码。双线程之间的通信我们都知道小程序是避免DOM操作，而是采用数据驱动来渲染页面的，那么他到底是怎么通过更改数据来更新DOM呢。逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。在渲染层会把WNML转化成Js对象，Js对象会模拟DOM树逻辑层更新数据的时候，通过setData方法将数据从逻辑层转发到Native,Native再转发到渲染层这时候，比较两虚拟DOM树的差异，最后将差异应用到真实DOM树上，更新页面。Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。小程序的生命周期小程序的生命周期借鉴了Android的生命周期，如果你了解过Android的APP开发，那么理解小程序的就会很简单。界面线程有四大状态：初始化状态：初始化界面线程所需要的工作，包括工作机制，基本和我们开发者没有关系，等初始化完毕就向“服务线程”发送初始化完毕信号，然后进入等待传回初始化数据状态。首次渲染状态：收到“服务线程”发来的初始化数据后（就是 json和js中的data数据），就开始渲染小程序界面，渲染完毕后，发送“首次渲染完毕信号”给服务线程，并将页面展示给用户。持续渲染状态：此时界面线程继续一直等待“服务线程”通过this.setdata（）函数发送来的界面数据，只要收到就重新局部渲染，也因此只要更新数据并发送信号，界面就自动更新。结束状态：结束渲染。服务线程五大状态：初始化状态：无需和其他模块交流，跟小程序开发也没多大关联，此阶段就是启动服务线程所需的基本功能，比如信号发送模块。系统的初始化工作完毕，就调用自定义的onload和onshow， 然后等待界面线程的“界面线程初始化完成”信号。onload是只会首次渲染的时候执行一次，onshow是每次界面切换都会执行，简单理解，这就是唯一差别。等待激活状态：接收到“界面线程初始化完成”信号后，将初始化数据发送给“界面线程”，等待界面线程完成初次渲染。激活状态：收到界面线程发送来的“首次渲染完成”信号后，就进入激活状态既程序的正常运行状态，并调用自定义的onReady()函数。此状态下就可以通过 this.setData 函数发送界面数据给界面线程进行局部渲染，更新页面。后台运行状态：如果界面进入后台，服务线程就进入后台运行状态，从目前的官方解读来说，这个状态挺奇怪的，和激活状态是相同的，也可以通过setdata函数更新界面的。毕竟小程序的框架刚推出，应该后续会有很大不同吧。运行机制启动热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用\twx.getUpdateManager 做个检查更新的功能。"}
{"title": "使用Taro小程序框架开发一个学习做题聊天交流的微信小程序 ", "author": "Rolan", "pub_time": "2019-11-19 00:41", "content": "项目介绍当代大学生上课缺少积极性，学习缺乏效率。同为大学生的我深有体会。所以特别开发出这样一款学习类的微信小程序帮助学生进行学习、巩固知识，同时增加对战PK模块来加强学生们的学习积极性。这是一个为学生提供在线学习课程、题库练习、考试答题、做题PK、上课签到、资料查阅、成绩分析等功能的微信小程序希望大佬们走过路过给个star~技术选型前端：Taro + 微信小程序 + Echarts后端：Node.js + MySql + websocket其他：七牛云存储项目功能在线学习课程专项题库练习课程考试答题知识趣味竞赛上课签到系统专业资料查阅学生成绩分析运行截图1. 主页2. 个人中心3. 课程详情4. 做题练习5. 学习交流群6. 聊天室7. 课程列表8. 习题列表9. 排行榜10. 论坛项目分析项目采用前后端分离的技术，前端采用了Taro微信小程序框架，因为本人比较喜欢React，所以采用了Taro这款类React语法的框架，后端则采用了Node.js,koa2框架。聊天室页面采用websocket来进行连接今天，我们首先来聊一聊聊天室使用的小技巧（并不）首先我们的后端数据库采用的是mysql，我们建了一个聊天记录的表（萌新勿喷~）1. 后端部分数据库部分我们将所有的聊天记录存放到一张表上方便管理，因为我们有多个聊天群组，我们该如何区分这些不同的聊天群组呢？答案是，通过room_name来区分，获取聊天记录的时候就直接查询这个群组名即可，这样就不用开很多的表，将不同的群聊记录存放到不同的表中啦！同时因为我们的聊天记录内需要存储emoji等信息，所以，我们需要将数据库的字符集调整为 utf8mb4 -- UTF-8 Unicode ，排序规则选择 utf8mb4_unicode_ci ，这个可以通过自行百度，或者navicat中设置。然后我们将数据表以及字段类型也设置为 utf8mb4 ，便于存储emoji信息后端处理聊天记录的方法。router.get('/chatlog/:to', async (ctx) => {\r\n  const to = ctx.params.to\r\n  const response = []\r\n  const res = await query(`SELECT * FROM chatlog WHERE room_name = '${to}' ORDER BY current_time DESC`);\r\n  res.map((item, index) => {\r\n    const { room_name, user_name, user_avatar, current_time, message } = item\r\n    response[index] = {\r\n      to: room_name,\r\n      userName: user_name,\r\n      userAvatar: user_avatar,\r\n      currentTime: formatTime(current_time),\r\n      message,\r\n      messageId: `msg${current_time}${Math.ceil(Math.random() * 100)}`\r\n    }\r\n  })\r\n  ctx.response.body = parse(response)\r\n})这是获取指定群聊的后端接口，to代表的是群组名，使用get的方法即可获取到指定群聊的聊天记录啦！继续聊聊我们如何为所有连接到聊天室的网友们发送信息，这里我们采用的是广播的方式，不同于socket.io内已经封装好广播的方法，小程序规定只能使用websocket，所以我粗略的封装了一下广播（十分丑陋的代码）let onlineUserSocket = {}\r\nlet onlineUserInfo = {}\r\n\r\nconst handleLogin = (ws, socketMessage) => {\r\n  const { socketId, userName, userAvatar } = socketMessage\r\n  onlineUserSocket[socketId] = ws\r\n  onlineUserInfo[socketId] = { userName, userAvatar }\r\n  ws.socketId = socketId\r\n}\r\n\r\n// 广播消息\r\nconst broadcast = (message) => {\r\n  const { from, userName } = message\r\n  Object.values(onlineUserSocket).forEach((socket) => {\r\n    socket.send(JSON.stringify({\r\n      ...message,\r\n      isMyself: userName === onlineUserInfo[socket.socketId].userName\r\n    }))\r\n  })\r\n}我们再登录的时候，就将前端传来的消息存入对象中，以及他的socket对象，然后广播的时候就可以遍历所有的socket对象，为所有在线用户广播消息，其中的 isMyself 代表的是否为本人，例如我发的消息，自己的socket对象接受广播的时候就是 true 。别人的就是 false ，这样做是为了方便区分，自己的聊天消息和被人的聊天消息2. 前端部分接下来聊聊前端的聊天室部分handleSocketMessage(): void {\r\n    const { socketTask } = this\r\n    socketTask.onMessage(async ({ data }) => {\r\n      const messageInfo: ReceiveMessageInfo = JSON.parse(data)\r\n      const { to, messageId, isMyself, userName, userAvatar, currentTime, message } = messageInfo\r\n      const time: string = formatTime(currentTime)\r\n\r\n      this.messageList[to].push({\r\n        ...messageInfo,\r\n        currentTime: time\r\n      })\r\n      /* 设置群组最新消息 */\r\n      this.contactsList.filter(contacts => contacts.contactsId === to)[0].latestMessage = {\r\n        userName, message, currentTime: time\r\n      }\r\n      this.scrollViewId = isMyself ? messageId : ''\r\n      await Taro.request({\r\n        url: 'http://localhost:3000/chatlog',\r\n        method: 'PUT',\r\n        data: {\r\n          to,\r\n          userName,\r\n          userAvatar,\r\n          currentTime,\r\n          message,\r\n        }\r\n      })\r\n    })\r\n  }我们先接受消息，然后先更新指定群组名的聊天群组的聊天记录，然后再使用 PUT 的方式访问接口添加聊天记录到数据库中。可以看到我们的聊天记录是分为左边以及右边的，自己发的消息即为右边，我们可以通过简单的flex布局来实现// 这里是覆盖默认样式，显示自己消息的样式\r\n.myself {\r\n  justify-content: flex-end;\r\n\r\n  .avatar {\r\n    order: 1;\r\n  }\r\n\r\n  .info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: flex-end;\r\n\r\n    .header {\r\n      justify-content: flex-end;\r\n\r\n      .username {\r\n        order: 1;\r\n        margin-right: 0 !important;\r\n        margin-left: .5em;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      color: #333 !important;\r\n      border: #e7e7e7 1px solid;\r\n      background: #fff !important;\r\n      box-shadow: 0 8px 20px -8px #d7d7d7;\r\n    }\r\n  }\r\n}\r\n\r\n// 以下是默认样式，就是左边的样式\r\n.message-wrap {\r\n  display: flex;\r\n  margin: 20px 0;\r\n\r\n  .avatar {\r\n    width: 14vw;\r\n    height: 14vw;\r\n    margin: 10px;\r\n    border-radius: 50%;\r\n    background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%);\r\n  }\r\n\r\n  .info {\r\n\r\n    .header {\r\n      display: flex;\r\n      align-items: center;\r\n      max-width: 40vw;\r\n      padding: 10px 0;\r\n      color: #666;\r\n      font-size: .8em;\r\n\r\n      .username {\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n        max-width: 40vw;\r\n        margin-right: .5em;\r\n        color: #555;\r\n        font-size: 1.2em;\r\n        font-weight: bold;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      display: inline-block;\r\n      max-width: 60vw;\r\n      padding: 10px 20px;\r\n      color: #fff;\r\n      word-break: break-all;\r\n      border-radius: 20px;\r\n      background: #66a6ff;\r\n    }\r\n  }\r\n}最后我们聊一下websocket的断线重连handleSocketClose(): void {\r\n    const { socketTask } = this\r\n    socketTask.onClose((msg) => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('onClose: ', msg)\r\n    })\r\n  }\r\n\r\n  handleSocketError(): void {\r\n    const { socketTask } = this\r\n    socketTask.onError(() => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('Error!')\r\n    })\r\n  }我们这里先监听一下websocket关闭或者异常的情况，调用重连方法，以及清空socketTask的对象，接下来是重连的方法socketConnect() {\r\n    // 生成随机特有的socketId\r\n    this.generateSocketId()\r\n\r\n    /* 使用then的方法才能正确触发onOpen的方法，暂时不知道原因 */\r\n    Taro.connectSocket({\r\n      url: 'ws://localhost:3000',\r\n    }).then(task => {\r\n      this.socketTask = task\r\n      this.handleSocketOpen()\r\n      this.handleSocketMessage()\r\n      this.handleSocketClose()\r\n      this.handleSocketError()\r\n    })\r\n  }\r\n\r\n  socketReconnect(): void {\r\n    this.isReconnected = true\r\n    clearTimeout(this.timer)\r\n\r\n    /* 3s延迟重连，减轻压力 */\r\n    this.timer = setTimeout(() => {\r\n      this.socketConnect()\r\n    }, 3000)\r\n  }我们每三秒调用一遍socket连接的方法，重新再设置好socketId，以及socketTask，重新监听各种方法。这里有一个奇特的地方，就是Taro的connectSocket方法，不能使用 async/await 的方法来获取socketTask，也就是说不能这样 const socketTask = await Taro.connectSocket({...}) 来获取socketTask，只能通过then的方法才能获取到，卑微的我暂时不知道如何解决这个问题......具体后续请关注一下我的github，将持续更新项目！猛戳~"}
{"title": "开发|微信小程序与tensorflow.js准备工作 ", "author": "Rolan", "pub_time": "2019-11-20 00:01", "content": "本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述这篇文章主要讲解如何将 t ensorflow 与微信小程序结合，使得 t ensorflow 的模型能够在微信小程序上呈现出来。解决方案下载微信小程序稳定版，版本号最新的就行。新建一个小程序项目, AppID 必须是正式的没有可以注册一个。打开项目后点击右上角详情 — > 本地设置 - -> 调试基础库 -- > 选择最新版本并勾选使用 n pm 模块。打开以下网址，登录自己的小程序账号添加 t ensorflowJS 插件。安装 t ensorflowJS 库，安装 L TS 版本 ( 安装过程不需要配置，一直点下一步即可 )https://nodejs.org/en/安装成功后，打开 P owerShell( 管理员 ) ，如下图输入 node –version 和 npm –version 查看版本号检测是否安装成功接下来使用 n pm 安装 t fjs 所用的一些包先切换到小程序项目的目录下，输入 npm init 对环境进行初始化之后会要求输一些配置信息，没什么特别需求直接回车，最后输入 y es 即可分别安装以下包npm install @tensorflow/tfjs-corenpm install @tensorflow/tfjs-converternpm install fetch-wechat回到微信小程序页面，点击工具 -- > 构建 npm进入 p ackage.json 可以查看已经安装的包，每次新建项目都要重复初始化和安装包的操作删除一些微信小程序自带的代码， a pp.js 内的代码可以都删除。删除 Index.js 内的内容删除 l ogs 文件夹app.json 内指向 l ogs 的部分也删除 , 删除代码时前后相应的逗号别忘了删除，不然会报错。之后用代码导入包，进入之前添加 t ensorflowJS 插件的网页，下方有引入插件的代码及相关说明复制到 a pp . json 内，只复制红线部分复制红线内代码到 a pp.js之后用 t ensorflow 打印一个常量，检测是否能正常运行结语导入 tfjs 需要注意的地方基础库需要切换到2.7.0以上的版本（一般是最新版本）Npm 的初始化和安装需要在项目目录下操作每次安装 n pm 包之后，需要重新构建 n pmEND实习编辑   |   王文星责       编   |   马原涛 where2go 团队微信号： 算法与编程之美"}
{"title": "uni-app对微信小程序云函数的适配 ", "author": "Rolan", "pub_time": "2019-11-20 00:05", "content": "版权说明本文首发于个人博客-指尖魔法屋（www.thinkmoon.cn)。原文地址： uni-app对微信小程序云函数的适配引言熟悉uni-app的人应该都知道，uni-app并未对微信小程序云函数（本文统称云函数）进行相应的适配。但是，如果我们在某些业务场景的下需要使用云函数呢？我们知道，云函数可以复制到微信开发者工具，这样的话我们不得不每次编译一次就手动复制一次，不得不说麻烦至极。本文就问题做出以下解决方案。本文环境Hbuilder X微信开发者工具创建云函数目录首先，我们需要在uni-app项目文件夹下，创建一个云函数目录，路径随意，我这里是 functions 。然后先随便在里面放一些文件，这里以 new_file.css 为例。修改 manifest.json在uni-app根目录下，修改 manifest.json 中的微信小程序项，结构如下\"mp-weixin\" : {\r\n        /* 小程序特有相关 */\r\n        \"appid\" : \"wxd7de467f6e6cf741\",\r\n        \"cloudfunctionRoot\": \"./functions/\", // 这一行就是标记云函数目录的字段\r\n        \"setting\" : {\r\n            \"urlCheck\" : false\r\n        },\r\n        \"usingComponents\" : true\r\n    }编写 vue.config.jsvue.config.js\r\nconst path = require('path')\r\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\r\n\r\nmodule.exports = {\r\n    configureWebpack: {\r\n        plugins: [\r\n            new CopyWebpackPlugin([\r\n                {\r\n                    from: path.join(__dirname, 'functions'),\r\n                    to: path.join(__dirname, 'unpackage/dist', process.env.NODE_ENV === 'production' ? 'build' : 'dev', process.env.UNI_PLATFORM, 'functions')\r\n                }\r\n            ])\r\n        ]\r\n    }\r\n}编译运行发现提示如下内容说明未安装 copy-webpack-plugin 插件，我们手动安装一下。然后编译运行，发现微信开发者工具里面出现以下内容。截止目前，已打通Hbuilder X到微信开发者工具的自动复制，即已解决本文的核心内容。以下为进一步测试。创建云函数我们在云函数根目录上右键，在右键菜单中，可以选择创建一个新的 Node.js 云函数，我们将该云函数命名为check。开发者工具在本地创建出云函数目录和入口 index.js 文件，同时在线上环境中创建出对应的云函数。创建成功后，工具会提示是否立即本地安装依赖，确定后工具会自动安装 wx-server-sdk。我们会看到以下内容。创建好后将其同步复制到uni-app项目，即可为以后自动同步行方便，又可避免在输出文件夹中云函数的意外丢失。至此，相关文件编写工作转至 Hbuilder X ，云函数上传部署依旧在微信开发者工具。编写云函数默认的云函数只是一个返回用户基本数据的内容，我们将其修改至满足我们的业务需求，以内容安全云调用为例。在云函数文件中写入以下内容// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    console.log('待检测文本:' + event.content);\r\n    let result = await cloud.openapi.security.msgSecCheck({\r\n      content: event.content\r\n    })\r\n    console.log('result:' + JSON.stringify(result));\r\n\r\n    if (result && result.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: result\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: 'ok',\r\n        data: result\r\n      }\r\n    }\r\n\r\n  } catch (err) {\r\n    if (err.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    }\r\n    return {\r\n      code: 400,\r\n      msg: '调用security接口异常',\r\n      data: err\r\n    }\r\n  }\r\n}权限申明在函数目录下，创建一个 config.json ,文档说会自动创建，但是我实际操作时未自动创建。 config.json 内容如下。{\r\n    \"permissions\": {\r\n        \"openapi\": [\r\n            \"security.msgSecCheck\"\r\n        ]\r\n    }\r\n}然后在函数目录右键，上传并部署。小程序调用云函数wx.cloud.init()\r\n                wx.cloud.callFunction({\r\n                    name: 'check',\r\n                    data: {\r\n                        \"content\": this.contents.join()\r\n                    }\r\n                }).then(res => {\r\n                    console.log(res.result)\r\n                    if (res.result.code == 300) {\r\n                        uni.showModal({\r\n                            title: \"温馨提示\",\r\n                            content: \"你所输入的内容可能含有违法违规内容，不支持进行下一步操作\"\r\n                        })\r\n                        return\r\n                    } else {\r\n                        ... // 你要进行的操作\r\n                    }\r\n                })效果展示"}
{"title": "小程序 - 可搜索的地址选择 ", "author": "Rolan", "pub_time": "2019-11-20 00:41", "content": "最终实现效果：新建index文件夹index.wxml<!--pages/index/index.wxml--><view class='container'>  <view bindtap='onChangeAddress'>    <input value=\"{{address}}\" name=\"address\" placeholder=\"选择地点\">  </view></view>index.js// pages/index/index.jsPage({  data: {    address: ''  },  onChangeAddress() {    var _page = this;    wx.chooseLocation({      success: (res) => {        _page.setData({          address: res.name        });      },      fail: (err) => {        console.log(err);      }    });  }})新建map文件夹map.wxml<!--pages/map/map.wxml--><view class=\"container\">  <map    id=\"myMap\"    style=\"width: 100%; height: 100%;\"    latitude=\"{{latitude}}\"    longitude=\"{{longitude}}\"    markers=\"{{markers}}\"    show-location  ></map></view>map.js// pages/map/map.jsPage({  data: {    latitude: 31.22786,    longitude: 121.46658,    markers: [{      id: 1,      latitude: 31.22786,      longitude: 121.46658,      name: '上海招商局广场'    }]  },  onReady(e) {    this.mapCtx = wx.createMapContext('myMap')  }})"}
{"title": "微信小程序 模拟打电话 实践 ", "author": "Rolan", "pub_time": "2019-11-20 00:50", "content": "模拟电话模拟打电话功能，拨下指定的号码如10086，等待1.5秒后开始播放本地音频文件并计时。使用小程序官方API createInnerAudioContext()创建 InnerAudioContext对象。小程序官方推荐使用更为强大的音频上下文对象InnerAudioContext，官方已经停止了对组件的维护。上述这个demo效果的具体实现，如下代码：<template><view class=\"task\">  <view class=\"call\">    <!-- 顶部区域 -->    <view class=\"top\" wx:if=\"{{phone.length > 0}}\">      <view class=\"phone\">{{phone}}</view>      <view class=\"tip\" wx:if=\"{{calling}}\">        <view wx:if=\"{{tipShow}}\">正在呼叫...</view>        <view wx:else>{{formatMmSs}}</view>      </view>    </view>    <!-- 中间区域 -->    <view class=\"middle\">      <view class=\"nums\" wx:if=\"{{showNums}}\" @tap=\"numClick\">        <view class=\"row\">          <view class=\"num\" data-num='1'>1</view>          <view class=\"num\" data-num='2'>2</view>          <view class=\"num\" data-num='3'>3</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='4'>4</view>          <view class=\"num\" data-num='5'>5</view>          <view class=\"num\" data-num='6'>6</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='7'>7</view>          <view class=\"num\" data-num='8'>8</view>          <view class=\"num\" data-num='9'>9</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='*'>*</view>          <view class=\"num\" data-num='0'>0</view>          <view class=\"num\" data-num='#'>#</view>        </view>          </view>      <view class=\"icons\" wx:else>        <view class=\"icon\">          <image src=\"{{img.ringIcon1}}\"></image>          <view>静音</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon2}}\" @tap=\"handle('back')\"></image>          <view>拔号</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon3}}\"></image>          <view>免提</view>        </view>      </view>    </view>    <!-- 底部区域 -->    <view class=\"bottom\">      <image wx:if=\"{{!calling}}\" class=\"btn\" src=\"{{img.call}}\" @tap=\"handle('call')\"></image>      <image wx:else class=\"btn\" src=\"{{img.cancel}}\" @tap=\"handle('cancel')\"></image>      <image wx:if=\"{{!calling && phone.length>0}}\" class=\"del\" src=\"{{img.delete}}\" @tap=\"handle('delete')\"></image>    </view>  </view></view> </template><script>import wepy from 'wepy'import img from '@/assets'export default class Test extends wepy.page {  config = {    navigationBarTitleText: '模拟电话'  }  data = {    img: img,    phone: '',        // 10086    tipShow: false,   // 显示呼叫中    calling: false,   // 是否拔通电话    showNums: true,   // 显示数字面板    seconds: 0        // 计时  }  computed = {    // 通话计时 格式化    formatMmSs() {      return this.mmss(this.seconds)    }  }  // 格式化时间  mmss(count) {    count = count % 3600  // 不考虑 HH    let mm = Math.floor(count / 60)    let ss = count % 60    if (mm < 10) mm = '0' + mm    if (ss < 10) ss = '0' + ss    return mm + ':' + ss  }  onLoad() {    // 音频上下文    wepy.setInnerAudioOption({      mixWithOther: false,    // 终止其他应用或微信内的音乐      obeyMuteSwitch: false   // 在静音模式下，也能播放声音    })    let ctx = wepy.createInnerAudioContext()    ctx.src = '/assets/media/10086.mp3'    ctx.loop = true    ctx.onPlay(() => {      console.log('开始播放')    })    ctx.onError((res) => {      console.log(res.errMsg)    })    this.ctx = ctx  }  methods = {    // 点击数字    numClick(e) {      console.log(e)      console.log(e.target.dataset.num)      const num = e.target.dataset.num      this.phone = this.phone + num    },    handle(type) {      switch (type) {        case 'call':          // 拔打电话          if (this.phone !== '10086') {            wepy.showToast({ title: '请拔打10086', icon: 'none' })          } else {            this.calling = true            this.tipShow = true            // 延迟1.5秒后开始计时，并播放音频文件            setTimeout(() => {              this.ctx.play()              this.showNums = false              this.timer = setInterval(() => {                this.tipShow = false                this.seconds = this.seconds + 1                this.$apply()              }, 1000)            }, 1500)          }          break        case 'cancel':          // 挂掉电话          clearInterval(this.timer)          this.ctx.seek(0)          this.ctx.stop()          this.phone = ''          this.calling = false          this.showNums = true          this.seconds = 0          break        case 'delete':          // 删除电话号码的最后一位          let phone = this.phone          let arr = phone.split('')          arr.pop()          this.phone = arr.join('')          break        case 'back':          // 返回至数字键盘          this.showNums = true          break        default:          break      }    }  }}</script><style lang='less'>.task {  position: absolute;  top: 0;  bottom: 0;  left: 0;  right: 0;  overflow: hidden;  background: rgba(0, 0, 0, 1);  // 打电话区域  .call {    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 2;    .top {      position: absolute;      top: 48rpx;      left: 0;      right: 0;      color: #FDFDFD;      text-align: center;      .phone {        font-size: 72rpx;        line-height: 100rpx;      }      .tip {        font-size: 36rpx;        line-height: 54rpx;      }    }    .middle {      position: absolute;      top: 232rpx;      left: 0;      right: 0;      // 数字面板      .nums {        .row {          width: 540rpx;          margin: 0 auto;          height: 158rpx;          overflow: hidden;          .num {            float: left;            margin: 0 30rpx;            width: 120rpx;            height: 120rpx;            border-radius: 50%;            background:rgba(229,229,229,1);            text-align: center;            line-height: 120rpx;            font-size: 60rpx;            color: black;          }          .num:active {            background:rgba(229,229,229,0.5);          }        }      }      // 免提等      .icons {        margin: 0 auto;        width: 540rpx;        height: 250rpx;        overflow: hidden;        padding-top: 196rpx;        .icon {          float: left;          width: 120rpx;          margin: 0 30rpx;          &>image {            display: block;            width: 120rpx;            height: 120rpx;            border-radius: 50%;          }          &>image:active {            opacity: 0.7;          }          &>view {            font-size: 32rpx;            color: #FDFDFD;            text-align: center;            line-height: 68rpx;          }        }      }    }    .bottom {      position: absolute;      top: 940rpx;      left: 0;      right: 0;      text-align: center;      .btn {        display: inline-block;        width: 120rpx;        height: 120rpx;        border-radius: 50%;      }      .del {        display: inline-block;        width: 75rpx;        height: 56rpx;        position: absolute;        top: 46rpx;        right: 138rpx;      }      .btn:active {        opacity: 0.7;      }      .del:active {        opacity: 0.7;      }    }  }}</style>"}
{"title": "在腾讯Q3财报中站C位的品牌小程序，BAT态度大不同！ ", "author": "Rolan", "pub_time": "2019-11-22 00:12", "content": "昨天，腾讯2019年Q3财报如“约”而至。其中，小程序数据格外亮眼，不仅日活跃用户超过3亿，商业化也表现强劲，中长尾小程序日均商业交易笔数同比增加超过一倍。值得注意的是，这组数据中，“品牌”二字尤其“夺目”，财报显示：品牌自营类小程序数量同比增长1倍以上；8%的品牌自营类小程序交易额同比增长100倍以上、56%的品牌自营类小程序交易额同比增长50%以上，在头部领跑下，中腰部正在崛起；超过1亿人次访问品牌自营类小程序。这一定程度上说明了越来越多的品牌选择了微信小程序作为重要阵地。因此，要让用户在众多品牌中一眼就能发现自己，品牌曝光是首要环节。对于企业而言，如果没做好品牌曝光，自家品牌就会淹没在“芸芸众生”之中，而这一局面，在搜索场景下尤为突出。比如，用户输入一个关键词，结果“数不胜数”，无论用户看多少眼，也不一定会注意到。于是，BAT三巨头接踵而至地基于自家搜索推出一个能力：品牌主页。直白点说，“品牌主页”就是：在搜索结果页中，将企业各类信息与服务放在一起整体展示，比如企业认证信息、小程序、服务等等，入口更直接。微信“品牌主页”叫作品牌官方区，于去年4月基于搜一搜推出，在公众号后台便可开通；相比之下，支付宝与百度则慢了好几拍，都是最近才推出小程序能力，前者叫品牌直达，后者称百度品牌名片。虽然叫法不同（以下统称时，称为“品牌主页”），但其目的是一致的，都是为了帮助企业更好地建立品牌效应、将服务充分触达用户，从而提升收益。但BAT三平台的属性不同，“品牌主页”的能力开放程度、玩法等也有所差异，并非都能满足所有企业的需求，企业们在选择上也就“不知所云”。对此，晓程序观察（yinghoo-tech）就来一次测评与PK，帮助企业们选择适合自己的“品牌主页”。1流量曝光：微信品牌官方区完胜？既然“品牌主页”是用来帮助企业更好地触达用户，对于企业与品牌而言，最关心的还是流量，比如：用户输入哪些关键词，才能直达“品牌主页”？如果品牌名称输入错误，“品牌主页”能不能显示？“品牌主页”在搜索结果中是怎么排序的？实际上，对于搜索平台来说，这些都是影响流量曝光不可忽略的因素。流量曝光第一环：入口微信：三种样式、三种入口，A级最突出在搜一搜的搜索结果页中，微信品牌官方区的有三种展示样式，如图，依次为A、B、C三种：A级与B级的品牌官方区可以添加公众号、小程序、服务和商品；C级样式仅允许将公众号展示。此外，A级与B级都有品牌详情页，C级样式并没有。在众多搜索结果中，A级样式会有一种“鹤立鸡群”的感觉，更容易建立品牌认知，尤其是小程序、公众号、服务、商品等都是卡片形式，入口更加“抢眼”。不过，A级样式并不是所有品牌都能开通的，三种样式各有不同的门槛。如图，要求中包括公众号与官方区点击量、是否有微信认证与商标认证、公众号注册时间等条件。值得注意的是，开通A级样式还有推广搜一搜的要求，即品牌主在投放广告时或在自有宣传渠道上，要有“微信搜一搜”搜索框露出。线上线下渠道都可以，比如：电梯间广告、户外大屏广告、易拉宝、门店宣传、自有小程序曝光、公众号文章广告、朋友圈广告等等。 支付宝&百度：品牌主页没有特殊展示，入口很“隐蔽”相较于微信官方区，支付宝品牌直达与百度品牌名片的样式则显得尤为“简陋”。展示上，支付宝品牌直达与其他搜索结果并无差别，而百度品牌名片本身即是一个小程序。所以，在入口上，支付宝品牌直达与百度品牌名片都不够突出。对于企业来说，“品牌主页”的作用，就是为了让用户在众多搜索结果中一眼就能看到自家品牌，而“与众不同”的样式，入口也就更“夺目”，这一点，微信官方区是合格的。从品牌曝光来看，支付宝与百度的“品牌主页”在入口上都没有明显优势。如此看来，微信品牌官方区完胜。流量曝光第二环：关键词配置对比完三家“品牌主页”的样式，再来看关键词配置。毕竟，用户输入什么关键词，才能将“品牌主页”搜索出来才是最重要的。微信：级别越高，可配置关键词数量越多刚刚提到，微信品牌官方区有A、B、C三种不同级别。所以，可配置的关键词数量也是不一样的，分别为5个、3个、1个。所以，这对企业来说，可操作空间不大，但仍旧需要将与品牌相关的常见关键词都加上。比如，开通A级官方区的“同程旅游网”，其相关的关键词有同程旅游、同程、同程艺龙等，但晓程序观察（yinghoo-tech）测试后发现，输入“同程艺龙”，并不会出现“同程旅游网”品牌官方区，说明其没有配置关键词“同程艺龙”。同样的问题，也出现在开通B级官方区的“麦当劳”上，搜索英文名称McDonald，就不会出现其品牌官方区。支付宝&百度：“关键词要与品牌名称完全一致”支付宝品牌直达与百度品牌名片的关键词完全不用主动配置，但是，对企业、对用户都极其不友好。因为，只有在用户精确搜索品牌词时，搜索结果中才会出现“品牌主页”。百度品牌名片更甚，据百度官方介绍，用户需要输入“品牌名+品牌名片”（如齐家网品牌名片），或者输入开发者在后台填写的企业全称。对此，晓程序观察也测试了一番，输入“齐家网”后，在搜索结果中，整个第一页都没有看到“齐家网品牌名片”的身影。因此，在“品牌主页”的关键词配置上，微信有一定的运营空间，而百度与支付宝则完全没有。流量曝光第三环：搜索排名对于搜索平台的逻辑来说，决定流量价值的，除了关键词，当然就是搜索结果页排名了。BAT三家“品牌主页”的排名规则，又有什么不一样？微信：“品牌主页”始终占据首位在搜一搜结果页中，微信官方区始终是以首位展示。比如，输入“同程”后，结果页中排在第一位的便是“同程旅游网”品牌官方区，而后才是文章、公众号、小程序、朋友圈等内容。当然前提是，需要针对特定搜索词才能保证官方区首位展示。不同级别的官方区，指定关键词数量也是不一样的。此外，搜索词申请也有一定的要求：须为品牌词汇：针对通用词汇，比如汉堡、保险等，不开放置顶申请；须具有品牌独占性：针对非品牌独占词汇，比如阿拉丁等，不开放置顶申请。支付宝：可通过运营手段来提升搜索排名相比于微信官方区首位展示，支付宝品牌直达的搜索排名则由算法决定。算法维度主要包括：搜索结果中品牌直达的访问和点击用户数、开通品牌直达后搜索带来的增量用户数等，而这些数据都可以利用运营手段来提升。需要注意的是，支付宝品牌直达内包括了小程序、生活号等内容；所以，企业们只需运营品牌直达即可，这样便能同时提升小程序与生活号的排名竞争力。比如，在运营活动中，就可以引导用户“上支付宝搜XXX”，从而改善搜索UV、搜索UV增量数据。百度：广告排在品牌主页前面作为一个搜索引擎平台，百度品牌名片的排名同样根据算法得到，至于逻辑目前还不太清楚。不过，据我们的测试来看，百度品牌名片并不会排在首位，“取而代之”的则是与关键词相关的广告内容。如图，输入“齐家网品牌名片”之后，出现在首位是与齐家网毫无关系的广告内容。综上，微信官方区首位展示，显然是最能帮助企业实现品牌曝光的。而支付宝与百度，还需要开发者在运营规范中自行摸索算法。比如，支付宝品牌直达的搜索UV就是其算法中一个很重要的因素。2在至关重要的拉新与转化上百度输了？对于企业而言，“品牌主页”能带来流量曝光是远远不够的，其更加看重的，仍是拉新与转化。这一点，目前只有微信品牌官方区与支付宝品牌直达能够做到。事实上，BAT三家“品牌主页”看似差别不大，都可以在“品牌主页”内添加小程序等入口，但在拉新与转化上，百度则略逊一筹。原因是微信与支付宝“品牌主页”具备以下两个能力：1.可在品牌主页内直接添加服务与商品在微信与支付宝的“品牌主页”内，开发者能够配置其小程序的服务或商品。品牌在搜索结果页中就能直接触达用户，转化能力更强。用户点击服务或商品后，落地页都是品牌关联的小程序，比如，在NIKE的微信品牌官方区内，点击商品，进入的就是“Nike耐克”小程序的商品详情页。目前，微信品牌官方区最多可在搜索结果页展示4个服务与3个商品；而支付宝品牌直达，仅可添加1-2个小程序服务。2.品牌主页可与功能直达打通在微信与支付宝“品牌主页”中，可与“功能直达”打通，也是其一项重要开放能力。（关于BAT三家功能直达，我们此前已有过测评对比，请点击阅读）在微信搜一搜中，品牌官方区的服务和商品也会出现在相关搜索结果中，拥有更多曝光；同样，用户在支付宝搜索的关键词与某功能关键词匹配时，便会触发功能直达，小程序内的服务便可直接出现在结果页中。相比之下，百度不仅在搜索结果页没有服务入口，在品牌详情页内也不可添加小程序内某个服务，目前只能起到展示作用。综上，无论是“品牌主页”样式，还是流量曝光，微信官方区都要更加完善；而支付宝与百度则处于刚刚起步的阶段，尤其是百度品牌名片，并没有将百度的搜索价值利用至最大化。那么，企业开发者们，BAT三家“品牌名片”，你们会怎么运营？欢迎留言哦~"}
{"title": "微信-小程序开发基础知识笔记 ", "author": "Rolan", "pub_time": "2019-11-22 00:41", "content": "绑定事件的方法：1.bindtab和catchtab，catchtab可以阻止事件冒泡\r\n<view bindtap='onClick'></view>\r\n\r\n<view catchtap='onClick'></view>\r\n2.互斥事件绑定 mut-bind一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。在想要规定冒泡区间时可以用到。\r\n<view mut-bind:tap='onClick'></view>\r\n在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点\r\n<view mark:myMark=\"last\" bindtap=\"bindViewTap\">\r\n\r\n<button mark:anotherMark=\"leaf\" bindtap=\"bindButtonTap\">按钮</button>\r\n\r\n</view>\r\n在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。\r\nPage({\r\n\r\nbindViewTap: function(e) {\r\n\r\ne.mark.myMark === \"last\" // true\r\n\r\ne.mark.anotherMark === \"leaf\" // true\r\n\r\n}\r\n\r\n})\r\nmark 和 dataset 很相似，主要区别在于：1.mark可以冒泡，如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。2.在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark。3.不同于 dataset ，节点的 mark 不会做连字符和大小写转换。.wxs文件的应用个人理解 .wxs文件就相当于cocos的prefab。执行起来比js性能要快。但是wxs是一门语言，平行于JavaScript。wxs基础语法有频繁用户交互的效果在小程序上表现是比较卡顿的，这时建议使用wxs，为什么？因为小程序分为视图层和逻辑层，比如需要拖动的功能，touchmove事件从视图层抛到逻辑层，逻辑层经过处理，通过this.setData到视图层。1. 一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。2. 此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 很方便。代码示例：\r\nvar wxsFunction = function(event, ownerInstance) {\r\n\r\nvar instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例\r\n\r\ninstance.setStyle({\r\n\r\n\"font-size\": \"14px\" // 支持rpx\r\n\r\n})\r\n\r\ninstance.getDataset()\r\n\r\ninstance.setClass(className)\r\n\r\n// ...\r\n\r\nreturn false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault\r\n\r\n}\r\n自定义组件上边在分析复杂交互时我们知道，频繁的调用this.setData会使页面卡顿，甚至导致小程序僵死。那么不想写或者说不会写wxs的开发者该怎么办呢？此时可以通过将页面的 setData 改为 自定义组件 中的 setData 来提升性能。原因：自定义组件中的setData不会进行深复制。（深复制会在这个值被组件间传递时才发生）自定义组件的规范1.在组件wxss中不应使用ID选择器、属性选择器和标签名选择器，就只使用class选择器准没错。2.在自定义组件的 js 文件中，需要使用 Component() 来注册组件。3.使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。4.自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。5.<slot></slot>相当于react的this.props.children。\r\n<!-- component-tag-name组件 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<view>这里是组件的内部节点</view>\r\n\r\n<slot></slot>\r\n\r\n</view>\r\n\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n\r\n<view>这里是插入到组件slot中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n6.默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用。\r\nComponent({\r\n\r\noptions: {\r\n\r\nmultipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n\r\n},\r\n\r\nproperties: { /\\* ... \\*/ },\r\n\r\nmethods: { /\\* ... \\*/ }\r\n\r\n})\r\n此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分。\r\n<!-- 组件模板 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<slot name=\"before\"></slot>\r\n\r\n<view>这里是组件的内部细节</view>\r\n\r\n<slot name=\"after\"></slot>\r\n\r\n</view>\r\n使用时，用 slot 属性来将节点插入到不同的slot上。\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"before\"> 的位置上 -->\r\n\r\n<view slot=\"before\">这里是插入到组件slot name=\"before\"中的内容</view>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"after\"> 的位置上 -->\r\n\r\n<view slot=\"after\">这里是插入到组件slot name=\"after\"中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n7.设置自定义组件的捕获和冒泡机制需要使用 triggerEvent 方法。\r\n// 组件 my-component.js\r\n\r\nComponent({\r\n\r\nmethods: {\r\n\r\nonTap: function(){\r\n\r\nthis.triggerEvent('customevent', {}, { bubbles: true, composed: true })\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的behaviors个人理解：多个页面可能会共用一个功能，这个功能抽象后称为组件。多个组件共用一个方法或者多个方法，这类方法的集合称为behaviors。就tm理解成高阶组件就完了。组件间关系relations官方说：有时需要实现这样的组件：\r\n<custom-ul>\r\n\r\n<custom-li> item 1 </custom-li>\r\n\r\n<custom-li> item 2 </custom-li>\r\n\r\n</custom-ul>\r\n说custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。具体怎么个复杂需要单独拎出来一个ralations属性来处理，咱也不知道。使用方法：\r\n// path/to/custom-ul.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-li': {\r\n\r\ntype: 'child', // 关联的目标节点应为子节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n},\r\n\r\n// path/to/custom-li.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-ul': {\r\n\r\ntype: 'parent', // 关联的目标节点应为父节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n注意：必须在两个组件定义中都加入relations定义，否则不会生效。还有一种情况，如果你两个自定义组件都用了相同的behaviors，你可以使用这个behavior来代替组件路径作为关联的目标节点。\r\n// path/to/custom-form.js\r\n\r\nvar customFormControls = require('./custom-form-controls')\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'customFormControls': {\r\n\r\ntype: 'descendant', // 关联的目标节点应为子孙节点\r\n\r\ntarget: customFormControls\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的observers官方定义他叫数据监听器，呵呵。使用方法：\r\nComponent({\r\n\r\nattached: function() {\r\n\r\nthis.setData({\r\n\r\nnumberA: 1,\r\n\r\nnumberB: 2,\r\n\r\n})\r\n\r\n},\r\n\r\nobservers: {\r\n\r\n'numberA, numberB': function(numberA, numberB) {\r\n\r\n// 在 numberA 或者 numberB 被设置时，执行这个函数\r\n\r\nthis.setData({\r\n\r\nsum: numberA + numberB\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n如果需要监听所有子数据字段的变化，可以使用通配符 。\r\nComponent({\r\n\r\nobservers: {\r\n\r\n'some.field.**': function(field) {\r\n\r\n// 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发\r\n\r\n// （除此以外，使用 setData 设置 this.data.some 也会触发）\r\n\r\nfield === this.data.some.field\r\n\r\n},\r\n\r\n},\r\n\r\nattached: function() {\r\n\r\n// 这样会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样也会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field.xxx': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样还是会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some': { /* ... */ }\r\n\r\n})\r\n\r\n}\r\n\r\n})\r\n特别地，仅使用通配符 可以监听全部 setData 。**纯数据字段就是局部变量，不参与渲染，也不会传递。官方说这样声明后再用能提高性能，要不我才不用。使用方式：\r\nComponent({\r\n\r\noptions: {\r\n\r\npureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段\r\n\r\n},\r\n\r\ndata: {\r\n\r\na: true, // 普通数据字段\r\n\r\n_b: true, // 纯数据字段\r\n\r\n},\r\n\r\nmethods: {\r\n\r\nmyMethod() {\r\n\r\nthis.data._b // 纯数据字段可以在 this.data 中获取\r\n\r\nthis.setData({\r\n\r\nc: true, // 普通数据字段\r\n\r\n_d: true, // 纯数据字段\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n抽象节点又一个新名词，呵呵呵。说白了就是有一个父容器组件A，因为条件不同有可能A中会渲染组件B，也可能渲染组件C。举个例子，当页面需要单选和多选组件的时候,方法1是按条件引用两个封装好的组件（<单选/>，</多选>），方法2是你也可以只引用一个组件<啦啦啦/>，只不过这个<啦啦啦/>组件去帮你按需渲染<单选/>或者<多选/>。需要在父容器组件A的.json文件声明：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": true\r\n\r\n}\r\n\r\n}\r\n在使用组件时，必须指定父组件具体是渲染哪个子组件：<啦啦啦 generic:selectable=\"单选\" /><啦啦啦 generic:selectable=\"多选\" />在页面的.json文件<啦啦啦/>，<单选/>，<多选/>都要引用。代码\r\n//page下页面的.json文件中\r\n\r\n{\r\n\r\n\"usingComponents\": {\r\n\r\n\"啦啦啦\": \"path/*/*\",\r\n\r\n\"多选\": \"*/checkbox\",\r\n\r\n\"单选\": \"*/radio\"\r\n\r\n}\r\n\r\n}\r\n当然，你也可以在容器组件.json中指定默认用哪个组件：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": {\r\n\r\n\"default\": \"*/checkbox\"// 多选\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n计算属性今天真是开眼了，学到了这么多新词汇。。( 计算属性的作用）：是为了解决HTML代码中复杂的js代码（HTML代码中可以嵌套js代码），把复杂的js代码通过计算属性来解决这是计算属性的应用？？？ 听着词这么厉害干这事真是大才小用了。计算属性会使用缓存机制，如果这个数据的值没有改变，则计算属性将不会调用方法这点应该是它实际有价值的地方。实现原理很简单，就是对已有的 setData 进行二次封装，在每次 setData 的时候计算出 computed 里各字段的值，这期间可以增加缓存机制，属性值没有变化的复用。自定义组件拓展在react中想拓展一个组件怎么办，会用高阶组件。小程序中，自然是使用behaviors。\r\n// behavior.js\r\n\r\nmodule.exports = Behavior({\r\n\r\ndefinitionFilter(defFields) {\r\n\r\ndefFields.data.from = 'behavior'\r\n\r\n},\r\n\r\n})\r\n\r\n// component.js\r\n\r\nComponent({\r\n\r\ndata: {\r\n\r\nfrom: 'component'\r\n\r\n},\r\n\r\nbehaviors: [require('behavior.js')],\r\n\r\nready() {\r\n\r\nconsole.log(this.data.from) // 此处会发现输出 behavior 而不是 component\r\n\r\n}\r\n\r\n})\r\nBehavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。"}
{"title": "uniapp登录流程详解uni.login ", "author": "Rolan", "pub_time": "2019-11-25 00:16", "content": "uni.login(OBJECT)登录H5平台登陆注意事项：微信内嵌浏览器运行H5版时，可通过js sdk实现微信登陆，需要引入一个单独的js，详见普通浏览器上实现微信登陆，并非开放API，需要向微信申请，仅个别开发者有此权限H5平台的其他登陆，比如QQ登陆、微博登陆，uni-app未封装，请在条件编译里按普通H5写法编写。OBJECT 参数说明参数名 类型 必填 说明 平台差异说明provider String 否 登录服务提供商，通过 uni.getProvider 获取，如果不设置则弹出登录列表选择界面scopes String/Array 见平台差异说明 授权类型，默认 auth_base。支持 auth_base（静默授权）/ auth_user（主动授权） / auth_zhima（芝麻信用） 支付宝小程序timeout Number 否 超时时间，单位ms 微信小程序、百度小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）success 返回参数说明参数名 说明authResult 登录服务商提供的登录信息，服务商不同返回的结果不完全相同errMsg 描述信息uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n  }\r\n});uni.checkSession检查登录状态是否过期属性 类型 必填 说明success function 否 接口调用成功的回调函数fail function 否 接口调用失败的回调函数complete function 否 接口调用结束的回调函数（调用成功、失败都会执行）uni.getUserInfo(OBJECT)获取用户信息。UNI-APP 开发微信公众号（H5）JSSDK 的使用方式在 uniapp 中可以使用模块方式引用微信 js-sdk ，微信官网直接下载的使用有问题，可以使用 jweixin-module。安装下载使用方式下载地址： https://unpkg.com/jweixin-mod...使用、var jweixin = require('jweixin-module')  \r\njweixin.ready(function(){  \r\n    // TODO  \r\n});一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq....provider String 否 登录服务提供商，通过 uni.getProvider 获取withCredentials Boolean 否 是否带上登录态信息。 微信小程序、头条小程序lang Number 否 指定返回用户信息的语言，默认为 en。更多值请参考下面的说明。 微信小程序timeout Number 否 超时时间，单位 ms。 微信小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）userInfo 参数说明参数 类型 说明 平台差异说明nickName String 用户昵称openId String 该服务商唯一用户标识 5+AppavatarUrl String 用户头像uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n    // 获取用户信息\r\n    uni.getUserInfo({\r\n      provider: 'weixin',\r\n      success: function (infoRes) {\r\n        console.log('用户昵称为：' + infoRes.userInfo.nickName);\r\n      }\r\n    });\r\n  }\r\n});说明：调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。注意：会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次uni.getProvider(OBJECT)获取服务供应商。仅App平台支持。在App平台，可用的服务商，是打包环境中配置的服务商，与手机端安装了什么app没有关系。云打包在manifest中配置相关模块和SDK信息，离线打包在原生工程中配置。某个服务商配置被打包进去，运行时就能得到相应的服务供应商。关于目前文章内容即涉及前端，PHP知识点，如果有兴趣即可关注，很荣幸，能被您发现，真是慧眼识英！也感谢您的关注，在未来的日子里，希望能够一直默默的支持我，我也会努力写出更多优秀的作品。我们一起成长，从零基础学编程，将 Web前端领域、数据结构与算法、网络原理等通俗易懂的呈现给小伙伴。分享 Web 前端相关的技术文章、工具资源、精选课程、热点资讯。若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。请点赞！因为你们的赞同/鼓励是我写作的最大动力！"}
{"title": "小程序云开发：菜鸟也能全栈做产品 ", "author": "Rolan", "pub_time": "2019-11-25 00:25", "content": "我想独立实现一个全栈产品为什么这么难#日常生活中，我们会使用很多软件产品。在使用这些产品的时候，我们看得见的东西称为“前端界面”如一个输入框、一个按钮，点击按钮之后发生的一切看不见的东西称为“后端服务”。与之对应的创造者分别称为“前端程序员”、“后端程序员”，然而，一个完整产品的开发不仅仅是只有前端和后端，还有设计师，架构师，运维等。有没有可能这些所有的事情都一个人干呢？有可能，事实上如今就有很多的“全栈工程师”，他们身兼数职，是多面手。能独立完成一个产品的方方面面。这种人固然十分了得，他们通常具有多年的经验，涉猎广泛，是老手，也是高手，当有一个产品想法的时候，他们可以用自己的全面专业技能，尽情的发挥去实现自己的想法。所以，从某种意义上讲“全栈也是一种自由”，你可以自由的实现你的想法，这简直太美妙了！然而，很多时候当我们有一个产品想法的时候，我们往往发现，前端写完了，后端怎么搞？数据库怎么搞？域名怎么搞？域名还要备案？应用部署怎么搞？我的买什么样的服务器啊？静态资源 CDN 怎么搞？文件上传服务器怎么搞？万一访问用户多了能撑住吗？等等……问题很多，导致你的一个个想法，都只是在脑海中昙花一现，从来都无法将她们实现，或者说你激情饱满的实现了其中自己最擅长的一部分，当碰到其他难题的时候就止步了。于是仰天长啸：我就想独立做一个完整的产品为什么这么难？年轻人，这一切都不怪你……破局：小程序云开发#为什么使用小程序云开发来破局？#为啥是用“小程序云开发”来破局？首先，我们的目的是全栈实现一个产品。全栈可以有多种技术方案，你可用任何你能会的技能来达到全栈的目的。你可以开发安卓，IOS，或者 PC 站，然而小程序是最实际的！为啥？手机上能做的事情为啥要用 PC 版？OK,既然手机版比较好，那能不能再简单一点？能，就是小程序，不需要开发IOS，安卓两个版本。可以快速产出，快速试错。其次，前面说到了，全栈实现一个产品并不容易，对很多人来说甚至是巨难！选择了小程序已经是比较划算的方案。而再集成云开发，全栈立马就有了。这就是为什么选择“小程序云开发”来破局。小程序云开发是什么?#小程序云开发是什么？官方文档是这么说的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。看完上面的描述，也许你仍然无法非常清楚的知道什么是“小程序云开发”，没关系，你只需要注意加粗的部分，大概知道它“无需搭建服务器”，从传统观念将，这个似乎“毁三观”咋可能没服务器啊？是的，可以没有传统意义上的服务器，这种模式是 serveless 的。那么，小程序云开发提供了哪些东西来破局呢？且看下面的表格：能 力作 用说 明云函数无需自建服务器在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库无需自建数据库一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储无需自建存储和 CDN在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理云调用原生微信服务集成基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力上面的表格中提到了“云开发”中的一些能力：“云函数”，“数据库”，“存储”，“云调用”，我们可以将这些词带入你曾经开发过的应用，看看它们分别代表了哪些部分。对于程序员来说，如果有疑问的话，没有什么是一个 helloword 解决不了的。实战：独立开发一个简易的零售小程序#哆嗦再多，不如实战。下面我们就来使用小程序云开发实现一个简单的零售小程序。项目构思#既然是一个零售小程序，那么我们可以思考一下零售小程序的大致业务流程，以及粗略的梳理一下，其功能点。现根据自己的想法，大致画一下草图，如果没有灵感可以参考一下别的 APP 是如何设计的。我根据自己的想法设计之后是这样的：功能模块：首页，商品列表页，购物车，确认订单，个人中心，个人订单，管你模块（商品添加，分类添加）其中商品需要上传图片。梳理完功能之后，我们对于要实现的东西已经有个初步的概念了。接下来，我们需要大概画一下页面设计、及功能流转。初次设计可能没有太多经验，没关系，开始做就行了，做着做着就会想法越来越多，然后优化的越来越好。。我也是经过了多番修改调整，最终找到了一些思路。我的（拙劣）设计如下，图片如果看不清楚可复制图片链接在新窗口打开查看：说明，以上图片是根据成品（我真的开发了一个云小程序并上线使用了）截图的，而实际我再设计的时候也是经过几番修改才最终定成这样。同时，补充说明一下，这里前端页面使用的是 vant-weapp控件，非常好用。推荐！如果你和我一样是一个纯后端程序员，建议使用 vant-weapp 来作为 ui，非常方便。否则自己写页面样式的话可能就做不出来了。全栈不是那么好干的啊。选择自己能驾驭的，能实现最终功能，就是一个合格的全栈。创建小程序云开发项目#我们先下载微信小程序开发工具，下载地址在这里,安装好了之后，新建项目，界面如下，APPID 需要你自己去注册一个。然后注意，选择“小程序云开发”，如下图所示：创建好了之后，项目目录如下,先看 1 标注的地方：如果你曾经有过小程序的开发经验，那么miniprogram文件夹下面的结构你肯定熟悉了，miniprogram下面的子目录分别是小程序对应的组件、图片、页面、样式以及app.js,app.json,sitemap.json,其中components下面的vant-weapp就是上面提到的 ui 组件。最后一个比较重要的文件夹就是cloudfunctions，这个目录是用来存放“云函数的”，云函数就是我们的后端。每一个云函数提供一个服务。一个个的云函数组成了我们整体的后端服务。云函数可以看做是 FaaS（function as a service）。途中，2 标记的位置的“云开发”按钮，我们点进去，就可以看到“云开发的控制台”，如下图所示：如果上图看不清楚，可以复制链接到新的浏览器窗口查看，如图，小程序云开发默认的免费套餐有一定的额度可供使用。首页便是使用统计。然后我们能看到，有“数据库”，“存储”，“云函数”。这里的“数据库”其实就是类似于一个 MongoDB，你可以点进去创建一个个的 collection（即：关系型数据库中的table）;这里的“存储”其实就是“文件夹”，我们可以通过微信提供的 api把图片上传到“存储”中；这里的“云函数”就是我们需要实现的后端业务逻辑，他就是一个个的函数（函数由我们自己写好后上传）。一般开发过程中我们在开发者工具中的cloudfunctions目录下创建云函数（比方说是:user-add）开发完成之后在云函数目录点击右键——上传即可。然后就可以在小程序的代码中调用这个user-add云函数。云开发之——3 分钟实现文件上传#注意：在开始云开发之前，我们现在 小程序代码的 app.js 中加入wx.cloud.init,如下：CopyApp({\r\n  onLaunch: function () {\r\n    if (!wx.cloud) {\r\n      console.error('请使用 2.2.3 或以上的基础库以使用云能力')\r\n    } else {\r\n      wx.cloud.init({\r\n        // env 参数说明：\r\n        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源\r\n        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看\r\n        //   如不填则使用默认环境（第一个创建的环境）\r\n        env: 'your-env-id',\r\n        traceUser: true,\r\n      })\r\n    }\r\n    this.globalData = {}\r\n  }\r\n})上面的图中，我们已经看到了“商品添加”页面的效果，它需要我们输入商品名称、价格、并上传图片，然后保存。传统架构中，上传图片需要前端页面摆一个控件，然后后端提供一个 api用来接收前端传来的文件，通常来说这个后端 api 接收到图片之后，会将图片文件保存到自己的文件服务器或者是阿里云存储、或者是七牛云存储之类的。然后返回给你一个文件链接地址。非常麻烦，然而，小程序云开发上传文件超级简单，上代码：Copy页面代码：\r\n<van-notice-bar\r\n  scrollable=\"false\"\r\n  text=\"发布商品\"\r\n/>\r\n  <van-field\r\n    value=\"{{ productName }}\"\r\n    required\r\n    clearable\r\n    label=\"商品名称\"\r\n    placeholder=\"请输入商品名称\"\r\n    bind:change=\"inputName\"\r\n  />\r\n    <van-field\r\n    value=\"{{ productPrice }}\"\r\n    required\r\n    clearable\r\n    label=\"价格\"\r\n    icon=\"question-o\"\r\n     bind:click-icon=\"onClickPhoneIcon\"\r\n    placeholder=\"请输入价格\"\r\n    error-message=\"{{phoneerr}}\"\r\n    border=\"{{ false }}\"\r\n    bind:change=\"inputPrice\"\r\n  />\r\n\r\n<van-action-sheet\r\n  required\r\n  show=\"{{ showSelect }}\"\r\n  actions=\"{{ actions }}\"\r\n  close-on-click-overlay=\"true\"\r\n  bind:close=\"toggleSelect\"\r\n  bind:select=\"onSelect\" cancel-text=\"取消\"\r\n/>\r\n  <van-field\r\n    value=\"{{ productCategory }}\"\r\n    center\r\n    readonly\r\n    label=\"商品分类\"\r\n    border=\"{{ false }}\"\r\n    use-button-slot\r\n  >\r\n    <van-button slot=\"button\" size=\"small\" plain type=\"primary\"  \r\n     bind:click=\"toggleSelect\">选择分类</van-button>\r\n  </van-field>\r\n  \r\n  <van-button class=\"rightside\" type=\"default\" bind:click=\"uploadImage\" >上传商品图片</van-button>\r\n  <view class=\"imagePreview\">\r\n    <image src=\"{{productImg}}\" />\r\n  </view>\r\n <van-submit-bar\r\n  price=\"{{ totalShow }}\"\r\n  button-text=\"提交\"\r\n  bind:submit=\"onSubmit\"\r\n  tip=\"{{ false }}\"\r\n >\r\n </van-submit-bar> \r\n<van-toast id=\"van-toast\" />\r\n<van-dialog id=\"van-dialog\" />这里有个控件，绑定了uploadImage方法，其代码为：Copy  uploadImage:function(){\r\n    let that = this;\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success(res) {\r\n        wx.showLoading({\r\n          title: '上传中...',\r\n        })\r\n        const tempFilePath = res.tempFilePaths[0]\r\n        const name = Math.random() * 1000000;\r\n        const cloudPath = name + tempFilePath.match(/\\.[^.]+?$/)[0]\r\n        wx.cloud.uploadFile({\r\n          cloudPath:cloudPath,//云存储图片名字\r\n          filePath: tempFilePath,//临时路径\r\n          success: res => {\r\n            let fileID = res.fileID;\r\n            that.setData({\r\n              productImg: res.fileID,\r\n            });\r\n            wx.showToast({\r\n              title: '图片上传成功',\r\n            })\r\n          },\r\n          fail: e =>{\r\n            wx.showToast({\r\n              title: '上传失败',\r\n            })\r\n          },\r\n          complete:()=>{\r\n            wx.hideLoading();\r\n          }\r\n        });\r\n      }\r\n    })\r\n  }这里，wx.chooseImage用于调起手机选择图片（相册/相机拍照），然后wx.cloud.uploadFile用于上传图片到上面说到的云开发能力之一的“存储”中。上传图片成功之后返回一个文件 ID，类似：Copycloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  这个链接可以直接在小程序页面展示：Copy<image src=\"cloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  \" />也可以通过微信 api，装换成 http 形式的图片链接。云开发之——操作数据库，1 分钟写完保存商品到数据库的代码#上面我们实现了商品图片上传，但是，商品图片并没有保存到数据库。正常录入商品的时候，我们会填好商品名称，价格等，然后上传图片，最终点击“保存”按钮，将商品保存到数据库。传统模式下，前端仍然是需要调用一个后端接口，通过 post 提交数据，最终由后端服务（比如 java 服务）将数据保存到数据库。小程序云开发使得操作数据库十分简单，首先我们在云开发控制台创建“商品表”，即一个 collection,取名为：products。然后我们就可以保存数据到数据库了，代码如下：CopyonSubmit:function(){\r\n    // 校验代码，略\r\n    let product = {};\r\n    product.imgId = this.data.productImg;\r\n    product.name= this.data.productName;\r\n    product.categoryId = this.data.productCategoryId;\r\n    product.price = this.data.productPrice;\r\n    // 其他赋值，略\r\n    const db = wx.cloud.database();\r\n    db.collection('products').add({\r\n     data: product,\r\n     success(res) {\r\n       wx.showToast({\r\n         title: '保存成功',\r\n       })\r\n     }\r\n   });\r\n  }以上就实现了数据入库，就这点代码，超简单，1 分钟写完，诚不欺我。其中这里的products就是我们的“商品表”，之前说过，类似 MongoDB 数据库，这里操作的是db.collection，这和 MongoDB 的语法差不多。云开发之——使用云函数完成后端业务逻辑，订单创建#小程序云开发提供了几大能力：“数据库”，“存储”，“云函数”，前两项我们已经有所体会了。下面我们能创建一个云函数来实现订单创建。这里说明，云函数其实就是 一段JavaScript 代码，上传至云服务器之后，最终也是运行在 nodejs 环境的，只是这一切，我们不需要关心。我们只需要关心我们这个云函数提供的功能是什么就可以了。创建云函数很简单，直接在开发工具中右键“新建Node.js 云函数”。然后以创建订单为例，假设我们创建一个云函数名为c-order-add,创建好了之后，目录是这样：云函数的主要代码在 index.js 中，其完整代码是这样：Copy// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n  env: 'release-xxx'// your-env-id\r\n})\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext();\r\n  console.log(\"云函数 c-order-add : \")  \r\n  // 这里是一些逻辑处理...\r\n  \r\n  return await db.collection('uorder').add({\r\n    data: {\r\n      openid: event.userInfo.openId,\r\n      address: event.address,\r\n      userName: event.userName,\r\n      phone: event.phone,\r\n      shoppingInfo: event.shoppingInfo,\r\n      totlePrice: event.totlePrice,\r\n      shoppingStr: event.shoppingStr,\r\n      remark:event.remark,\r\n      createTime: now,\r\n      // ...\r\n    }\r\n  });\r\n}这个云函数写好之后，需要上传到服务器，直接在云函数目录点击右键，然后点击“上传并部署”即可，这就相当于部署好了后端服务。前端小程序页面调用的写法是这样的：Copylet orderData={};\r\norderData.userName = this.data.userName;\r\norderData.phone = this.data.phone;\r\norderData.address = this.data.address;\r\n// ....\r\nwx.cloud.callFunction({\r\n      // 云函数名称\r\n      name: 'c-order-add',\r\n      // 传给云函数的参数\r\n      data: orderData,\r\n      complete: res => {\r\n        Dialog.alert({\r\n          title: '提交成功',\r\n          message: '您的订单成功，即将配送，请保持手机通畅。'\r\n        }).then(() => {\r\n          // ....\r\n          wx.redirectTo({\r\n            url: '../uorder/uorder'\r\n          });\r\n        });\r\n      }\r\n})这里，向程序前端，通过wx.cloud.callFunction完成了对云函数的调用，也可以理解为对后端服务的调用。至此我们我们介绍完了，小程序云开发的功能。虽然，我只贴出了少量的代码，即保存商品，和提交订单。由于时间和篇幅有限，我不可能把整个完整的程序代码贴出来。但是你可以参照这个用法示例，将剩下的业务逻辑补充完整，最终完成“项目构思”一节中展示的成品截图效果。小程序审核的一点经验#我开发的小程序审核在提交审核的时候遭遇了两次退回，第一次是因为：“小程序具备电商性质，个人小程序号不支持”。所以，我只好申请了一个企业小程序号，使用的是超市的营业执照。服务类目的选择也被打回了一次，最后选择了食品还提交了食品经营许可证。第二次打回是因为：“用户体验问题”。其实就是“授权索取”的问题，微信不让打开首页就“要求授权”，同时不能强制用户接受授权，得提供拒绝授权也能使用部分功能。上面两条解决之后，更新新了好几版，都没有出现过被拒的情况。并且，有次我是夜晚 10 左右提价的审核，结果10 点多就提示审核通过，当时没看具体时间，就是接盆水泡了个脚的时间审核通过了。所以，我推断小程序审核初次审核会比较严，之后如果改动不大应该直接机审就过了。总结及对比#这里我们可以对小程序云开发和传统模式做一个对比：就对比这么多吧，总之，我非常喜欢小程序云开发，小程序真的可以让你轻松干全栈。或者咱们别动不动就提“全栈”，姑且说，小程序云开发可以让你更简单、更快速、更便宜的实现你的产品落地。我自己开发的云小程序上线之后，使用了一两个月，没出现任何问题。我也不用操心服务器什么的。所以，我已经给身边很多人安利了小程序云开发了。这里我就不贴出我的小程序码了，因为已经正式给我同学的超市使用了，所以不方便让别人去产生测试数据。如果你感兴趣想看的话，可以联系我。作者： 逃离沙漠出处：https://www.cnblogs.com/demingblog/p/11914354.html本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。如果本文对您有帮助，不妨点个「推荐」及「赞赏」"}
{"title": "小程序顶部导航栏，可滑动，可动态选中放大效果 ", "author": "Rolan", "pub_time": "2019-11-25 00:36", "content": "老规矩，先看效果图可以看到我们实现了如下功能1，顶部导航栏 2，可以左右滑动的导航栏 3，选中条目放大 原理其实很简单，我这里把我研究后的源码发给大家吧。wxml文件如下<!-- 导航栏 --><scroll-view scroll-x class=\"navbar\" scroll-with-animation scroll-left=\"{{scrollLeft}}rpx\">  <view class=\"nav-item\" wx:for=\"{{tabs}}\" wx:key=\"id\" bindtap=\"tabSelect\" data-id=\"{{index}}\">    <view class=\"nav-text {{index==tabCur?'tab-on':''}}\">{{item.name}}</view>  </view></scroll-view>wxss文件如下/* 导航栏布局相关 */.navbar {  width: 100%;   height: 90rpx;  /* 文本不换行 */  white-space: nowrap;  display: flex;  box-sizing: border-box;  border-bottom: 1rpx solid #eee;  background: #fff;  align-items: center;  /* 固定在顶部 */  position: fixed;  left: 0rpx;  top: 0rpx;}.nav-item {  padding-left: 25rpx;  padding-right: 25rpx;  height: 100%;  display: inline-block;  /* 普通文字大小 */  font-size: 28rpx;}.nav-text {  width: 100%;  height: 100%;  display: flex;  align-items: center;  justify-content: center;  letter-spacing: 4rpx;  box-sizing: border-box;}.tab-on {  color: #fbbd08;  /* 选中放大 */  font-size: 38rpx !important;  font-weight: 600;  border-bottom: 4rpx solid #fbbd08 !important;}js文件如下// pages/test2/test2.jsPage({  data: {    tabCur: 0, //默认选中    tabs: [{        name: '等待支付',        id: 0      },      {        name: '待发货',        id: 1      },      {        name: '待收货',        id: 2      },      {        name: '待签字',        id: 3      },      {        name: '待评价',        id: 4      },      {        name: '五星好评',        id: 5      },      {        name: '差评订单',        id: 6      },      {        name: '编程小石头',        id: 8      },      {        name: '小石头',        id: 9      }    ]  },  //选择条目  tabSelect(e) {    this.setData({      tabCur: e.currentTarget.dataset.id,      scrollLeft: (e.currentTarget.dataset.id - 2) * 200    })  }})代码里注释很明白了，大家自己跟着多敲几遍就可以了。后面会更新更多小程序相关的知识，请持续关注。"}
{"title": "浅谈微信小程序流量变现的常见模式 ", "author": "Rolan", "pub_time": "2019-11-26 00:01", "content": "什么是小程序，小程序是基于微信平台发展而衍生出的即用即走、无需下载的第三方工具。由于其具有操作简单、使用便捷的天然优势，因而现在使用微信小程序人数的增长速度犹如闪电般一样。同时，现在小程序的变现流量也是大幅度的增长，这为商家企业带来了红利期。那么，今天小编将为大家介绍几种常见的小程序流量变现模式，供大家学习与参考。模式一 : 电商变现在微信社交关系链和微信支付体系里，电商小程序流量变现优势明显。电商类的小程序用户直接完结购买流程，包含产品选购、购买、付出一系列的流程，直接变现。如：拼多多、享物说、每日优鲜等社交电商小程序依靠微信社交关系链裂变传播，日订单数也在千万量级。模式二：广告变现广告变现是小游戏、工具类、资讯类小程序变现的主要方式。小程序官方开放了Banner广告，只要活跃用户达到一定量级，可通过广告点击直接变现流量。模式三 : 内容付费付费流量变现方式带动了微信小程序内容付费的发展，如Reader、读书知乎live等小程序，都选用的是付费程序。将公众号绑定小程序可以在公众号推文中嵌入付费产品的小程序贴片。小程序不必下载不占内存，界面清新，用小程序付费体验比APP更好，用户形成习惯后，可直接通过内容付费小程序模式完成引流、推广和变现的流量闭环营销操作。模式四 : 游戏付费微信官方发布了小游戏支撑微信交际关系链玩法，小程序游戏中道具、会员等等这些都能成为商家盈利的方法。游戏底部 banner 位、原生广告植入、续命激励来引导用户点击广告、通过设置付费关卡和道具等，都是游戏小程序的付费方式。当然，关于小程序的变现模式，不局限于以上四种，例如电商卖货、平台卖货等新型盈利模式，也赢得了强烈的反响度。因此，商家应当根据自己的用户群体和产品属性，来选择合适的流量变现模式。"}
{"title": "在小程序中自定义弹窗组件 ", "author": "Rolan", "pub_time": "2019-11-8 00:08", "content": "component\r\n{\r\n    \"component\": true\r\n}\r\n复制代码表明它是一个组件，我们称之为“子组件” 3. 注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。（只使用class）如何使用组件便于区分，引用子组件的页面我们称之为“父组件，” 在父组件的json里先引用子组件：{\r\n  \"usingComponents\": {\r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n}\r\n复制代码父组件传值给子组件因为这个自定义的弹窗组件会应用于很多不同的页面，所以显示的弹窗标题也是不同的，这就是需要父组件给子组件自定义标题，也就是子组件的标题应该从父组件中接受到的。 子组件里： wxml<view class=\"page\">\r\n  <view>{{popupTitle}}</view>\r\n</view>\r\n复制代码jsComponent({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    popupTitle: { //弹窗标题\r\n      type: String,\r\n      value: '默认值', \r\n    }\r\n  },\r\n})\r\n复制代码父组件里： wxml<popup popup-title=\"{{pagetitle}}\"/>\r\n复制代码jsdata: {\r\n    pagetitle: '我是页面标题',\r\n}\r\n复制代码. 在子组件中自定义值是以小驼峰的形式书写的，但是在父组件传的时候要以“-”连接。子组件改变父组件的值这个组件的显示和隐藏都是在父组件决定的，但是因为我这是一个全屏的弹窗，覆盖了整个屏幕，所以想要关闭弹框只能想办法在子组件的点击事件上想办法。 基本逻辑是这样的： 操作流程：打开页面- 点击弹框（弹出子组件）- 点击关闭（点击子组件关闭弹窗） 数据流程：打开页面-点击弹框（传入弹窗标题、点赞成功结果、其他参数）-点击关闭（在父组件上自定义组件，然后子组件关闭按钮监听onTap事件，点击子组件关闭按钮时，会通知父组件去改变状态）逻辑：在子组件中给要触发的元素加 bindtap = 'onTap'然后通过在method中设置onTap函数在onTap中的triggerEvent中设置要触发父组件事件的函数名称父组件接收到字组件的消息，然后触发事件具体参考：\t小程序-组件通信子组件： wxml<view class=\"hide-btn\" bindtap=\"onTap\">×</view>\r\n复制代码jsmethods: { //放自定义的方法\r\n    onTap: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      console.log(`子组件：'向父组件发送通知，我要关闭弹窗'`)\r\n      this.triggerEvent('hidepopop', myEventDetail, myEventOption)\r\n    }\r\n  },\r\n复制代码父组件 wxml<popup \r\nbindhidepopop=\"hidePopop\" \r\nis-show-popup=\"{{isShowPopup}}\" \r\npopup-title=\"{{popupTitle}}\" \r\npopup-content=\"{{popupContent}}\"\r\n/>\r\n复制代码jshidePopop: function(e) {\r\n    console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    console.log('父组件：我接受到了子组件的关闭弹窗的通知！');\r\n    this.setData({\r\n      isShowPopup: true\r\n    })\r\n  }\r\n复制代码参考小程序-自定义组件 代码地址：\tgithub.com/AnsonZnl/wx…"}
{"title": "微信小程序使用echarts，实现左右双Y轴，动态获取数据，生成折线图 ... ", "author": "Rolan", "pub_time": "2019-11-8 00:52", "content": "微信小程序使用echarts，实现左右双Y轴，动态获取数据，生成折线图 本来使用的是wxcharts，但发现实现不了左右双y轴的效果，就换成echarts效果图展示 要实现这样的效果，需要以下几步： （1）去github下载插件，放进自己的项目里 呐，链接 ===>点击这里 只需要将名称是ec-canvas的文件夹放进自己项目里。 像这样： 图片发自简书App（2）分别写小程序的四个文件 ①//echart.json{  \"usingComponents\": {    \"ec-canvas\": \"../../ec-canvas/ec-canvas\"  }}②<!--echart.wxml--><view class=\"container\">     <ec-canvas id=\"myechart\" canvas-id=\"graph\" ec=\"{{ ec }}\"></ec-canvas></view>③/* echart.wxss*/.container{  margin: 0;  padding: 0}④ echart.js 这里分步写： 第一步：导入 echarts 插件import * as echarts from '../../ec-canvas/echarts';第二步：写在Page外的方法function echart(chart, leftData, rightData) {//leftData是坐标系左边y轴，rightData是右边y轴  var option = {    //网格    grid: {      bottom: 80,      show: true,      // containLabel: true    },    //图例    legend: {      data: [{          name: 'leftData',          textStyle: { //设置颜色            color: '#6076FF',            fontSize: '14',          }        },        {          name: 'rightData',          textStyle: {            color: '#FFC560',            fontSize: '14',          }        }      ],      x: 'left',      bottom: 15,      left: 30    },    //x轴    xAxis: {      type: 'category',      boundaryGap: false,      disableGrid: true, //绘制X网格      data: ['', '', '', '', '', '', '', '', ''],      splitLine: {        show: true,        //  改变轴线颜色        lineStyle: {          // 使用深浅的间隔色          color: ['#DDDDDD']        }      },      //去掉刻度      axisTick: {        show: false      },      //去掉x轴线      axisLine: {        show: false      },    },    //y轴    yAxis: [{        name: 'mph',        type: 'value',        min: 0,        // max: 40,        //y标轴名称的文字样式        nameTextStyle: {          color: '#FFC560'        },        //网格线        splitLine: {          show: true,          lineStyle: {            color: ['#DDDDDD']          }        },        //去掉刻度        axisTick: {          show: false        },        //去掉y轴线        axisLine: {          show: false        },      },      {        name: 'g',        type: 'value',        // max: 4,        min: 0,        nameTextStyle: {          color: '#6076FF'        },        //去掉刻度        axisTick: {          show: false        },        //去掉y轴线        axisLine: {          show: false        },      }    ],    series: [{        name: 'leftData',        type: 'line',        animation: true, //动画效果        symbol: 'none',        //折线区域        areaStyle: {          //渐变颜色          color: {            type: 'linear',            x: 0,            y: 0,            x2: 0,            y2: 1,            colorStops: [{              offset: 0,              color: '#6076FF' // 0% 处的颜色            }, {              offset: 1,              color: 'rgba(96,118,255,0.1)' // 100% 处的颜色            }],            global: false, // 缺省为 false          },        },        //折线宽度        lineStyle: {          width: 2        },        color: '#6076FF',        data: leftData // 后台传过来的动态数据        //设置固定的数据        // data: [        //   23, 30, 20, 23, 30, 26, 20, 25, 25        // ]       },      {        name: 'rightData',        type: 'line',        yAxisIndex: 1,        animation: true,        symbol: 'none',        areaStyle: {          color: {            type: 'linear',            x: 0,            y: 0,            x2: 0,            y2: 1,            colorStops: [{              offset: 0,              color: '#FFC560' // 0% 处的颜色            }, {              offset: 1,              color: 'rgba(255, 197, 96,0.3)' // 100% 处的颜色            }],            global: false, // 缺省为 false          },        },        lineStyle: {          width: 2        },        color: '#FFC560',        data: rightData,//后台传过来的动态数据        //设置固定的数据        // data: [        //   2, 1, 0.5, 0.9, 2, 1.0, 0.6, 2, 0.5        // ]      }]  }}第三步：写在Page里的方法，（包括onLoad(),初始化）/** * 页面的初始数据 */data: {  ec: {    lazyLoad: true //初始化加载  }},onLoad: function (options) {  let that = this;  this.oneComponent = this.selectComponent('#mychart');  let url = \"xxxxx\";  let params = {    \"openId\": options.id,  };wx.request({    url: \"xxxx\",    method: 'POST'    data: params,    header: header,    success: (res) => {     that.setData({       leftData: xxx,//从后台获取的数据       rightData: xxxx //从后台获取的数据   });    },  //给图表加上数据  that.initGraph(that.data.leftData, that.data.rightData)  })}初始化图表initGraph: function (leftData, rightData) {  this.oneComponent.init((canvas, width, height) => {    const chart = echarts.init(canvas, null, {      width: width,      height: height    });    initChart(chart, leftData, rightData);    this.chart = chart;    return chart;  });}到这就搞定啦"}
{"title": "微信小程序工程化之路 ", "author": "Rolan", "pub_time": "2019-11-11 00:30", "content": "最近很长一段时间都在和前端项目构建“纠缠”在一起，处理了web项目、app项目紧接着便是微信小程序，之所以把微信单独拎出来做一篇分享，主要是因为小程序的工程化在很多细节上是区别于传统意义上的web项目，请往下看准备工作配置一台打包机，建议弄一台mini（具体配置根据大家的实际情况来定，ps一下我们公司用的16G+128的，目前来说资源已经明显不够用了）其次要去搭建一个jenkins服务，做任务的集中管理。搭建一个服务，主要提供和微信的对接为后期代码上传，提审等功能做基础，关于微信的对接方式大家可以看官网文档 第三方平台如果有可能的话对接一下各自公司的办公管理工具比如企业微信、钉钉等用来做消息的通知、审核等。最后一点就是微信常用的开发套件了，就不做过多阐述。创建和执行工作流首先在Jenkins中创建任务，建议同时创建两个，一个作为开发预览（DevelopTask），另外一个作为代码上传（ReleaseTask）。Jenkins任务中的配置注意下面这几点。处理微信开发者工具登录过期，我们可以通过开发辅助中提供的命令行登录方式来获取到授权二维码，提供给管理者去处理。DevelopTask要定时执行，因为小程序预览二维码会有过期的问题，所以我这里每20分钟会重新生成一张，我们可以在Jenkins的构建触发器中设置DevelopTask的脚本配置主要是上传预览、生成二维码资源（Base64）、通知开发者获取新的二维码。ReleaseTask中区别与DevelopTask的是不需要定时执行，另外我们需要将脚本中的 cli -p /Users/username/demo --preview-qr-output base64@/Users/username/code.txt 命令替换成 cli -u 1.0.0@/Users/username/demo --upload-desc 'initial release' --upload-info-output /Users/username/info.json开发预览，上面说到DevelopTask会生成预览二维码的base64文件，如何将这个信息通知给测试或者开发者呢？这里我以企业微信的方式为例，首先看下效果通过企业微信中的接受消息功能我们可以将消息做一次中转，另外通过消息推送将新的消息推送给指定的用户，我们可以在中转服务中将二维码信息推送给用户，这里有一张企业微信消息推送的流程，大家可以借鉴一下，另外企业微信支持配置菜单类似于微信公众号中的菜单。版本发布，ReleaseTask执行外之后我们会将代码推送到小程序的草稿库中，这里距离真正的提审还有三步骤，第一添加草稿到代码模版库，第二通过模版ID上传小程序代码，第三提交审核。这里的三个步骤由于微信限制，我们没办法在Jenkins中去操作，我们可以搭建中转服务去管理。总结整体流程创建Jenkins任务，处理预览或者上传问题测试：生成预览二维码模版发布：上传草稿利用微信三方服务接口实现模版提交，提审等功能如有不足，还望指出。愿大家在前端的道路上少走弯路"}
{"title": "uni-app中picker组件“确定”和“取消”文字的修改 ", "author": "Rolan", "pub_time": "2019-11-11 00:45", "content": "本文为uniapp中picker组件“确定”和“取消”文字的修改的教程，包括颜色和文字，需要清楚的是，颜色在H5和微信小程序下非常容易修改，但是“确定”和“取消”文字是无法修改的，因为在uniapp中这些都是写死在uniapp源码中的，目前没有找到更好的方式去修改！前言首先需要确定的几点* 在uniapp中picker组件是webview（无论是小程序还是APP，h5是dom）* 需要清楚自己需要修改的是什么版本的，H5和APP以及小程序不一样* 是需要修改文字还是颜色* 没有源码阅读能力者请谨慎操作H5修改颜色非常方面，但是修改文字目前只能改uniapp源码* 修改文字，找到你安装HBuilderX的目录D:\\Program Files\\HBuilderX\\plugins\\uniapp-cli\\node_modules\\@dcloudio\\uni-h5\\src\\platforms\\h5\\view\\components\\picker\\index.vue\r\n// D:\\Program Files为你安装的HBuilderX目录\r\n// 在index.vue中16-25行代码中\r\n\r\n        <div\r\n          class=\"uni-picker-header\"\r\n          @click.stop>\r\n          <div\r\n            class=\"uni-picker-action uni-picker-action-cancel\"\r\n            @click=\"_cancel\">取消</div>\r\n          <div\r\n            class=\"uni-picker-action uni-picker-action-confirm\"\r\n            @click=\"_change\">确定</div>\r\n        </div>修改颜色，可以直接在上面的index.vue里面修改，但是这样做会带来一个问题，就是每次升级HBuilderX的时候就需要修改这个文件// 在index.vue中550-558行代码中\r\n.uni-picker-container .uni-picker-action.uni-picker-action-cancel {\r\n  float: left;\r\n  color: #888;\r\n}\r\n\r\n.uni-picker-container .uni-picker-action.uni-picker-action-confirm {\r\n  float: right;\r\n  color: #007aff;\r\n}在App.vue中修改颜色uni-picker .uni-picker-action.uni-picker-action-confirm{color: #FF725C;}App和小程序在app和小程序中 H5版本的修改方法全部失效修改文字// 在D:\\Program Files\\HBuilderX\\plugins\\weapp-tools\\template\\common\\__uniapppicker.html\r\n// 第 5562-5577是“取消”和“确定”的文字\r\n}, [t._v('取消')]), e(\"div\", {\r\n    staticClass: \"uni-picker-action uni-picker-action-confirm\",\r\n    on: {\r\n    click: t._change\r\n    }\r\n}, [t._v('确定')])]), t.visible ? e(\"picker-view\", {\r\n    staticClass: \"uni-picker-content\",\r\n    attrs: {\r\n    value: t.valueArray\r\n},\r\n    on: {\r\n    \"update:value\": function(i) {\r\n        t.valueArray = i\r\n    }\r\n}\r\n},修改样式// 第14行css代码中\r\n.uni-picker-action.uni-picker-action-cancel[data-v-1c1d4578]{float:left;color:#888} // 取消\r\n.uni-picker-action.uni-picker-action-confirm[data-v-1c1d4578]{float:right;color:#57DBD0} //确定注意事项此方法在升级更新HBuilderX里面的文件就会重置，请注意再次修改，最好把自己项目需要修改的文件修改后备份"}
{"title": "微信小程序实现去抖音视频水印 ", "author": "Rolan", "pub_time": "2019-11-11 00:52", "content": "先放效果图可以扫码或者微信搜索 “ 和水印说拜拜 ” 小程序体验一下。有效再继续往下看吧。实现原理抖音视频上传后，是有2个视频地址，（长视频还会多一个），一个是无水印的，一个是有水印的，万能的网友经过爬虫后，拿到了这个链接，那就可以实现保存无水印的视频了（去水印）。先上代码1、里面是一个PHP文件，把你输入的抖音链接，转为无水印的链接输出。不建议把这个转换算法写死在本地，因为这个转换算法随时会变，所以用PHP实现，然后客户端或者微信小程序调用。<?phpheader('Content-type: application/json');$_u = $_GET['_u'];function _g($_u, $_n = 0) {    $_h = curl_init();    curl_setopt($_h, CURLOPT_URL, $_u);    curl_setopt($_h, CURLOPT_RETURNTRANSFER, 1);    curl_setopt($_h, CURLOPT_HEADER, false);    curl_setopt($_h, CURLOPT_HTTPHEADER, array(        'user-agent:Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Mobile Safari/537.36'    ));    if ($_n == 1) {        curl_setopt($_h, CURLOPT_NOBODY, 1);        curl_setopt($_h, CURLOPT_FOLLOWLOCATION, 1);        curl_exec($_h);        $_r = curl_getinfo($_h, CURLINFO_EFFECTIVE_URL);    } else {        $_r = curl_exec($_h);    }    curl_close($_h);    return $_r;}if (strpos($_u, 'com') !== false) {    $_u = _g(_g($_u, 1));    preg_match('/class=\\\"video-player\\\" src=\\\"(.*?)\\\" preload/is', $_u, $_m);    $_m = str_replace(\"line=0\", \"line=1\", str_replace(\"playwm\", \"play\", $_m[1]));    $_v = _g($_m, 1);    if ($_v == '') {        $_c = 0701.1;        $_s = 'error';    } else {        $_c = 0;        $_s = 'success';    }} else {    $_c = 0701.2;    $_s = 'url does not match';}echo json_encode(array(    \"code\" => $_c,    \"errMsg\" => $_s,    \"videoUrl\" => $_v,    \"tmp\" => time()) , JSON_UNESCAPED_SLASHES);?> 把这个PHP文件丢到你的服务器，然后访问https://xxxx.com/douyin.php?_u=https://sss抖音链接 然后就会返回对应的信息，例如：{    \"code\": 0,    \"errMsg\": \"success\",    \"videoUrl\": \"https://aweme.snssdk.com/aweme/v1/play/?s_vid=93f1b41336a8b7a442dbf1c29c6bbc56827bba338da58fff9d414d5e0e891260a1c391d356de42072e5c7b4c15e93325052710f7923662532737d5c3f25a856e&amp;line=1\",    \"tmp\": 1568018629}这个videoUrl就是无水印的视频地址，可以直接在小程序 标签里面播放，但是在小程序里面，这个是保存不了的，很奇怪，我试了很多次，都是提示类型无效。所以，我是直接让用户复制这个链接，然后在QQ浏览器打开，就能下载视频。（如果有人知道小程序怎样能保存这个视频，请联系我，我做了一个微信小程序的代码片段，你们可以拿去试下。地址：https://developers.weixin.qq.com/s/f5e4RbmR7kbH）如果是客户端使用的话，是可以直接保存的，后缀名为mp4，能直接下载保存。核心代码    $_u = _g(_g($_u, 1));    preg_match('/class=\\\"video-player\\\" src=\\\"(.*?)\\\" preload/is', $_u, $_m);    $_m = str_replace(\"line=0\", \"line=1\", str_replace(\"playwm\", \"play\", $_m[1]));    $_v = _g($_m, 1);上面的PHP，其实主要就是这里，把接收的抖音链接，进行一个正则转换替换字符，然后再输出链接。最后说几句这个转换的算法，应该是抖音随时更换的，不保证永远有效，但截至发帖，都是有效的，建议大家去扫一下小程序，看看能不能转换，能的话，即表明还能用。"}
{"title": "微信小程序swiper组件非居中对称滑动解决方案 ", "author": "Rolan", "pub_time": "2019-11-12 00:02", "content": "一、前言在公司的项目中遇到了非居中对称的类banner滑动需求，如下图：每次滑动的距离并非一屏的宽度，而是要根据实际情况来控制。二、解决方案一开始看文档，由于swiper组件的配置项并不多，我估计能解决这个需求的大概只有previous-margin，next-margin和display-multiple-items三个参数。在经过一系列尝试之后，放弃了display-multiple-items这个参数，如果使用这个参数，很多时候基本上触发不了bindchange事件，并不符合预期也不合理。于是开始研究previous-margin和next-margin，previous-margin可以露出前一项的一小部分，next-margin可以露出后一项的一小部分。于是在初始化时，我把previous-margin设置为28，next-margin设置为400，就可以完美展现图banner1的效果。（slide宽度为300rpx）<swiper\r\n  class=\"swiper-container\"\r\n  previous-margin=\"{{swiperDis.previous}}rpx\"\r\n  next-margin=\"{{swiperDis.next}}rpx\"\r\n  bindchange=\"handleSwiperChange\"\r\n>\r\n  <block wx:for=\"{{ImgList}}\" wx:key=\"{{index}}\">\r\n    <swiper-item class=\"slide-item\">\r\n      <navigator>\r\n        <view class=\"slide-content\">\r\n          <image class=\"slide-bg\" src=\"{{item.bg}}\" />\r\n        </view>\r\n      </navigator>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>swiperDis设置为：swiperDis: {\r\n  previous: 28,\r\n  next: 400\r\n}这时候如果滑动的话，会发现后面两个slier并不如我们所想，而是每次都会滑到最前面，所以我就想如果我在每次bindchange的时候改变previous-margin和next-margin呢？于是我加入了这种傻瓜式的代码：handleSwiperChange(e) {\r\n  const currentIndex = e.detail.current\r\n  if(currentIndex == 0) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 28,\r\n        next: 400\r\n      }\r\n    })\r\n  }else if(currentIndex == 1) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 214,\r\n        next: 214\r\n      }\r\n    })\r\n  }else if(currentIndex == 2) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 400,\r\n        next: 28\r\n      }\r\n    })\r\n  }\r\n}得到的效果如我所想。唯一不够完美的就是这样设置不如swiper自适应滑动的效果那么自然，稍微有那么一点点的卡顿，但我觉得在没有更好的解决办法前这是个又快速又好的方法。"}
{"title": "微信小程序实现A-Z导航的Slidebar ", "author": "Rolan", "pub_time": "2019-11-12 00:41", "content": "微信小程序实现A-Z导航的Slidebar效果代码slidebar.wxml<view id=\"s-bar\" class=\"slidebar\" bindtouchstart=\"_onTouchStart\" bindtouchmove=\"_onTouchMove\" bindtouchend=\"_onTouchEnd\">  <view wx:for=\"{{data}}\" class=\"slide-item\" id=\"item-{{index}}\" wx:key=\"{{index}}\">    <text class=\"t {{item.selected ? 'slide-item-selected' : ''}}\">{{item.key}}</text>  </view></view><view class=\"dialog\" hidden=\"{{currentKey == '' || closeKeyDialog}}\" animation=\"{{animationData}}\" bindtransitionend=\"_onAnimationend\">  {{currentKey}}</view>slidebar.wxss  /* components/slidebar/slidebar.wxss */.slidebar{  position: absolute;  right: 0rpx;  height: 98vh;  width: 60rpx;  border-radius: 30rpx;}.slide-item{  display: flex;  justify-content: center;  justify-items: center;  height: 3.9vh;  width: 60rpx;  font-size: 24rpx;  color: #222222;  text-align: center;  line-height: 3.9vh;  font-weight: 400;}.slide-item .t{  width: 40rpx;  height: 40rpx;  display: inline-block;}.slide-item-selected{  font-weight: 500;  color: #ffffff;  background: #07C160;  border-radius: 50%;}.dialog{  position: absolute;  top: 50%;  margin-top: -180rpx;  left: 50%;  margin-left: -125rpx;  width: 250rpx;  height: 250rpx;  text-align: center;  font-size: 72rpx;  line-height: 250rpx;  color: #ffffff;  background: grey;  border-radius: 15%;}slidebar.js  // components/slidebar/slidebar.jsComponent({  /**   * 组件的属性列表   */  properties: {    data: {      type: Array,      value: [        { key: \"A\" },        { key: \"B\" },        { key: \"C\" },        { key: \"D\" },        { key: \"E\" },        { key: \"F\" },        { key: \"G\" },        { key: \"H\" },        { key: \"I\" },        { key: \"J\" },        { key: \"L\" },        { key: \"M\" },        { key: \"N\" },        { key: \"O\" },        { key: \"P\" },        { key: \"Q\" },        { key: \"R\" },        { key: \"S\" },        { key: \"T\" },        { key: \"U\" },        { key: \"V\" },        { key: \"W\" },        { key: \"X\" },        { key: \"Y\" },        { key: \"Z\" }      ]    }  },  /**   * 组件的初始数据   */  data: {    selectedIndex: -1,    currentKey: \"\",    closeKeyDialog: false,    animationData: {},  },  lifetimes: {    attached: function () {      // 在组件实例进入页面节点树时执行      this.isTouch = false;    },    ready: function(){      this.data.data.forEach((d,i)=>{        this._wxQueryElementInfo(\"#item-\" + i).then(res => {          d.top = res[0].top;          d.left = res[0].left;          d.height = res[0].height;          d.width = res[0].width;        });      });      this.animation = wx.createAnimation({        duration: 1000,        timingFunction: 'ease',      });    },    detached: function () {      // 在组件实例被从页面节点树移除时执行    },  },  /**   * 组件的方法列表   */  methods: {    _onTouchStart: function(e){      this.isTouch = true;      this.setData({        closeKeyDialog: false,        animationData: this.animation.opacity(1).step().export()      });      this._markSlideItemSeleted(e.touches[0].clientY);    },    _onTouchMove: function(e){      this._markSlideItemSeleted(e.touches[0].clientY);    },    _onTouchEnd: function(e){      this.isTouch = false;      this.setData({        animationData: this.animation.opacity(0).step().export()      })    },    /**     * 通过selector查询元素信息     */    _wxQueryElementInfo: function(selector){      return new Promise((resolve, reject)=>{        var query = wx.createSelectorQuery().in(this);        query.select(selector).boundingClientRect();        query.selectViewport().scrollOffset();        query.exec(function (res) {          resolve(res);        });      });    },    /**     * 根据y的位置标记SlideItem的selected状态     */    _markSlideItemSeleted: function(y){      for(var i=0; i<this.data.data.length; i++){        var d = this.data.data[i];        if (y >= d.top && y <= d.top + d.height) {          if(this.data.selectedIndex == i){            return;          }          this._setSlideItemSelectStatus(d,i);          console.log(\"当前选中=>\" + d.key);          this.triggerEvent(\"selected\",d);          return;        }      }    },    _setSlideItemSelectStatus(d,i){      d.selected = true;      if (this.data.selectedIndex != -1) {        this.data.data[this.data.selectedIndex].selected = false;      }      this.setData({        data: this.data.data,        currentKey: d.key,        selectedIndex: i      });    },    _onAnimationend: function(e){      if (this.isTouch){        return;      }      console.log(\"动画结束\")      this.setData({        closeKeyDialog: true      });    },    /**     * 通过key更新slidebar选择的item     */    updateItemSelectedByKey: function(key){      this.data.data.forEach((d,i)=>{        if(d.key == key){          this._setSlideItemSelectStatus(d,i);          return;        }      });    },    /**     * 通过index更新slidebar选择的item     */    updateItemSelectedByIndex: function(index){      if(index > 0 && index < this.data.data.length){        this._setSlideItemSelectStatus(this.data.data[index], index);      }    }  }})"}
{"title": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 ... ", "author": "Rolan", "pub_time": "2019-11-12 11:23", "content": "在做小程序的时候，要实现下面的搜索历史界面下面的搜索很明显的想到是用flex布局，然后把justify-content设置为justify-content: flex-start; 代码如下：<!--wxml--><view class=\"flex\"><button class=\"item\">1</button><button class=\"item\">2</button><button class=\"item\">3</button><button class=\"item\">4</button><button class=\"item\">5</button><button class=\"item\">6</button><button class=\"item\">7</button></view><!--wxss-->.flex{  display: flex;  flex-wrap: wrap;   justify-content: flex-start;}.flex .item{  width: 216rpx;  background-color: red;  margin-bottom: 34rpx;}可效果却不尽人意，发现justify-content不起作用，无论怎么设置都是space-around的效果。 经过排查，发现原因是小程序button中的默认样式中的margin-left: auto;margin-right: auto;所引起的。flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自探秘 flex 上下文中神奇的自动 margin原因找到了，具体修改就容易多了，我们可以覆盖button的margin-left和margin-right的默认值，或者在button外面包裹一层view。在遇到这个问题之前，我也没想到过flex和margin之间还能这么用，涨姿势了。"}
{"title": "【微信小程序】图片压缩-纯质量压缩，非长宽裁剪压缩 ", "author": "Rolan", "pub_time": "2019-11-13 00:17", "content": "原理：利用canvas来实现，将图片绘制到canvas上，然后canvas转图片时，微信提供的一个方法wx.canvasToTempFilePath(Object object, Object this)，此方式可以指定生成图片的质量，下图是从官方API截的图：其中quality可以指定图片的质量，quality的值越小，图片越模糊，通过此方法可以实现图片的压缩注意：1.quality设置只对jpg格式的图片有效，使用时要将fileType设置为“jpg”， 此举可能会导致其它格式的图片变为jpg格式\r\n\r\n2.透明背景的png图片，绘制到canvas上使用此方式导出的图片是黑色背景，有需求的话是需要canvas先设置背景色的，请小伙伴们注意爬坑。有了这个参数，压缩就简单很多了，下面是代码：wxml<view>\r\n  <button bindtap=\"chooseImage\">选择图片</button>\r\n</view>\r\n\r\n<!-- 展示压缩后的图片 -->\r\n<view style=\"display: flex;justify-content: center;flex-direction: column\">\r\n  <image width=\"50\" mode=\"widthFix\" src=\"{{imagePath}}\"></image>\r\n</view>\r\n\r\n<button wx:if=\"{{imagePath.length>0}}\" bindtap=\"save\">点击下载压缩后的图片</button>\r\n\r\n<!-- 用来渲染的canvas --> \r\n<canvas canvas-id='attendCanvasId' class='myCanvas' style='width:{{cWidth}}px;height:{{cHeight}}px;position: fixed;top: -9999px;left: -9999px;'></canvas>jsPage({\r\n  data: {\r\n    imagePath: '',\r\n    quality: 0.2\r\n  },\r\n  onLoad: function (options) {\r\n  \r\n  },\r\n  /**\r\n  * 选项添加图片事件\r\n  */\r\n  chooseImage: function (e) {\r\n    var that = this;\r\n    wx.chooseImage({\r\n      sizeType: ['compressed'],  //可选择原图或压缩后的图片\r\n      sourceType: ['album', 'camera'], //可选择性开放访问相册、相机\r\n      success: result => {\r\n        wx.getImageInfo({\r\n          src: result.tempFilePaths[0],\r\n          success: function (res) {\r\n            that.setData({\r\n              cWidth: res.width,\r\n              cHeight: res.height\r\n            })\r\n            that.getCanvasImg(result.tempFilePaths, res.width, res.height, that.data.quality, function (res) {\r\n              that.setData({\r\n                imagePath: res.tempFilePath\r\n              });\r\n            });\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 质量压缩\r\n   */\r\n  getCanvasImg(tempFilePaths, canvasWidth, canvasHeight, quality, callback) {\r\n    var that = this; \r\n    const ctx = wx.createCanvasContext('attendCanvasId');\r\n    ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n    ctx.drawImage(tempFilePaths[0], 0, 0, canvasWidth, canvasHeight);\r\n    ctx.draw(false, function () {\r\n      wx.canvasToTempFilePath({\r\n        canvasId: 'attendCanvasId',\r\n        fileType: 'jpg',\r\n        quality: quality,\r\n        success: function success(res) {\r\n          callback && callback(res)\r\n        }, fail: function (e) {\r\n          wx.showToast({\r\n            title: '图片上传失败，请重新上传！',\r\n            icon: 'none'\r\n          })\r\n        }\r\n      });\r\n    });\r\n  },\r\n  /**\r\n   * 图片保存到相册\r\n   */\r\n  save(e) {\r\n    let that = this;\r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: that.data.imagePath,\r\n      success: function (res) {\r\n        console.log('图片已保存');\r\n      },\r\n      fail: function (res) {\r\n        console.log('保存失败');\r\n      }\r\n    })\r\n  },\r\n})注意点：注意设置canvas-id='attendCanvasId'canvas要离屏渲染，就是移出屏幕之外，但是元素还是显示的，position: fixed;top: -9999px;left: -9999px; 不能使用 display: none; 这样是获取不到canvas元素的。最后h5页面中也有提供这样的方法例如这样子：let canvas = document.createElement('canvas');\r\nlet ctx = canvas.getContext('2d');\r\nctx.drawImage(imagePath, 0, 0, w, h);\r\ncanvas.toDataURL('image/jpeg', quality);需要的小伙伴也可以自己研究研究哈...源码-欢迎star感谢ok, 结束，"}
{"title": "微信小程序后端开发流程 ", "author": "Rolan", "pub_time": "2019-11-13 00:42", "content": "1、前端调用 wx.login 返回了code，然后调用wx.getUserInfo获取到用户的昵称 头像 2、服务端根据code去微信获取openid， 接口地址： developers.weixin.qq.com/miniprogram…微信小程序后端接口开发controller层public class OauthController {\r\n\r\n    @Autowired\r\n    private WeChatService weChatService;\r\n\r\n    /**\r\n     * 微信授权用js_code换取openId\r\n     * @param code\r\n     * @return\r\n     */\r\n    @GetMapping(\"/code2Session\")\r\n    public BaseResponse code2Session(String code) {\r\n        log.info(\"code2Session,code={}\", code);\r\n        if (StringUtil.isEmpty(code)) {\r\n            return BaseResponse.buildFail(\"参数异常\");\r\n        }\r\n        Code2SessionResponse res = weChatService.code2Session(code);\r\n        log.info(\"code2Session,res={}\", res);\r\n        if (!res.isSuccess()) {\r\n            return BaseResponse.buildFail(res.getErrCode(), res.getErrMsg());\r\n        }\r\n        return BaseResponse.buildSuccess(res);\r\n    }\r\n\r\n\r\n /**\r\n     * 解密获取手机号\r\n     * @param request\r\n     * @param response\r\n     * @param param\r\n     * @return\r\n     */\r\n    public BaseResponse decryptGetPhone(HttpServletRequest request, HttpServletResponse response,\r\n                                    @RequestBody OauthParam param) {\r\n   \r\n            if (!StringUtil.isEmpty(param.getOpenId())) {//微信授权登录\r\n                String sessionKey = weChatService.getSessionKey(param.getOpenId());\r\n                if (StringUtil.isEmpty(sessionKey)) {\r\n                    return BaseResponse.buildFail(\"会话不存在\");\r\n                }\r\n                Sha1Utils sha = new Sha1Utils();\r\n                // 获取用户信息\r\n                log.debug(\"微信登陆 sessionKey = {}\", sessionKey);\r\n                String userInfoStr = sha.decryptWXAppletInfo(sessionKey, param.getEncryptedData(), param.getIv());\r\n                if (StringUtil.isEmpty(userInfoStr)) {\r\n                    return BaseResponse.buildFail(\"无法获取用户信息\");\r\n                }\r\n                JSONObject json = JSONObject.parseObject(userInfoStr);\r\n                //绑定微信的手机号\r\n                String tel = json.getString(\"purePhoneNumber\");\r\n                Assert.isTrue(!StringUtils.isEmpty(tel), \"无法获取用户手机号\");\r\n                BaseResponse baseResponse=new BaseResponse();\r\n                baseResponse.setResultInfo(tel);\r\n                baseResponse.setState(0);\r\n                return baseResponse;\r\n            }\r\n\r\n    }\r\n}\r\n复制代码接口public interface WeChatService {\r\n\r\n\r\n    /**\r\n     * 用code换取openid\r\n     *\r\n     * @param code\r\n     * @return\r\n     */\r\n    Code2SessionResponse code2Session(String code);\r\n\r\n\r\n    /**\r\n     * 获取凭证\r\n     *\r\n     * @return\r\n     */\r\n    String getAccessToken();\r\n\r\n\r\n    /**\r\n     * 获取凭证\r\n     *\r\n     * @param isForce\r\n     * @return\r\n     */\r\n    String getAccessToken(boolean isForce);\r\n\r\n\r\n    String getSessionKey(String openId);\r\n\r\n}\r\n复制代码实现类public class WeChatServiceImpl implements WeChatService {\r\n\r\n    //获取配置文件数据\r\n    @Value(\"${wechat.miniprogram.id}\")\r\n    private String appId;\r\n\r\n    @Value(\"${wechat.miniprogram.secret}\")\r\n    private String appSecret;\r\n\r\n    @Reference\r\n    private SysUserService sysUserService;\r\n\r\n\r\n    @Override\r\n    public Code2SessionResponse code2Session(String code) {\r\n        String rawResponse = HttpClientUtil\r\n                .get(String.format(WechatConstant.URL_CODE2SESSION, appId, appSecret, code));\r\n        log.info(\"rawResponse====={}\", rawResponse);\r\n        Code2SessionResponse response = JSON.parseObject(rawResponse, Code2SessionResponse.class);\r\n        if (response.isSuccess()) {\r\n            cacheSessionKey(response);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    private void cacheSessionKey(Code2SessionResponse response) {\r\n        RedisCache redisCache = RedisCache.getInstance();\r\n        String key = RedisCacheKeys.getWxSessionKeyKey(response.getOpenId());\r\n        redisCache.setCache(key, 2147483647, response.getSessionKey());\r\n    }\r\n\r\n    @Override\r\n    public String getAccessToken() {\r\n        return getAccessToken(false);\r\n    }\r\n\r\n    @Override\r\n    public String getAccessToken(boolean isForce) {\r\n        RedisCache redisCache = RedisCache.getInstance();\r\n        String accessToken = null;\r\n        if (!isForce) {\r\n            accessToken = redisCache.getCache(RedisCacheKeys.getWxAccessTokenKey(appId));\r\n        }\r\n        if (StringUtil.isNotEmpty(accessToken)) {\r\n            return accessToken;\r\n        }\r\n        String rawResponse = HttpClientUtil\r\n                .get(String.format(WechatConstant.URL_GET_ACCESS_TOKEN, appId, appSecret));\r\n        AccessTokenResponse response = JSON.parseObject(rawResponse, AccessTokenResponse.class);\r\n        log.info(\"getAccessToken:response={}\", response);\r\n        if (response.isSuccess()) {\r\n            redisCache.setCache(RedisCacheKeys.getWxAccessTokenKey(appId), 7000, response.getAcessToken());\r\n            return response.getAcessToken();\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    @Override\r\n    public String getSessionKey(String openId) {\r\n        RedisCache redisCache = RedisCache.getInstance();\r\n        String key = RedisCacheKeys.getWxSessionKeyKey(openId);\r\n        String sessionKey = redisCache.getCache(key);\r\n        return sessionKey;\r\n    }\r\n}\r\n复制代码用到的解密工具类public class Sha1Utils {\r\n    public static String decryptWXAppletInfo(String sessionKey, String encryptedData, String iv) {\r\n        String result = null;\r\n        try {\r\n            byte[] encrypData = Base64.decodeBase64(encryptedData);\r\n            byte[] ivData = Base64.decodeBase64(iv);\r\n            byte[] sessionKeyB = Base64.decodeBase64(sessionKey);\r\n\r\n            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivData);\r\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\r\n            SecretKeySpec keySpec = new SecretKeySpec(sessionKeyB, \"AES\");\r\n            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\r\n            byte[] doFinal = cipher.doFinal(encrypData);\r\n            result = new String(doFinal);\r\n            return result;\r\n        } catch (Exception e) {\r\n            //e.printStackTrace();\r\n            log.error(\"decryptWXAppletInfo error\",e);\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n复制代码网络请求工具类public class HttpClientUtil {\r\n\r\n    // utf-8字符编码\r\n    public static final String                        CHARSET_UTF_8          = \"utf-8\";\r\n\r\n    // HTTP内容类型。\r\n    public static final String                        CONTENT_TYPE_TEXT_HTML = \"text/xml\";\r\n\r\n    // HTTP内容类型。相当于form表单的形式，提交数据\r\n    public static final String                        CONTENT_TYPE_FORM_URL  = \"application/x-www-form-urlencoded\";\r\n\r\n    // HTTP内容类型。相当于form表单的形式，提交数据\r\n    public static final String                        CONTENT_TYPE_JSON_URL  = \"application/json;charset=utf-8\";\r\n\r\n    // 连接管理器\r\n    private static PoolingHttpClientConnectionManager pool;\r\n\r\n    // 请求配置\r\n    private static volatile RequestConfig requestConfig;\r\n\r\n    private static CloseableHttpClient getNewHttpClient() {\r\n\r\n        CloseableHttpClient httpClient = HttpClients.custom()\r\n            // 设置连接池管理\r\n            .setConnectionManager(pool)\r\n            // 设置请求配置\r\n            .setDefaultRequestConfig(getRequestConfig())\r\n            // 设置重试次数\r\n            .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false)).build();\r\n\r\n        return httpClient;\r\n    }\r\n\r\n    /**\r\n     * 发送 post请求\r\n     *\r\n     * @param httpUrl\r\n     *            地址\r\n     */\r\n    public static String post(String httpUrl) {\r\n        // 创建httpPost\r\n        HttpPost httpPost = new HttpPost(httpUrl);\r\n        return request(httpPost);\r\n    }\r\n\r\n    public static byte[] postRaw(String httpUrl) {\r\n        // 创建httpPost\r\n        HttpPost httpPost = new HttpPost(httpUrl);\r\n        return requestRaw(httpPost);\r\n    }\r\n\r\n    /**\r\n     * 发送 get请求\r\n     *\r\n     * @param httpUrl\r\n     */\r\n    public static String get(String httpUrl) {\r\n        // 创建get请求\r\n        HttpGet httpGet = new HttpGet(httpUrl);\r\n        return request(httpGet);\r\n    }\r\n\r\n    /**\r\n     * 发送 post请求（带文件）\r\n     *\r\n     * @param httpUrl\r\n     *            地址\r\n     * @param maps\r\n     *            参数\r\n     * @param fileLists\r\n     *            附件\r\n     */\r\n    public static String post(String httpUrl, Map<String, String> maps, List<File> fileLists,\r\n                              String fileName) {\r\n        HttpPost httpPost = new HttpPost(httpUrl);// 创建httpPost\r\n        MultipartEntityBuilder meBuilder = MultipartEntityBuilder.create();\r\n        if (maps != null) {\r\n            for (String key : maps.keySet()) {\r\n                meBuilder.addPart(key, new StringBody(maps.get(key), ContentType.TEXT_PLAIN));\r\n            }\r\n        }\r\n        if (fileLists != null) {\r\n            for (File file : fileLists) {\r\n                FileBody fileBody = new FileBody(file);\r\n                meBuilder.addPart(fileName, fileBody);\r\n            }\r\n        }\r\n        HttpEntity reqEntity = meBuilder.build();\r\n        httpPost.setEntity(reqEntity);\r\n        return request(httpPost);\r\n    }\r\n\r\n    public static String post(String httpUrl, Map<String, String> maps, List<File> fileLists) {\r\n        return post(httpUrl, maps, fileLists, \"file\");\r\n    }\r\n\r\n    public static String post(String httpUrl, List<File> fileLists) {\r\n        return post(httpUrl, Collections.emptyMap(), fileLists, \"file\");\r\n    }\r\n\r\n    /**\r\n     * 发送 post请求\r\n     *\r\n     * @param httpUrl\r\n     *            地址\r\n     * @param params\r\n     *            参数(格式:key1=value1&key2=value2)\r\n     *\r\n     */\r\n    public static String post(String httpUrl, String params) {\r\n        HttpPost httpPost = new HttpPost(httpUrl);// 创建httpPost\r\n        try {\r\n            // 设置参数\r\n            if (params != null && params.trim().length() > 0) {\r\n                StringEntity stringEntity = new StringEntity(params, \"UTF-8\");\r\n                stringEntity.setContentType(CONTENT_TYPE_FORM_URL);\r\n                httpPost.setEntity(stringEntity);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        return request(httpPost);\r\n    }\r\n\r\n    /**\r\n     * 发送 post请求\r\n     *\r\n     * @param maps\r\n     *            参数\r\n     */\r\n    public static String post(String httpUrl, Map<String, String> maps) {\r\n        String param = convertStringParamter(maps);\r\n        return post(httpUrl, param);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 发送 post请求 发送json数据\r\n     *\r\n     * @param httpUrl\r\n     *            地址\r\n     * @param content\r\n     *\r\n     *\r\n     */\r\n    public static String post(String httpUrl, String content, String contentType) {\r\n        //        HttpPost httpPost = new HttpPost(httpUrl);// 创建httpPost\r\n        //        try {\r\n        //            // 设置参数\r\n        //            if (StringUtils.isNotEmpty(content)) {\r\n        //                StringEntity stringEntity = new StringEntity(content, \"UTF-8\");\r\n        //                stringEntity.setContentType(contentType);\r\n        //                httpPost.setEntity(stringEntity);\r\n        //            }\r\n        //        } catch (Exception e) {\r\n        //            e.printStackTrace();\r\n        //        }\r\n        //        return request(httpPost);\r\n        return new String(postRaw(httpUrl, content, contentType), StandardCharsets.UTF_8);\r\n    }\r\n\r\n    public static byte[] postRaw(String httpUrl, String content, String contentType) {\r\n        HttpPost httpPost = new HttpPost(httpUrl);// 创建httpPost\r\n        try {\r\n            // 设置参数\r\n            if (StringUtils.isNotEmpty(content)) {\r\n                StringEntity stringEntity = new StringEntity(content, \"UTF-8\");\r\n                stringEntity.setContentType(contentType);\r\n                httpPost.setEntity(stringEntity);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        return requestRaw(httpPost);\r\n    }\r\n\r\n    /**\r\n     * 发送 post请求 发送json数据\r\n     *\r\n     * @param httpUrl\r\n     *            地址\r\n     * @param paramsJson\r\n     *            参数(格式 json)\r\n     *\r\n     */\r\n    public static String postJson(String httpUrl, String paramsJson) {\r\n        return post(httpUrl, paramsJson, CONTENT_TYPE_JSON_URL);\r\n    }\r\n\r\n    public static byte[] postJsonRaw(String httpUrl, String paramsJson) {\r\n        return postRaw(httpUrl, paramsJson, CONTENT_TYPE_JSON_URL);\r\n    }\r\n\r\n    /**\r\n     * 发送 post请求 发送xml数据\r\n     *\r\n     * @param url   地址\r\n     * @param paramsXml  参数(格式 Xml)\r\n     *\r\n     */\r\n    public static String postXml(String url, String paramsXml) {\r\n        return post(url, paramsXml, CONTENT_TYPE_TEXT_HTML);\r\n    }\r\n\r\n    /**\r\n     * 将map集合的键值对转化成：key1=value1&key2=value2 的形式\r\n     *\r\n     * @param parameterMap\r\n     *            需要转化的键值对集合\r\n     * @return 字符串\r\n     */\r\n    public static String convertStringParamter(Map parameterMap) {\r\n        StringBuilder parameterBuffer = new StringBuilder();\r\n        if (parameterMap != null) {\r\n            Iterator iterator = parameterMap.keySet().iterator();\r\n            String key = null;\r\n            String value = null;\r\n            while (iterator.hasNext()) {\r\n                key = (String) iterator.next();\r\n                if (parameterMap.get(key) != null) {\r\n                    value = (String) parameterMap.get(key);\r\n                } else {\r\n                    value = \"\";\r\n                }\r\n                parameterBuffer.append(key).append(\"=\").append(value);\r\n                if (iterator.hasNext()) {\r\n                    parameterBuffer.append(\"&\");\r\n                }\r\n            }\r\n        }\r\n        return parameterBuffer.toString();\r\n    }\r\n\r\n    /**\r\n     * 发送请求\r\n     *\r\n     * @param request\r\n     * @return\r\n     */\r\n    public static byte[] requestRaw(HttpRequestBase request) {\r\n\r\n        CloseableHttpClient httpClient;\r\n        CloseableHttpResponse response = null;\r\n        // 响应内容\r\n        //        String responseContent = null;\r\n        byte[] rawResponse = null;\r\n        try {\r\n            // 创建默认的httpClient实例.\r\n            httpClient = getNewHttpClient();\r\n            // 配置请求信息\r\n            request.setConfig(requestConfig);\r\n            // 执行请求\r\n            response = httpClient.execute(request);\r\n            // 得到响应实例\r\n            HttpEntity entity = response.getEntity();\r\n\r\n            // 可以获得响应头\r\n            // Header[] headers = response.getHeaders(HttpHeaders.CONTENT_TYPE);\r\n            // for (Header header : headers) {\r\n            // System.out.println(header.getName());\r\n            // }\r\n\r\n            // 得到响应类型\r\n            // System.out.println(ContentType.getOrDefault(response.getEntity()).getMimeType());\r\n\r\n            // 判断响应状态\r\n            if (response.getStatusLine().getStatusCode() >= 300) {\r\n                throw new Exception(\"HTTP Request is not success, Response code is \"\r\n                                    + response.getStatusLine().getStatusCode());\r\n            }\r\n\r\n            if (HttpStatus.SC_OK == response.getStatusLine().getStatusCode()) {\r\n                rawResponse = EntityUtils.toByteArray(entity);\r\n                //                responseContent = EntityUtils.toString(entity, CHARSET_UTF_8);\r\n                EntityUtils.consume(entity);\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 释放资源\r\n                if (response != null) {\r\n                    response.close();\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return rawResponse;\r\n    }\r\n\r\n    private static String request(HttpRequestBase req) {\r\n        return new String(requestRaw(req), StandardCharsets.UTF_8);\r\n    }\r\n\r\n    private static RequestConfig getRequestConfig() {\r\n\r\n        if (requestConfig == null) {\r\n            synchronized (HttpClientUtil.class) {\r\n                if (requestConfig == null) {\r\n                    try {\r\n                        //System.out.println(\"初始化HttpClientTest~~~开始\");\r\n                        SSLContextBuilder builder = new SSLContextBuilder();\r\n                        builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());\r\n                        SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(\r\n                            builder.build());\r\n                        // 配置同时支持 HTTP 和 HTPPS\r\n                        Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder\r\n                            .<ConnectionSocketFactory> create()\r\n                            .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\r\n                            .register(\"https\", sslsf).build();\r\n                        // 初始化连接管理器\r\n                        pool = new PoolingHttpClientConnectionManager(socketFactoryRegistry);\r\n                        // 将最大连接数增加到200，实际项目最好从配置文件中读取这个值\r\n                        pool.setMaxTotal(200);\r\n                        // 设置最大路由\r\n                        pool.setDefaultMaxPerRoute(2);\r\n                        // 根据默认超时限制初始化requestConfig\r\n                        int socketTimeout = 10000;\r\n                        int connectTimeout = 10000;\r\n                        int connectionRequestTimeout = 10000;\r\n                        requestConfig = RequestConfig.custom()\r\n                            .setConnectionRequestTimeout(connectionRequestTimeout)\r\n                            .setSocketTimeout(socketTimeout).setConnectTimeout(connectTimeout)\r\n                            .build();\r\n\r\n                    } catch (NoSuchAlgorithmException e) {\r\n                        e.printStackTrace();\r\n                    } catch (KeyStoreException e) {\r\n                        e.printStackTrace();\r\n                    } catch (KeyManagementException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                    // 设置请求超时时间\r\n                    requestConfig = RequestConfig.custom().setSocketTimeout(50000)\r\n                        .setConnectTimeout(50000).setConnectionRequestTimeout(50000).build();\r\n                }\r\n            }\r\n        }\r\n        return requestConfig;\r\n    }\r\n}\r\n复制代码常量public interface WechatConstant {\r\n    Integer OK_STATUS            = 0;\r\n    String  URL_CODE2SESSION     = \"https://api.weixin.qq.com/sns/jscode2session?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code\";\r\n\r\n\r\n    String  URL_GET_ACCESS_TOKEN     = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=%s&secret=%s\";\r\n\r\n\r\n    String URL_GET_IMAGE = \"http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=%s&media_id=%s\";\r\n    \r\n    \r\n    /**\r\n     * 给公众号发送信息。参考https://mp.weixin.qq.com/advanced/tmplmsg?action=faq&token=708366329⟨=zh_CN\r\n     */\r\n    String  URL_SEND_TO_CHANNEL  = \"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=%s\";\r\n    String  URL_SEND_MESSAGE     = \"https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=%s\";\r\n    \r\n    /**\r\n     * 发送模板消息。参考https://developers.weixin.qq.com/miniprogram/dev/api-backend/sendMiniTemplateMessage.html\r\n     */\r\n    String URL_SEND_TEMPLATE_MESSAGE = \"https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=%s\";\r\n\r\n    String  URL_QR_CODE_UNLIMTED = \"https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=%s\";\r\n    \r\n    String  URL_QR_CODE = \"https://api.weixin.qq.com/wxa/getwxacode?access_token=%s\";\r\n\r\n    /**\r\n     * 获取标签下粉丝列表\r\n     */\r\n    String URL_ALL_FANS_OPENID = \"https://api.weixin.qq.com/cgi-bin/user/tag/get?access_token=%s\";\r\n    /**\r\n     * 获取公众号已创建的标签\r\n     */\r\n    String URL_ALL_TAGS = \"https://api.weixin.qq.com/cgi-bin/tags/get?access_token=%s\";\r\n\r\n}\r\n复制代码使用到的实体类public class Code2SessionResponse implements Serializable {\r\n    public static Integer RESPONSE_OK = 0;\r\n\r\n    @JSONField(name = \"openid\")\r\n    private String       openId;\r\n    @JSONField(name = \"session_key\")\r\n    private String       sessionKey;\r\n    @JSONField(name = \"unionid\")\r\n    private String       unionId;\r\n    @JSONField(name = \"errcode\")\r\n    private Integer      errCode;\r\n    @JSONField(name = \"errmsg\")\r\n    private String      errMsg;\r\n\r\n\r\n\r\n    public boolean isSuccess() {\r\n        return this.errCode == null || RESPONSE_OK.equals(this.errCode);\r\n    }\r\n}\r\n复制代码总结：微信小程序的后端开发主要就是对用户进行授权 ， 1、前端调用 wx.login 返回了code，然后调用wx.getUserInfo获取到用户的昵称 头像 2.首先通过微信授权用js_code换取openId，来获取openId，前端传微信的参数 code字段 3.然后解密获取手机号 前端需要传openId encryptedData iv 等字段来获取用户的的授权手机号这些信息都获取后 接着就是调用后端的登陆接口，登陆接口如果只有授权登录就是我们将接口参数为下图最后三个字段为前端必填字段主要步骤是根据前端的openId获取sessionKey 然后根据sessionKey 和其他参数进行解密获取用户手机号通过解密获取授权登录的手机号，然后根据自己的业务逻辑处理即可，这样我们就可以根据授权的手机号进行授权登录"}
{"title": "小程序导航栏选择每一项居中(scroll-view) ", "author": "Rolan", "pub_time": "2019-11-14 00:41", "content": "前言在项目中遇到点击scroll-view中每一项使其居中，查看文档后发现有scroll-view有属性scroll-into-view可以根据id来定位每一项，但是无法居中，于是我想到了使用scroll-left来计算滚动距离是使一项居中.查看效果完成思路获取屏幕宽度的一半（srceenHalfWidth）获取元素宽度的一半（即subHalfWidth）获取元素到手机屏幕左边的距离（即元素的subLeft）计算scroll-view需要滚动的距离：needScroll = subLeft - srceenHalfWidth + subHalfWidth监听scroll-view滚动获取上次滚动的距离（prevDistance）计算scroll-left属性的值 scroll-left= needScroll + prevDistancewxml代码<scroll-view class=\"power-view\" scroll-x=\"true\" scroll-with-animation=\"true\" scroll-left=\"{{scrollLeft}}\" bindscroll=\"scrollMove\">\r\n    <block wx:for=\"{{powerList}}\" wx:key>\r\n\r\n        <view class=\"item {{index == activeIdx?'active':''}}\" bindtap=\"chooseSub\" id=\"v{{index}}\" data-index=\"{{index}}\">\r\n          <view class=\"icon\"></view>\r\n          <view class=\"text\">全年海量优惠</view>\r\n        </view>\r\n\r\n    </block>\r\n\r\n  </scroll-view>复制代码js代码data: {\r\n    powerList: ['v1', 'v2', 'v3', 'v4', 'v5', 'v6', 'v7', 'v8', 'v9', 'v10', 'v11', 'v12'],\r\n    activeIdx: 0, //选中的index\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n    let scrollInfo = {\r\n      prevDistance: 0, //滚动条的距离（默认为0）\r\n      screenHalfwidth: wx.getSystemInfoSync().windowWidth / 2, \r\n    }\r\n\r\n    this.data.scrollInfo = scrollInfo; \r\n\r\n  },\r\n\r\n  //选择某一项类目\r\n  chooseSub: function(e) {\r\n\r\n    let index = e.currentTarget.dataset.index;\r\n\r\n    this.setData({\r\n      activeIdx: index\r\n    })\r\n    this.getRect(index);\r\n  },\r\n\r\n  //获取类目的宽高\r\n  getRect: function (index) {\r\n\r\n    let that = this;\r\n    let query = wx.createSelectorQuery();\r\n    query.select(\"#v\" + index).boundingClientRect(function (rect) {\r\n\r\n      that.data.scrollInfo.subLeft = rect.left; //元素一半宽度\r\n      that.data.scrollInfo.subHalfWidth = rect.width / 2; \r\n\r\n      that.moveTo();\r\n    }).exec()\r\n\r\n  },\r\n\r\n  //移动导航栏\r\n  moveTo: function() {\r\n    let subLeft = this.data.scrollInfo.subLeft;\r\n    let subHalfWidth = this.data.scrollInfo.subHalfWidth;\r\n    let prevDistance = this.data.scrollInfo.prevDistance;\r\n    let screenHalfwidth = this.data.scrollInfo.screenHalfwidth;\r\n\r\n    let needScroll = subLeft - screenHalfwidth + subHalfWidth;\r\n    let scrollLeft = needScroll + prevDistance;\r\n\r\n    this.setData({\r\n      scrollLeft: scrollLeft\r\n    })\r\n  },\r\n\r\n  //记录滚动的距离\r\n  scrollMove: function(e) {\r\n\r\n    let distance = e.detail.scrollLeft;\r\n    this.data.scrollInfo.prevDistance = distance\r\n  },复制代码结尾有两种特殊情况当scroll-left < 0，scroll-view会滚动到 scroll-left = 0;当scroll-left > maxScroll，scroll-view会滚动到 scroll-left = maxScroll;所以还是正常运行."}
{"title": "开始你的uniapp之旅:写出你的第一个微信小程序 ", "author": "Rolan", "pub_time": "2019-11-18 00:07", "content": "uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。引用官方介绍 , 为什么它可以做到这点 ? uniapp 内置了 Vue.js 如果你熟悉 Vue.js ,  就知道 Vue 的核心只是完成的只是在数据变更后 , 自动帮你把用到这个数据的 \" 对象 \" 中的数据进行更新 , 在浏览器器上它对应着浏览器 dom , 在不同的平台上它可以对应不同的东西 , 这就赋予了 Vue.js 的跨平台能力刚刚说的\"对象\"并不是 Javascript 中 的 Object , 理解成 面向对象编程中的对象更为合适 , 无论它是虚拟的还是现实中的东西 , 它都可以被描述为对象 . 你可以想象吗, 有人已经把 Vue 移植到了带有显示屏的底层硬件上 , 每当 Vue 代码中的数据更新时 , 显示屏上的数据也会被通知更新 .你知道这点就行了 : uniapp 编译时 , 把 Vue template中的基础组件对应不同平台上的基础组件 ,完成了跨平台的工作 .uniapp 跨平台是不是很多坑?你一定会怀疑 unipp 的能力 . 是的 , 必然是有坑的 . 但是坑的层面不是数据层面 , Javascript引擎在不同平台上的解析都是符合规范的  ,一般是 css 样式 或者 api 层面的 , 每个平台对 css和api 的支持不同 ,这个必须你自己去做兼容 , 再好的编译也不可能完全消除原生上带来的差距 . 因此 , 它的坑并不是因为自身的原因 , 而是你对这个平台本身不是很了解 , 写出了不兼容的代码 .如果你不考虑兼容的话 , 我可以说它写小程序是没有坑的 . 你最后写起来会感觉跟小程序差不多 , 但是写起来更爽 .为什么我一定推荐你用 uniapp 写微信小程序?微信小程序用它的语法写不好吗 ? 为什么一定要用 uniapp 呢 . uniapp有几大优势微信的所有api都可以用Vue 的几乎所有语法的支持内置 Vuex 和 Vue-router可以用浏览器调试其他类似于css动画 , vue单文件的优势就不一一说了 .  加粗的每一点都值得你去使用 uniapp .第一点:用 Vue 来写程序 , 你的 Vue 水平和了解程度也会上升不少 , 将来写网页或者其他东西时候 , 用 Vue 也是胸有成竹 .第二点: 微信小程序没有内置 类似 Vuex 的功能 , 导致跨页面 , 跨多级组件的共享数据会非常麻烦 .第三点: 如果你调试过微信小程序就知道 , 每次修改完后编译是多慢 ,展开 dom 是多么麻烦 , 查看数据只能一个 console.log 或者 debugger 来调试 . 但是用 chrome来调试就完全不同了 , 它编译很快 , 可以用 Vue 官方插件 dev-tool 来 查看 v-node 树 , 数据状态和 Vuex , 这个真的是在开发体验和效率上是**降维打击 . **版本较新的浏览器对 css 的支持是一个超集 , 在小程序中的能使用的样式在 chrome 完全兼容, 调试效率也会高一些 , 不过自定义组件要注意一下 , 它的宽高只能由内部撑起 .uniapp 来写小程序有没有缺点呢?有 .微信限制小程序包的大小为 2mb , 但是 uniapp 编译的小程序因为自带 Vue Vuex 等原因 , 会稍稍多几十kb不过不是特别大的问题 . 2. 首次渲染页面速度不如小程序 . 毕竟是要多一层 Vue 的传递所以, 首次加载不如原生 .但是后续的数值更新 , 特别是大量数据的更新 , 因为 Vue 中有 diff 算法使渲染的效率大大提升 .开启 uniapp 的学习第一步:首先下载安装 hbuiderx(标准版) 和 微信开发者工具第二步: hbuilderx 安装完后安装 uniapp 插件 , 其他的插件 比如 scss 编译 等等也可以安装一下 , 全装也没问题哈第三步:微信开发者工具和 uniapp 都安装完后打开微信开发者工具 , 登录账号等等操作设置服务端口 , 先打开你的微信开发者工具 -> 上栏 -> 设置 -> 安全设置 -> 服务端口 -> 开启接着 hbuilderx导航栏 工具 -> 设置 -> 源码视图 这里可以看到右边有设置的json 找到最后一行-> \"weApp.devTools.path\":\"\" 这里填上微信开发者工具的绝对路径 比如我的 : \"weApp.devTools.path\":\"E:/微信web开发者工具\"第四步:两个都设置完后 , hbuilderx 导航栏左上角:文件 -> 新建 -> 项目 -> 选择 uniapp ->选择模板 : Hello uniapp 演示模板 创建-> 导航栏中间:运行 -> 运行到小程序 , 你就可以啦~接下来的学习可以到官方的文档去学习哦~官方的文档"}
{"title": "闲鱼前端基于 serverless 的一种多端开发解决方案 ", "author": "Rolan", "pub_time": "2019-11-18 00:27", "content": "背景前端的发展太快了，前端框架和技术的发展也层出不穷，还包括不同智能设备的出现，对前端开发同学来说是个很大的跳转，简单列举下：前端框架：vue、react、angular小程序：微信小程序、支付宝小程序、字节跳动小程序智能设备：苹果设备、天猫精灵、小度这样就滋生了一些问题，比如我要开发一个通用的页面，兼容不同的端侧和小程序，显然目前是做不到的，我们只能开发多套页面去适配不同的场景，这样的话成本就太高了。很多同学都在尝试解决这个问题，也催生了类似 taro 这样的多端统一开发框架，这是一个好的解决方案，但是比较被动，缺乏一定的扩展性。这篇文章我们要探讨的是，看能不能换个角度去解决这个问题，提升开发效率。ViewModel当我们在开发一个页面的时候，不管用的是哪一种框架，通常都会抽象出一层 viewmodel 层，它主要有 2 个作用和服务端进行交互，接受后台返回的数据，进行加工并传递给 view 层渲染接受 view 层的回调，加工数据并返回给 view 层渲染从上图中我们可以看出，viewmodel 是一段独立的通用代码逻辑，起到了承前启后的作用。它和 view 层关系更加紧密，因此通常会放在前端测。既然 viewmodel 是独立的，那我们能不能把它放在后端呢？这样一个最大的好处就是 viewmodel 可以进行复用，不需要在重复编写，而且只需要改动一个 viewmodel，就可以全量生效。似乎是一个很美好的想法，但是这部分代码由谁去开发呢，总不可能寄希望于后端同学吧，当然只能是我们自己，也感谢于 serverless 架构的出现，让这件事情变成了可能。有些同学可能会问，既然 viewmodel 后移了，那 view 呢？后续会考虑结合我们的 ui2code 技术，那真的就比较完美了。什么是 serverless我们先简单介绍一下什么是 serverless，serverless 的基础是云技术，它是云技术发展到一定阶段而出现的一种革命性的高端架构。serverless 并不是说不需要服务器，而是指不需要开发者去关心底层服务器的状态、资源和扩容等，开发者只需要关注于业务逻辑实现。架构上，我们可以把 serverless 分为 FaaS 和 BaaS。FaaS 是用于创建、运行、管理函数服务的计算平台，它支持多种开发语言，比如 java、nodejs、dart 等，这有利于不同端侧的开发同学介入开发。FaaS 是基于事件驱动的思想，只有当一个函数被事件触发时才会占用服务器资源执行，不然都是无需占用服务器资源的。BaaS 提供了用于函数调用的第三方基础服务，比如身份校验、日志、数据库等，它是由服务商直接提供，开发者无需关系实现，直接调用即可。业务落地我们是通过 gaia 平台 开发后端接口，gaia 可以理解为上文提到的 FaaS 平台。日常开发中有这样一个需求，下面是这个需求的一个页面。因为这个页面上的数据比较多，先把它切分成一个个小的模块，后台返回数据的时候也根据模块来返回数据。我们是根据 viewmodel 来设计接口，首先肯定有一个首屏数据接口；然后是页面上的交互，比如切换卡片、切换芝麻信用按钮，切换会引起页面数据变化，我们可以统一封装一个页面更新的接口；最后是一个开通的接口。后端接口前后端交互最重要的数据结构的设计，我们省略了中间的业务逻辑处理，看下接口的数据结构。首屏接口返回的数据主要有几个特征：根据前端的页面模块定义返回结构字段的颗粒度很细，页面上的每个元素都对应一个字段值有两个字段来控制模块的显示和刷新更新接口的返回数据结构和首屏接口类似，但是入参有所不同，主要包括 2 个字段：data：当前页面的数据，为了避免数据的重复获取action: 定义的页面操作前端处理从后端返回的数据可以看到，数据是及其详细的，无需我们做任何的业务逻辑处理，直接映射到页面即可。这样，前端已经变成了很薄的一层数据，没有任务的业务逻辑处理，变的很简单，当需要迁移到其他端时，只需要迁移视图层即可。当有任何的业务变动时，只需要修改后端的接口，就能生效。收益与总结通过具体的实践，我们发现，对于前端开发同学来说，变的简单了，开发效率有很大的提升，前端同学甚至都不需要去理解具体的业务逻辑，就能完成页面的开发。而且，提取的 viewmodel 可以复用到不同的端侧，设置还包括 native 端。我们还可以将 viewmodel 拆分成更小粒度的 viewmodel，方便在不同的页面接口中进行复用。我们有同学还在 FaaS 侧基于 redux 的思想封装了一个通用的状态管理框架，规范了前后端的交互。后面， 还有一些问题待我们去解决，比如开发成本、viewmodel 的逻辑拆分、具体接口问题定位等。本文转载自公众号闲鱼技术（ID：XYtech_Alibaba）。原文链接：https://mp.weixin.qq.com/s/VLsVTe4ZyOJ9rNyVf5aXyg"}
{"title": "手把手教你避开组件cover-view的那些坑 ", "author": "Rolan", "pub_time": "2019-11-1 00:32", "content": "以下内容转载自微信开放社区腾讯位置服务官方文章《手把手教你避开组件cover-view的那些坑》作者：腾讯位置服务链接: https://developers.weixin.qq....来源：微信开放社区著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。案例背景：最近在开发城市地铁图项目，具体功能有规划路线、定位最近地铁站、以及显示整个城市的地铁网状图等功能。根据需求，在实现的时候在地铁线路图上需要添加定位按钮及线路弹框来展示位置信息以及地铁站详情信息。遇到的问题：在地铁图调研初期，原计划实现渲染方案是采用svg来绘制，但是调研后发现小程序原生API不支持svg。同时，我们在开源中找到一个svg的框架库来实现绘制，但是开发初期发现遇到很多无法实现的需求和性能问题。在对开源库的代码跟踪后，发现绘制方案也是canvas的方式，于是我们决定使用原生canvas的方案来支持地铁图。但是呢，又遇到一些问题，那么我们来看看几个具体的点：        1) view在canvas上无法正常显示。在canvas上使用view来添加图片和弹框时，发现图片以及弹框在canvas的下面，不能正常显示图片。查看文档发现canvas、map、video等原生组件使用的是native实现的，默认显示在小程序的最上层，所以就把view换成cover-view或者cover-image。使用view效果：<!-- 线路 -->\r\n<view class = \"sublines sublines-icon\">\r\n<image class = 'sublinesIcon' src = \"/static/img/ic_sublines.png\" bindtap = 'clickSublines' wx-if = \"{{lineIconShow}}\" ></ image > \r\n</view>替换成cover-view效果：<!-- 线路 -->\r\n<cover-view class = \"sublines sublines-icon\">\r\n<cover-image class = 'sublinesIcon' src = \"/static/img/ic_sublines.png\" bindtap = 'clickSublines' wx-if =\"{{lineIconShow}}\"></cover-image>\r\n</cover-view>但是使用cover-view又遇到了层级和样式的问题。2）canvas上使用cover-image添加图片，图片设置position：absolute；页面上的图片显示在canvas画线的下方，导致定位按钮不能正常使用。后来把position该换成fixed解决来层级的问题。效果如下所示：.locationIcon {\r\n    width: 3rem;\r\n    height: 3rem;\r\n    position: fixed;\r\n    bottom: 3rem;\r\n    left: 0.7rem;\r\n}3）在页面上实现一个弹框时，根据UI图需要实现一个底边线和底边小三角形。通过border给块级元素设置底边线或者css实现三角箭头，单边border设置无效。最终采用了height为1px的cover-view或者图片来代替。设置单边border效果：<!-- 起终点设置弹框 -->\r\n<cover-view class =  \"sdMark\"  style =  'top:{{tapClient.y}}px;left:{{tapClient.x}}px;'  wx-if  =  \"{{sdMarkShow}}\">\r\n    <cover-view class = 'sdMarkContent'>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickStart'>设为起点</cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickEnd' >设为终点</cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickStationDetail'>站点详情</cover-view>\r\n    </cover-view>\r\n</cover-view>修改后的代码：<!-- 起终点设置弹框 -->\r\n<cover-view class = \"sdMark\" style = 'top:{{tapClient.y}}px;left:{{tapClient.x}}px;' wx-if = \"{{sdMarkShow}}\">\r\n    <cover-view class = 'sdMarkContent'>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickStart'>设为起点</cover-view>\r\n        <cover-view class = 'line'></cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickEnd'>设为终点</cover-view>\r\n        <cover-view class = 'line'></cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap``= 'clickStationDetail'>站点详情</cover-view>\r\n    </cover-view>\r\n    <cover-view class = \"icon\">\r\n        <cover-image class = 'icArrow' src = '/static/img/ic_arrow.png'></cover-image>\r\n    </cover-view>\r\n</cover-view>最终的效果：踩坑总结：canvas层级较高，使用cover-view或者cover-image在canvas做操作。单边border相关的操作使用图片或者块级元素来代替。查看相关API文档：cover-view相关文档：https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html欢迎体验和吐槽：\"腾讯位置服务-地铁图\"插件：https://lbs.qq.com/miniprogram_plugin/subway.html"}
{"title": "如何实现微信小程序图像剪切？代码拿去用，不谢！ ", "author": "Rolan", "pub_time": "2019-11-1 00:33", "content": "我在早先发布的文章 《如何实现微信小程序换头像？三步帮你搞定！》 中，提到实现微信小程序换头像需要三步：获取用户头像图片模板图片合成前文已经就获取用户头像和图片模板两个步骤进行了讲解，本文就来详细说说如何合成图片。图片合成的过程中非常重要的一块功能对图片进行剪切。该功能点很固定，大都是对图片进行拖拽、缩放后，在一定区域内剪切出一个固定长宽的图片。这类功能在app端和H5中都有很多成熟的插件供使用，接下来就来看看我在海豚趣图小程序中的头像剪切插件是如何实现的，欢迎大家提意见。为了更好地理解接下来的代码，建议大家先扫描体验一下图片裁剪效果。实现效果界面实现在H5中要实现图片的拖拽和缩放需要一大坨代码，具体实现网上有很多。小程序实现就简单的多了，通过 <movable-area> 和 <movable-view> 就可以实现上述功能<view class=\"clip-view\">\r\n  <!--\r\n    clipHeight、clipWidth 分别为剪切框的高和宽\r\n    imgHeight、imgWidth 分别对应图片的初始高和宽\r\n    imgUrl 为剪切图片的url地址\r\n  -->\r\n  <movable-area class=\"moveare\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \">\r\n    <movable-view scale=\"true\" scale-min=\"{{1}}\" damping=\"1000\" style=\"height: {{imgHeight}}px; width: {{imgWidth}}px; \" direction=\"all\" x=\"{{x}}\" y=\"{{y}}\" bindchange=\"_onChange\" bindscale=\"_onScale\">\r\n      <image class=\"clip-img\" src=\"{{imgUrl}}\" />\r\n    </movable-view>\r\n  </movable-area>\r\n  <!--剪切框 装饰用-->\r\n  <view class=\"clip-box\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \">\r\n    <!--剪切框四个角-->\r\n    <view class=\"clip-border clip-border-lt\"></view>\r\n    <view class=\"clip-border clip-border-rt\"></view>\r\n    <view class=\"clip-border clip-border-lb\"></view>\r\n    <view class=\"clip-border clip-border-rb\"></view>\r\n  </view>\r\n  <!--剪切图片用的canvas-->\r\n  <canvas class=\"clip-canvas\" id=\"img_clip_canvas\" canvas-id=\"img_clip_canvas\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \"></canvas>\r\n</view>\r\n复制代码组件属性组件的入参只需要原始图片的地址和图片剪切框的宽高/**\r\n * 组件的属性列表\r\n */\r\nproperties: {\r\n  // 原始图片路径（要剪切的图片）\r\n  imgUrl: {\r\n    type: String,\r\n    value: ''\r\n  },\r\n  // 剪切的宽度 (rpx)\r\n  clipWidth: {\r\n    type: Number,\r\n    value: 500\r\n  },\r\n  // 截切的高度 (rpx)\r\n  clipHeight: {\r\n    type: Number,\r\n    value: 500\r\n  }\r\n}\r\n复制代码组件data组件的data就会多一些记录图片拖拽缩放的数据，需要注意的是，图片初始位置和图片拖拽位置没有使用同一变量存储，是为了防止在拖拽过程中产生抖动。/**\r\n * 组件的初始数据\r\n */\r\ndata: {\r\n  baseScale: 1,\r\n  imgPath: '',\r\n  imgWidth: 0, // 图片宽\r\n  imgHeight: 0, // 图片高\r\n  x: 0, // 图片初始时x轴位置\r\n  y: 0, // 图片初始时y轴位置，之所以不和top共用一个变量，是因为如果频繁改变y值，图片会闪烁，x同理\r\n  left: 0, // 图片拖拽后的x轴位置\r\n  top: 0, // 图片拖拽后的y轴位置\r\n  scale: 1 // 拖拽后的缩放比例\r\n}\r\n复制代码组件初始化组件的初始化方法用于把图片缩放到合适的大小，并使剪切框位于图片中央/**\r\n * 初始化方法\r\n * 获取图片宽高后，把图片缩放至剪切框大小，\r\n * 并使剪切框位于图片中央\r\n **/\r\n_init() {\r\n  if (!this.data.imgUrl) return\r\n  // 获取屏幕宽度\r\n  let {\r\n    screenWidth\r\n  } = wx.getSystemInfoSync()\r\n  // 计算屏幕rpx\r\n  const rpx = screenWidth / 750\r\n  // 获取图片宽高，然后缩放至剪切框大小\r\n  wx.getImageInfo({\r\n    src: this.data.imgUrl,\r\n    success: ({\r\n      width,\r\n      height,\r\n      path\r\n    }) => {\r\n      const cw = this.data.clipWidth * rpx\r\n      const ch = this.data.clipHeight * rpx\r\n      let scale = Math.max(cw / width, ch / height)\r\n      const imgWidth = width * scale\r\n      const imgHeight = height * scale\r\n      this.setData({\r\n        imgPath: path,\r\n        imgWidth,\r\n        imgHeight,\r\n        baseScale: scale,\r\n        x: (cw - imgWidth) / 2,\r\n        y: (ch - imgHeight) / 2\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码图片拖拽缩放处理完成初始化后就可以监听用户的拖拽和缩放操作了，主要是记录拖拽的位置和缩放的比例，具体到代码实现就是监听 <movable-view> 的拖拽( bindchange )和缩放( bindscale )事件// 拖拽事件响应函数\r\n  _onChange: function(e) {\r\n    this.setData({\r\n      x: e.detail.x,\r\n      y: e.detail.y\r\n    })\r\n  }\r\n\r\n  // 缩放事件响应函数\r\n  _onScale: function(e) {\r\n    this.setData({\r\n      x: e.detail.x,\r\n      y: e.detail.y,\r\n      scale: e.detail.scale\r\n    })\r\n  }\r\n复制代码图片剪切实现拖拽缩放完成后就是剪切了,剪切是利用了 <canvas> 重新绘制图片的剪切区域，保存到微信临时目录里，并返回保存路径。需要注意的是拖拽和缩放后记录的图片剪切位置并不是原图的位置，利用 canvas 的 drawImage 进行绘制的时候需要转换成原图位置，或者先把 canvas 的坐标系进行缩放。 注意：在自定义组件下调用 wx.createCanvasContext(string canvasId, Object this) 方法时，第二个参数this不能省略，否则canvas绘制无响应/**\r\n  * 图片剪切入口方法\r\n  */\r\nclip() {\r\n  const scale = this.data._scale * this.data._baseScale\r\n  const canvasId = 'img_clip_canvas'\r\n  imageClip(canvasId, this.data.imgPath, {\r\n    x: this.data._left * -1,\r\n    y: this.data._top * -1,\r\n    scale,\r\n    width: this.data.clipWidth,\r\n    height: this.data.clipHeight\r\n  }, this)\r\n}\r\n\r\n/**\r\n * 图片剪切\r\n *\r\n * @param canvas canvas组件id，用于绘制剪切图片\r\n * @param img 要剪切的图片\r\n * @param option 剪切的位置宽高等信息\r\n * @param option.left 剪切图片左边距\r\n * @param option.top 剪切图片上边距\r\n * @param option.width 剪切图片宽度\r\n * @param option.height 剪切图片高度\r\n * @param context 组件实例对象\r\n * \r\n * @return new Promise(resolve=>ctx)\r\n */\r\nimageClip(canvas, img, option, context) {\r\n  return new Promise((resolve, reject) => {\r\n    option = Object.assign({\r\n      left: 0,\r\n      top: 0,\r\n      scale: 1,\r\n      width: 0,\r\n      height: 0\r\n    }, option)\r\n    let x = option.left / option.scale\r\n    let y = option.top / option.scale\r\n    let clipW = option.width / option.scale\r\n    let clipH = option.height / option.scale\r\n    const ctx = wx.createCanvasContext(canvas, context)\r\n    ctx.drawImage(img,\r\n      x,\r\n      y,\r\n      clipW,\r\n      clipH,\r\n      0,\r\n      0,\r\n      option.width,\r\n      option.height)\r\n\r\n    ctx.draw(false, (e) => {\r\n      console.log(e)\r\n      resolve()\r\n    })\r\n\r\n  })\r\n},\r\n\r\n/**\r\n * canvas 保存为临时文件\r\n */\r\nfunction saveCanvasToTemp(canvas, option) {\r\n  return new Promise((resolve, reject)=>{\r\n    wx.canvasToTempFilePath({\r\n      ...option,\r\n      canvasId: canvas,\r\n      success:resolve,\r\n      fail:reject\r\n    }, this)\r\n  })\r\n}\r\n复制代码写在最后这就是小程序版图片剪切的主要代码实现，里面还有一些小点儿需要注意<movable-view>\r\nwx.createCanvasContext(string canvasId, Object this)\r\n关于我们快狗打车前端团队专注前端技术分享，定期推送高质量文章，欢迎关注点赞。 文章同步发布在公众号哟，想要第一时间得到最新的资讯，just scan it ！"}
{"title": "node egg 微信支付服务 ", "author": "Rolan", "pub_time": "2019-11-1 00:42", "content": "一、初始化egg应用npm init egg --type=simple\r\nnpm i\r\n复制代码二、配置微信支付用到的插件plugin.js 必备插件(egg-wechat-pay可以选择别的插件代替)module.exports = {\r\n cors: {\r\n   enable: true,\r\n   package: 'egg-cors',\r\n },\r\n wechatPay: {\r\n   enable: true,\r\n   package: 'egg-wechat-pay'\r\n },\r\n};\r\n复制代码三、配置中间件因为微信支付返回的数据都是xml格式数据 所以我们的解析xml数据 不然接收不到微信支付回调的请求数据xmlparse.js (可以使用koa的其它中间件也行)module.exports = require('co-wechat-body');\r\n复制代码四、配置config.default.js//部分主要配置\r\nconfig.security = {\r\n        csrf: {\r\n            enable: false,\r\n        },\r\n        domainWhiteList: ['*'],\r\n}//跨域请求\r\n\r\n    const fs = require('fs')\r\n    const path = require('path')\r\n    \r\n    config.mpWeixin = {\r\n        appid: '',微信公众号或小程序号\r\n        AppSecret: '',密钥\r\n        Host: 'https://api.weixin.qq.com/',\r\n        MsgToken: '',\r\n        EncodingAESKey: ''\r\n    }\r\n    \r\n    config.wechatPay = {\r\n        client: {\r\n            bodyPrefix: '',//\r\n            appId: '',//微信公众号或小程序号\r\n            merchantId: '',//商户号\r\n            secret: '',//商户密钥\r\n            notifyUrl: '',//支付成功回调地址\r\n            REFUNDNotifyUrl: '',//退款成功回调地址\r\n            pfx: fs.readFileSync(path.join(__dirname, '../app/public/wxpaly/apiclient_cert.p12'))//退款证书地址\r\n        },\r\n        URLS: {\r\n            UNIFIED_ORDER: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n            ORDER_QUERY: 'https://api.mch.weixin.qq.com/pay/orderquery',\r\n            REFUND: 'https://api.mch.weixin.qq.com/secapi/pay/refund',\r\n            REFUND_QUERY: 'https://api.mch.weixin.qq.com/pay/refundquery',\r\n            DOWNLOAD_BILL: 'https://api.mch.weixin.qq.com/pay/downloadbill',\r\n            SHORT_URL: 'https://api.mch.weixin.qq.com/tools/shorturl',\r\n            CLOSE_ORDER: 'https://api.mch.weixin.qq.com/pay/closeorder',\r\n            REDPACK_SEND: 'https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack',\r\n            REDPACK_QUERY: 'https://api.mch.weixin.qq.com/mmpaymkttransfers/gethbinfo',\r\n            TRANSFERS: 'https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers',\r\n            TRANSFERS_QUERY: 'https://api.mch.weixin.qq.com/mmpaymkttransfers/gettransferinfo',\r\n        }\r\n    }\r\n复制代码五、工具函数util.jsconst crypto = require('crypto');\r\nconst fs = require('fs')\r\nconst path = require('path')\r\n\r\nfunction randomString(len) {\r\n  // isFinite 判断是否为有限数值\r\n  if (!Number.isFinite(len)) {\r\n    throw new TypeError('Expected a finite number');\r\n  }\r\n  return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').slice(0, len);\r\n}\r\n\r\n\r\nfunction getSign(params, key, type = 'MD5') {//支付签名\r\n  const paramsArr = Object.keys(params);\r\n  paramsArr.sort();\r\n  const stringArr = []\r\n  paramsArr.map(key => {\r\n    if (key != 'sign' && params[key])\r\n      stringArr.push(key + '=' + params[key]);\r\n  })\r\n  if (type == \"MD5\") {\r\n    // 最后加上 商户Key\r\n    stringArr.push(\"key=\" + key)\r\n    const string = stringArr.join('&');\r\n    const MD5 = crypto.createHash('md5');\r\n    return MD5.update(string).digest('hex').toUpperCase();\r\n  } else {\r\n    return crypto.createHmac('sha256', key)\r\n      .update(stringArr.join('&'))\r\n      .digest('hex').toUpperCase();\r\n  }\r\n\r\n}\r\n\r\nfunction checkSign(params, key) { //验证签名是否正确\r\n  const {\r\n    sign\r\n  } = params;\r\n  const Newsign = getSign(params, key)\r\n  if (sign === Newsign) {\r\n    return true\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n\r\n复制代码六、编写ServicePayment.js'use strict';\r\nconst Service = require('egg').Service;\r\nconst { randomString, ransign, getSign, checkSign, } = require('util.js')\r\nconst moment = require('moment');\r\nconst Decimal = require('decimal.js');\r\nclass PaymentService extends Service {\r\n \r\n    /**\r\n     * H5支付或微信扫一扫支付\r\n     *\r\n     * @param {*} body 费用说明\r\n     * @param {*} money 金额\r\n     * @returns\r\n     * @memberof PaymentService\r\n     */\r\n    async pay(PayType, body, money) {\r\n        const { ctx, service, app } = this;\r\n        let No = Date.now();\r\n        let OrderNo = moment().format('YYYYMMDDHHmm') + randomString(3) + No;\r\n        let createTime = moment().format('YYYY-MM-DD HH:mm:ss');\r\n        let order = { //统一订单参数\r\n            device_info: 'WEB',\r\n            body,\r\n            out_trade_no: OrderNo,\r\n            total_fee: new Decimal(money).mul(new Decimal(100)).toFixed(),\r\n            attach: `${UserId}`\r\n        };\r\n        if (PayType == 'H5') {\r\n            order.scene_info = JSON.stringify({\r\n                h5_info: 'h5_info',\r\n                type: 'Wap',\r\n                wap_url: this.config.h5host,\r\n                wap_name: '峰会报名付款'\r\n            })\r\n        }\r\n        const unifiedRes = await this.unifiedOrder(order, PayType == 'H5' ? 'MWEB' : 'NATIVE'); \r\n        return unifiedRes\r\n    }\r\n\r\n\r\n   \r\n\r\n    //支付回调\r\n    async payaction(params) {\r\n        const {\r\n            ctx,\r\n            service,\r\n            app\r\n        } = this;\r\n        const {\r\n            appid, //公众账号ID\r\n            bank_type, //付款银行\r\n            cash_fee, //现金支付金额\r\n            device_info, //设备号\r\n            fee_type, //货币种类\r\n            is_subscribe, //是否关注公众账号\r\n            mch_id, //商户号\r\n            nonce_str, //随机字符串\r\n            openid, //用户标识\r\n            out_trade_no, //商户订单号\r\n            result_code, //业务结果\r\n            return_code, //返回状态码\r\n            sign, //签名\r\n            time_end, //支付完成时间\r\n            total_fee, //订单金额\r\n            trade_type, //交易类型\r\n            transaction_id, //微信支付订单号\r\n            attach\r\n        } = params;\r\n\r\n        if (return_code == \"SUCCESS\") {\r\n            if (checkSign(params, this.config.wechatPay.client.secret)) {//解析回调数据是否正确\r\n               //自己处理\r\n            } else {\r\n                return {\r\n                    msg: '签名错误',\r\n                    status: 'error',\r\n                }\r\n            }\r\n        } else {\r\n            return {\r\n                msg: '支付失败',\r\n                status: 'error',\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n \r\n\r\n    //退款\r\n    async refund(out_trade_no,refund_fee,refund_desc,PayPrice) {\r\n        const {\r\n            ctx,\r\n            service,\r\n            app\r\n        } = this;\r\n\r\n     \r\n        let nonce_str = randomString(32);\r\n \r\n            let out_refund_no  = moment().format('YYYYMMDDHHmmss') + randomString(25);\r\n\r\n            let data = {\r\n                appid: this.config.wechatPay.client.appId,\r\n                mch_id: this.config.wechatPay.client.merchantId,\r\n                nonce_str,//随机字符串\r\n                out_trade_no,//订单号\r\n                out_refund_no,//退款订单号\r\n                total_fee: new Decimal(PayPrice).mul(new Decimal(100)).toFixed(),//总金额\r\n                refund_fee: new Decimal(refund_fee).mul(new Decimal(100)).toFixed(),//退款金额\r\n                refund_desc,//退款原因描述\r\n                notify_url: this.config.wechatPay.client.REFUNDNotifyUrl//退款成功回调地址\r\n            }\r\n            let sign = getSign(data, this.config.wechatPay.client.secret);//签名\r\n            let xml = {\r\n                ...data,\r\n                sign\r\n            };\r\n            try {\r\n                const curlres = await ctx.curl(`${this.config.wechatPay.URLS.REFUND}`, {\r\n                    method: 'POST',\r\n                    pfx: this.config.wechatPay.client.pfx,//退款证书\r\n                    passphrase: this.config.wechatPay.client.merchantId,\r\n                    // 直接发送原始 xml 数据，不需要 HttpClient 做特殊处理\r\n                    content: this.app.wechatPay.stringify(xml),\r\n                });\r\n                \r\n                let rdata = await this.app.wechatPay.parse(curlres.data);//解析xml数据\r\n\r\n                return {\r\n                    res: rdata\r\n                }\r\n            } catch (error) {\r\n                console.log(error, \"error\");\r\n                if (error == \"invalid refund_fee\") {\r\n                    return {\r\n                        msg: '退款金额不正确',\r\n                        status: 'error',\r\n                    }\r\n                } else {\r\n                    return {\r\n                        msg: '退款失败',\r\n                        status: 'error',\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n    }\r\n\r\n  \r\n    //微信内部浏览器或小程序 统一创建支付 \r\n    async CreatePaymentInfo(money,openid) {\r\n        const {\r\n            ctx,\r\n            service,\r\n            app\r\n        } = this;\r\n        \r\n        let No = Date.now();\r\n        let OrderNo = moment().format('YYYYMMDDHHmmss') + randomString(3) + No;\r\n        const order = { //统一订单参数\r\n            device_info: 'WEB',\r\n            body: \"\",费用说明\r\n            out_trade_no: OrderNo,//订单编号\r\n            total_fee: new Decimal(money).mul(new Decimal(100)).toFixed(),//支付金额 分为单位\r\n            openid,//用户openid\r\n        };\r\n        const res = await this.unifiedOrder(order); //请求生成订单信息\r\n        return {\r\n            res\r\n        }\r\n    }\r\n\r\n    async unifiedOrder(order, trade_type = 'JSAPI') {\r\n        const {\r\n            ctx,\r\n            service\r\n        } = this;\r\n        let nonce_str = randomString(32);//随机字符串\r\n        let Data = {\r\n            appid: this.config.wechatPay.client.appId,\r\n            mch_id: this.config.wechatPay.client.merchantId,//商户号\r\n            nonce_str,\r\n            sign_type: 'MD5',//签名方式\r\n            spbill_create_ip: ctx.ip,//用户ip\r\n            trade_type,//支付类型\r\n            notify_url: this.config.wechatPay.client.notifyUrl,//支付成功回调地址\r\n            time_expire: moment().add(1, 'h').format('YYYYMMDDHHmmss'),\r\n            ...order\r\n        }\r\n\r\n        let sign = getSign(Data, this.config.wechatPay.client.secret);//签名\r\n        let xml = {\r\n            ...Data,\r\n            sign\r\n        };\r\n        const cur = await ctx.curl(`${this.config.wechatPay.URLS.UNIFIED_ORDER}`, {\r\n            method: 'POST',\r\n            // 直接发送原始 xml 数据，不需要 HttpClient 做特殊处理\r\n            content: this.app.wechatPay.stringify(xml),\r\n        });\r\n        const parseData = await this.app.wechatPay.parse(cur.data);\r\n        let res = {\r\n            appId: Data.appid,\r\n            nonceStr: nonce_str,\r\n            package: `prepay_id=${parseData.prepay_id}`,\r\n            timeStamp: moment().add(1, 'h').unix().toString(),\r\n            signType: 'MD5',\r\n        }\r\n        if (trade_type == 'MWEB') {//手机浏览器H5支付\r\n            res.mweb_url = parseData.mweb_url\r\n        }\r\n\r\n        if (trade_type == 'NATIVE') {//可用于微信扫一扫支付\r\n            res.code_url = parseData.code_url\r\n        }\r\n\r\n        return {\r\n            ...res,\r\n            paySign: getSign(res, this.config.wechatPay.client.secret)\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nmodule.exports = PaymentService;\r\n复制代码主要代码基本可以实现微信支付的服务端写的太糙了hhh 不会写只能贴代码 有什么问题 可以留言"}
{"title": "微信小程序工程化之持续集成方案 ", "author": "Rolan", "pub_time": "2019-11-1 00:52", "content": "本文作者：韩永刚，360奇舞团 WEB前端开发高级工程师。本文将简单介绍一下持续集成的概念，并手把手带你在你的微信小程序项目中完成属于你的持续集成方案。什么是前端工程化所有能降低成本，并且能提高效率的事情总称为工程化。在前端项目中能够减少重复工作、扩展 javascript\\html\\css 本身的语言能力、解决功能复用和变更问题、解决开发和产品环境差异问题、任何时间任何地点生成可部署的软件、解决发布流程问题，都属于前端工程化。什么是持续集成持续集成是前端工程化中的一部分，是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括自动化编译，自动化测试，自动化发布）来验证项目代码，从而尽早地发现错误。Web项目持续集成怎么做Web项目的持续集成方案选择比较多，并且相对成熟，这里介绍一下 gitlab-ci 持续集成方案。这种方式的原理就是为项目在自己的 linux 服务器安装并注册 gitlab-runner，注册会有一个 token ，服务器上运行 gitlab-runner 后， runner 会轮询的发送带 token 的 http 请求给 gitlab ,如果 gitlab 有任务了，（一般是 git push ），那么会把任务信息返回给 runner ，然后 runner 就开始调用注册时选的 Executor 来执行项目根目录下的配置文件 .gitlab-ci.yml ，执行后把结果反馈给 gitlab 。此时我们可以编写 .gitlab-ci.yml 脚本，比如设定当 test 分支发生 push时，自动运行测试用例、自动构建代码、自动将代码更新到测试人员在测的环境等任何你想在提测时需要做的事情。当 merge 到 master 时，自动更新线上代码完成上线等各种你想在上线时做的事情。这里只要考虑的足够全面，那么之后的项目开发你只需要 push 到对应的分支， gitlab-runner 会自动完成你想做的所有构建、提测、上线操作。减少重复工作，这就是持续集成的意义所在。手把手教你完成小程序的持续集成方案小程序的持续集成可以继续使用 gitlab-ci 的方式，但由于小程序的构建、提测、提交体验版等操作都需要依赖于 微信开发者工具 ，而微信开发者工具只有 Windows 和 Mac 版，所以我们需要一台 Windows 服务器来运行 gitlab-runner 。1. 准备工作一台 Windows 服务器一个权限为 Maintainer 的 gitlab 项目2. 安装必要软件在这台 Windows 服务器上安装以下软件GitNode.js微信开发者工具3. 配置gitlab-runner1. 首先下载 gitlab-runnerhttps://docs.gitlab.com/runner/install/windows.html\r\n下载完成后将其移动到合适的路径后重命名为 gitlab-runner.exe2. 在 Windows 服务器中打开 powershell 并进入 gitlab-runner.exe 所在目录，然后执行以下命令.\\gitlab-runner.exe register1. Please enter the gitlab-ci coordinator URL打开想要设置 CI 的 gitlab 项目，进入页面 settings > CI/CD > Runners > Expand ，找到 Set up a specific Runner manually ，输入 Specify the following URL during the Runner setup: 下的地址2. Please enter the gitlab-ci token for this runner输入 Use the following registration token during setup: 下的token字符串3. Please enter the gitlab-ci description for this runner输入一个描述4. Please enter the gitlab-ci tags for this runner输入一个标签，该标签对应该runner5. Please enter the executor这里输入 shell 就好此时刷新 gitlab 页面会新增一个 gitlab-runner3. 执行命令 install.\\gitlab-runner.exe install4. 执行命令 start.\\gitlab-runner.exe start此时刷新 gitlab 页面，之前的 gitlab-runner 会更新为以下状态，表示 gitlab-runner 配置完成，已经可以开始工作。4. 修改gitlab-runner服务的登录账号由于 gitlab-runner 服务默认登录账号为 authority\\system ，而这个账号在执行微信开发者工具命令行时会出现报错，所以我们需要更改 gitlab-runner服务的登录账号为正确账号并重启该服务。右击计算机 -> 管理 -> 服务和应用程序 -> 服务找到 gitlab-runner 服务右击 gitlab-runner -> 属性 -> 登录 -> 此账号 -> 输入可以正确使用微信开发者工具命令行的账号和密码 -> 确定 -> 重启动此服务修改完成后账号会正确被更改5. 配置微信开发者工具使用你的微信账号登录开发者工具设置 -> 安全 -> 服务端口 -> 开启6. 配置.gitlab-ci.yml在项目根目录创建 .gitlab-ci.yml 文件，并填写以下配置。stages: # 定义阶段用于执行任务\r\n  - build\r\n  - deploy\r\n\r\nbuild_job: # 定义 build 任务，名称可以随意命名，只是为了方便理解和区分\r\n  stage: build # 该任务属于 build 阶段，要严格与stages中定义的命名一致\r\n  only:\r\n    - master\r\n  tags: # tags 指定运行在哪个 Runner 上，这里需要在我们刚注册的 Runner 运行，和注册时的 mp_win7 匹配\r\n    - mp_win7\r\n  before_script: # 执行script之前的钩子\r\n    - whoami\r\n  script: # 执行下面脚本，这里可以自定义配置您的构建任务\r\n    - echo \"build\" # 可以在这里执行您项目的构建编译操作\r\n\r\ndeploy_job: # 定义 deploy 任务，名称可以随意命名，只是为了方便理解和区分\r\n  stage: deploy # 该任务属于 deploy 阶段\r\n  only:\r\n    - master\r\n  tags: # tags 指定运行在哪个 Runner 上，这里需要在我们刚注册的 Runner 运行，和注册时的 mp_win7 匹配\r\n    - mp_win7\r\n  script: # 执行下面脚本，这里可以自定义配置您的部署任务\r\n    - C:\\software\\wechatDevTool\\cli.bat -u 0.1.0@\"$PWD\" --upload-desc 最新的描述 # 这里使用微信开发者工具提供的命令行工具进行上传体验版操作修改完成后将代码 push 到远程仓库，会自动触发CI任务。此时登录微信小程序官网后台，就可以看到刚刚 push 代码时由 gitlab-ci 自动上传的体验版了。有关 .gitlab-ci.yml 的详细配置方法可以参考以下文章。http://urlqh.cn/mK3tA\r\nhttp://urlqh.cn/mNjWs\r\n7. 持续集成项目方案以下为本人最近在做的 360瞭望台 小程序的持续集成方案，您可以根据自己的需要加以改进，并完成属于你的持续集成方案。由于编写 .gitlab-ci.yml 时需要用到微信开发者工具的命令行，所以为了便于团队成员使用，我开发了一个 node.js 脚本，并发布为 npm 模块，用于在 .gitlab-ci.yml 调用 Windows 虚拟机中的上传命令。约定团队开发流程，开发新需求时创建 feature/0.5.1 (需求版本号) 分支，当 push 代码时会自动触发 CI 任务，并在虚拟机修改为 test 环境后提交体验版。发完测试报告后可以将小程序提审时，我们需要将 feature/0.5.1 分支 merge 到 audit 分支，此时会自动触发 CI 任务，并在虚拟机修改为 production 环境后提交体验版。 audit 分支需要添加为受保护的分支，不允许直接 push 代码，如果审核没通过那么可以以 audit 为基础新建 feature/0.5.2 分支进行调整后重新 merge 到 audit 。当审核通过后我们需要将 audit 分支代码合并到 master 分支， master 分支应该永远与线上代码保持同步。相关资料http://urlqh.cn/mKi7T\r\nhttp://urlqh.cn/mJPCC\r\nhttp://urlqh.cn/mIWRk\r\nhttp://urlqh.cn/mJoY2\r\nhttp://urlqh.cn/mLCIB"}
{"title": "如何开发微信小程序打车应用 ", "author": "Rolan", "pub_time": "2019-11-4 00:16", "content": "业务流程介绍项目描述为了解决长途如跨城市的出行撮合需求，满足乘客和司机双方自由定价的意愿，特开发一款非及时的打车应用。基本功能是出行用户登录小程序后，根据自己角色选择发布行程计划。行程计划包括出行时间和起始位置以及期望价格；如果是乘客，发布自己的出行计划之后跳转到乘客发布的出行计划列表页，乘客可以点击期望的行程计划，邀请司机接单；如果是司机，需要验证是否已经认证通过。如果没有认证通过则跳转到认证页面，否则跳转到乘客发布的出行计划列表页，选择期望的出行计划，完成接单。司机和乘客通过聊天页面协调出行计划。暂不支持支付功能，由双方线下完成交易。用流程图描述为：系统原型主要提供3个Tab页面：“首页”、“消息”和“我的”。其中“首页”聚焦行程发布、行程查看和聊天会话等核心功能。“消息”聚焦历史会话检索等功能，在首页进行的会话会跳转到该tab页面。“我的”聚焦车主认证、司机或者乘客查看历史行程记录以及客服服务等功能。原型图如下所示：系统存储设计根据业务，存储表主要有以下几种：driver：司机认证记录表，包括司机个人信息以及认证状态等driver_route:司机发布的行程记录表passager_route：乘客发布的行程记录表bargin_route：成交的行程记录表chat_partner：聊天的双方参与者message：会话记录存储表 结构 和各表之间的关系如下所示：开发准备a. 帐号申请开发小程序的第一步需要注册一个小程序帐号，可能这一步是小程序开发最大的障碍，因为不管哪种帐号都需要认证，特别是企业类型帐号认证需要企业工商营业执照和组织机构代码证，如果小程序需要支付功能，还需要提供对公帐号。但是你也可以使用个人帐号类型，但是个人帐号具备的功能很有限，比如不能支持支付功能等。有关小程序的注册类型和认证的疑问可以参考这里：小程序的注册类型和认证。注册小程序帐号之后，就可以得到一个appId和secret key，它们跟小程序应用相绑定的，在后续API调用中是不可缺少的。b. 开发工具同开发其他应用程序一样，微信团队同样也有自己的开发集成工具。有关如何注册和下载开发工具，可以参考官方文档：注册和下载开发工具。下面简要介绍开发工具的常用功能：从上面图中可以看到开发工具由以下几个区域组成：功能预览区：代码编辑保存，开发工具会自动编译并生成预览，在该区域可以及时看到小程序渲染后的效果；文件浏览区：也就是文件浏览器，树状图形式可以展开和收拢；代码编辑区：提供代码阅读、搜索和编辑提示功能；网络调试区：集成的是google开发工具组件，功能相信大家已经很熟悉。最上面一排的按钮功能区，主要包括编译、代码上传和代码仓库版本管理以及云服务入口功能等。这里唯一需要普及的是小程序的代码构成。c.小程序代码组成一个小程序通常由一个描述整体程序的 app 和多个描述各自页面的 page页面模块组成。其中app主体部分由三个文件组成，必须放在项目的根目录，文件为：app.js: 控制小程序的全局业务逻辑；app.json：小程序的全局公共配置信息；app.wxml：小程序的全局公共样式，每个页面模块由4钟类型的文件组成，放置一个目录里面，四种类型的文件为：.json 后缀的 JSON 配置文件：存放配置信息；.wxml 后缀的 WXML 模板文件：页面内容模板，支持变量的动态渲染；.wxss 后缀的 WXSS 样式文件：页面样式定义；.js 后缀的 JS 脚本逻辑文件：js实现的业务逻辑，是页面模块中最重要的文件。比如我们项目的代码结构组成如下图所示：更多信息可以参考文档：小程序目录结构和代码构成。前端设计我们先确定小程序的总体展现框架，在app.wxml圈定整体结构： 1{\r\n 2  \"cloud\": true,\r\n 3  \"pages\": [\r\n 4    \"pages/home/home\",//home tab页面\r\n 5    \"pages/position/position\",//定位服务页面\r\n 6    \"pages/drivers/drivers\",//司机和乘客发布的行程列表页面\r\n 7    \"pages/myroutes/myroutes\",//我的历史行程\r\n 8    \"pages/messages/messages\",//“message”tab页面\r\n 9    \"pages/chat/chat\",//聊天会话页面\r\n10    \"pages/detail/detail\",//行程信息详情\r\n11    \"pages/certificate/certificate\",//企业认证页面\r\n12    \"pages/enterprise/enterprise\",//\r\n13    \"pages/mine/mine\" //“我的”tab页面\r\n14  ],\r\n15  \"window\": {\r\n16    \"backgroundTextStyle\": \"light\",\r\n17    \"navigationBarBackgroundColor\": \"#fff\",\r\n18    \"navigationBarTitleText\": \"WeChat\",\r\n19    \"navigationBarTextStyle\": \"black\"\r\n20  },\r\n21  \"tabBar\": {\r\n22    \"color\": \"#ccc\",\r\n23    \"selectedColor\": \"#35495e\",\r\n24    \"borderStyle\": \"white\",\r\n25    \"backgroundColor\": \"#f9f9f9\",\r\n26    \"list\": [\r\n27      {\r\n28        \"text\": \"首页\",\r\n29        \"pagePath\": \"pages/home/home\",\r\n30        \"iconPath\": \"resources/icon_home.png\",\r\n31        \"selectedIconPath\": \"resources/icon_home.png\"\r\n32      },\r\n33      {\r\n34        \"text\": \"消息\",\r\n35        \"pagePath\": \"pages/messages/messages\",\r\n36        \"iconPath\": \"resources/icon_cate.png\",\r\n37        \"selectedIconPath\": \"resources/icon_home.png\"\r\n38      },\r\n39      {\r\n40        \"text\": \"我的\",\r\n41        \"pagePath\": \"pages/mine/mine\",\r\n42        \"iconPath\": \"resources/icon_member.png\",\r\n43        \"selectedIconPath\": \"resources/icon_home.png\"\r\n44      }\r\n45    ]\r\n46  },\r\n47  \"sitemapLocation\": \"sitemap.json\"\r\n48}\r\n其中\"cloud\": true表示我们接下来用到云服务，pages定义我们应用所有定义的页面模块路径，tabBar定义应用的展示框架，它是一个list结构，每个列表项目由tab名称、页面路径和图标路径组成。各个tab接下来详细介绍。首页Tab首页主要功能为司机和乘客发布行程计划，一旦行程计划发布就分别跳转到对应的列表页面。具体说就是，如果是乘客，则可以查看司机发布的出行列表信息，并可以邀请司机接单；如果是司机，则可以看到乘客的出行列表信息，并可以选择主动接单。我们将这一部分核心功能放在主页面内完成，因为无论是司机还是乘客都有共同的行为：发布行程信息，且基本项目一样，故可以复用该功能。a.行程计划行程计划页面是司机和乘客发布行程的主入口，主要展示行程发布的起始位置和价格等。我们定义一个模板：publishRoute.wxml，有关模板的更多信息可以参考：模板。 1<template name=\"publishRoute\">\r\n 2  <form bindsubmit=\"publishRoute\">\r\n 3      <view style=\"display: flex;flex-direction: column;\">\r\n 4          <input bindtap=\"inputStartPosition\" style='padding: 10rpx;width:300px;margin-top: 10px;' placeholder=\"当前位置?\" value=\"{{startLocation.title}}\"></input>\r\n 5          <input name=\"startLocation\" style='display:none;' value=\"{{startLocation.title}}\"></input>\r\n 6          <input name=\"startAddr\" style='display:none;' value=\"{{startLocation.title}}\"></input>\r\n 7          <input name=\"startLatitude\" style='display:none;' value=\"{{startLocation.location.lat}}\"></input>\r\n 8          <input name=\"startLongitude\" style='display:none;' value=\"{{startLocation.location.lng}}\"></input>\r\n 9          <input bindtap=\"inputEndPosition\" style='padding: 10rpx;width:300px;'placeholder=\"想要去哪儿?\" value=\"{{endLocation.title}}\"></input>\r\n10          <input name=\"endLocation\" style='display:none;' value=\"{{endLocation.title}}\"></input>\r\n11          <input name=\"endAddr\" style='display:none;' value=\"{{endLocation.title}}\"></input>\r\n12          <input name=\"endLatitude\" style='display:none;' value=\"{{endLocation.location.lat}}\"></input>\r\n13          <input name=\"endLongitude\" style='display:none;' value=\"{{endLocation.location.lng}}\"></input>\r\n14          <input name=\"price\" type=\"number\"style='padding: 10rpx;width:300px;'placeholder=\"出价（单位:元）\"></input>\r\n15          <view class=\"btn-area\">\r\n16            <button type=\"primary\" formType=\"submit\">发布行程</button>\r\n17          </view>\r\n18      </view>\r\n19  </form>\r\n20</template>\r\n其中style='display:none;'的input组件是隐藏域，在表单提交时用到，它们的值在搜索定位完成后回显。输入起始位置的input组件分别绑定到事件回调函数inputStartPosition和inputEndPosition，当输入焦点落到输入框时候，调用对应函数进入搜索定位页面。我们将模版导入到首页home.wxml中: 1view class=\"nav\">\r\n 2  <view class='{{isDriver?\"default\":\"red\"}}'bindtap=\"passengerTabed\">我是乘客</view>\r\n 3  <view class='{{isDriver?\"red\":\"default\"}}' bindtap=\"driverTabed\">我是司机</view>\r\n 4</view>\r\n 5<view class='{{isDriver?\"show\":\"hidden\"}}'>\r\n 6  <import src=\"../home/publishRoute.wxml\"/>\r\n 7  <template is=\"publishRoute\" data=\"{{isDriver:isDriver,startLocation:startLocation,endLocation:endLocation,dateTimeArray:dateTimeArray,dateTime:dateTime}}\"/>\r\n 8</view>\r\n 9<view class=\"{{isDriver?'hidden':'show'}}\">\r\n10 <import src=\"../home/publishRoute.wxml\"/>\r\n11 <template is=\"publishRoute\" data=\"{{isDriver:isDriver,startLocation:startLocation,endLocation:endLocation,dateTimeArray:dateTimeArray,dateTime:dateTime}}\"/>\r\n12</view>\r\n13因为publishRoute.wxml作为home.wxml内容的一部分而存在，故我们将回调函数inputStartPosition和inputEndPosition定义在home.js文件中：\r\n14  inputStartPosition: function (e) {\r\n15    wx.navigateTo({\r\n16      url: '../position/position?isStartPos=true&isDriver=' + this.data.isDriver\r\n17    })\r\n18  },\r\n19  inputEndPosition: function (e) {\r\n20    wx.navigateTo({\r\n21      url: '../position/position?isStartPos=false&isDriver=' + this.data.isDriver\r\n22    })\r\n23  }\r\n在上面回调函数中导航到位置搜索页面。通过下面我们详细介绍搜索定位的实现。当发布行程的必要信息填写完毕后提交发布，发布事件回调函数绑定在form表单上：，函数定义接下来我们再做介绍。有关小程序事件的更多信息可以参考文档：小程序事件。b.位置搜索搜索页面提供位置模糊搜索功能，示意图如下：我们创建页面模块position，提供搜索关键词的查询、搜索历史记录查询等高级功能，为此我们把这部分功能封装为一个模块。为了简化开发，这里引入了一个第三方开源组件，可以参考: https://github.com/icindy/wxSearch 。 这里我们不需要这么复杂的功能，只是将我们根据关键词搜索到的候选位置信息展现在下拉列表即可。 wxSearch的展现部分核心代码wxSearch.wxml模板内容为： 1<template name=\"wxSearch\">\r\n 2  <view class=\"wxSearch\" bindtap=\"wxSearchTap\"  style=\"display:{{wxSearchData.view.isShow ? 'block':'none'}};height:{{wxSearchData.view.seachHeight}}px;top:{{wxSearchData.view.barHeight}}px;\">\r\n 3    <view  class=\"wxSearchInner\">\r\n 4        <view class=\"wxSearchMindKey\">\r\n 5            <view class=\"wxSearchMindKeyList\">\r\n 6                <block wx:for=\"{{wxSearchData.mindKeys}}\">\r\n 7                    <view class=\"wxSearchMindKeyItem\" bindtap=\"wxSearchKeyTap\" data-key=\"{{item}}\">{{item}}</view>\r\n 8                </block>\r\n 9            </view>\r\n10        </view>\r\n11      </view>\r\n12    </view>\r\n13</template>\r\nwxSearchData.mindKeys这里就是将位置列表遍历显示出来。在position.wxml中引入上述代码： 1<import src=\"wxSearch/wxSearch.wxml\"/>\r\n 2<form bindsubmit=\"confirm\">\r\n 3  <view class=\"wxSearch-section\">\r\n 4    <view class=\"wxSearch-pancel\">\r\n 5      <input name=\"position\" bindinput=\"wxSearchInput\" bindfocus=\"wxSerchFocus\" value=\"{{wxSearchData.value}}\" bindblur=\"wxSearchBlur\" class=\"wxSearch-input\" placeholder=\"搜索\"/>\r\n 6      <button class=\"wxSearch-button\" size=\"mini\" formType=\"submit\" plain=\"true\">确定</button>\r\n 7    </view>\r\n 8  </view>\r\n 9</form>\r\n10<template is=\"wxSearch\" data=\"{{wxSearchData}}\"/>\r\n11<view class=\"container\">\r\n12</view>\r\n然后在postion.js中定义函数wxSearchInput： 1 wxSearchInput: function (e) {\r\n 2    var that = this\r\n 3    this.data.queryLocations=[]\r\n 4    console.log(\"Searching \" + e.detail.value)\r\n 5    getApp().globalData.qqmapsdk.getSuggestion({\r\n 6      keyword: e.detail.value,\r\n 7      region: getApp().globalData.city,\r\n 8      success: function (res) {\r\n 9        var targets=new Array()\r\n10        for (let i = 0; i < res.data.length; i++) {\r\n11            targets.push(res.data[i].title)\r\n12            that.data.queryLocations[res.data[i].title] = res.data[i]\r\n13        }\r\n14        WxSearch.initMindKeys(targets)\r\n15      }\r\n16    })\r\n17    WxSearch.wxSearchInput(e, that); \r\n18  }\r\n其中WxSearch.initMindKeys(targets)将搜索到的候选位置名称放入wxSearch组件展示。当提交确认表单，将返回上一页面即home页面，将查询到的位置详细信息回显到上层页面，表单提交处理逻辑为： 1  confirm: function (event) {\r\n 2    console.log(event)\r\n 3    //WxSearch.wxSearchAddHisKey(this);\r\n 4    let pages = getCurrentPages();//当前页面\r\n 5    let prevPage = pages[pages.length - 2];//上一页面\r\n 6    var data={}\r\n 7    if (this.data.isStartPos=='true'){\r\n 8      data = { isStartPos: this.data.isStartPos, startLocation: this.data.selectedLocation}\r\n 9    }else{\r\n10      data = { isStartPos: this.data.isStartPos, endLocation: this.data.selectedLocation}\r\n11    }\r\n12    //直接给上一页面赋值\r\n13    prevPage.setData(data);\r\n14    wx.navigateBack({\r\n15      delta: 1\r\n16    })\r\n17  }\r\n有关页面导航接口的详细信息可以参考：页面导航。qqmapsdk.getSuggestion就是接下来要介绍的定位服务。c.定位服务上面调用的api接口：qqmapsdk.getSuggestion用的是腾讯位置服务：提供了地点搜索、关键词提示、（逆）地址解析、路径规划、距离计算、获取城市等功能。接口getSuggestion(options:Object) 中有两个比较重要的参数：关键词：keyword和当前区域：region。其中region参数可选，可以设置城市名，用于限定搜索范围，默认是全国。调用该接口需要申请密钥和下载JavaScriptSDK。有关该接口如何使用的更多信息可以参考官方文档：申请密钥。在本小程序中，我们使用到根据输入关键词获取位置列表接口的详细指导可以参考：获取位置列表接口。这里详细介绍下如何获取当前region，因为当前region使用贯穿于打开小程序的整个请求生命周期，所以把获取的region作为全局变量，在小程序启动时候调用。我们在app.js中加载sdk组件：1var QQMapWX = require('utils/qqmap-wx-jssdk1.0/qqmap-wx-jssdk.js');\r\n2App({\r\n3  onLaunch: function () {\r\n4    var that = this;\r\n5    that.globalData.qqmapsdk = new QQMapWX({\r\n6      key: conf.getQqMapKey()\r\n7    });\r\n8}\r\n9})\r\n为了能够获取到当前region，首先需要获取到当前位置的经纬度坐标，然后根据经纬度坐标解析出文字表示的region，具体步骤如下：1. 获取当前经纬度坐标这里我们使用微信小程序提供的api接口，接口的详细说明可以参考文档：经纬度坐标 1   wx.getLocation({\r\n 2      type: \"gcj02\",\r\n 3      success: function (res) {\r\n 4        console.log(res)\r\n 5        var latitude = res.latitude\r\n 6        var longitude = res.longitude\r\n 7        that.globalData.location = {\r\n 8          latitude: latitude,\r\n 9          longitude: longitude\r\n10        }\r\n11      }\r\n12    })\r\n2. 逆地址解析这里我们用到腾信位置服务的另一个接口：reverseGeocoder(options:Object)，该接口提供由坐标到坐标所在位置的文字描述的转换，输入坐标返回地理位置信息和附近poi列表。有关该接口的详细信息可以参考这里：逆地址解析我们在home.js首页加载时候调用获取当前城市位置的文字描述。 1onLoad: function (option) {\r\n 2getApp().globalData.qqmapsdk.reverseGeocoder({\r\n 3      location: {\r\n 4        latitude: getApp().globalData.location.latitude,\r\n 5        longitude: getApp().globalData.location.longitude\r\n 6      },\r\n 7      success: function (res) {\r\n 8        console.log(res);\r\n 9        const { city } = res.result.address_component\r\n10        getApp().globalData.city = city\r\n11      }\r\n12  }）\r\n13}\r\n这里将上面获取的经纬度参数传进去，返回城市city名称。d.行程发布回到发布行程的函数定义，因为我们需要持久化用户的行程信息，这里我们使用了腾讯的云开发能力。所谓云开发能力就是微信为开发者提供了全套的云原生支持和微信服务支持，弱化后端开发和运维概念，用户无须搭建自己的服务器即可调用云端API实现自己的业务逻辑，目前微信提供的云开发能力包括云函数、云数据库、存储以及云调用。我们这里使用到云数据库。云数据库是一个 JSON 数据库，数据库中的每条记录都是一个 JSON 格式的对象。一个数据库可以有多个集合（相当于关系型数据中的表），集合可看做一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 对象。使用云数据库需要先初始化，获取数据库实例的引用，我们在app.js中应用启动时候调用：1App({\r\n2  onLaunch: function () {\r\n3    wx.cloud.init({\r\n4      env: conf.getCloudEnv()\r\n5    })\r\n6  }\r\n7})\r\n其中env参数指定获取的数据库实例所在环境，比如开发环境和生产环境，用于数据库实例的区分。获取数据库实例之后，我们还需要通过文章开头提到的云开发入口，登录控制台创建集合：通过控制台我们可以手动创建集合，对集合进行增删改查，数据导入导出等功能。除此之外，集合还提供了丰富的常用api调用接口。有关云数据库的更多信息可以参考这里：云数据库。回到我们发布行程记录，虽然司机和乘客行程信息可以共享一个集合，但是为了方便后续的数据检索和分析，我们将其分开存储，分别命名为driver_route和passenger_route。行程记录包含的基本信息如下：基本字段包括用户的openid、起始位置（包含经纬度坐标和经过转换后的文字表示的地址）、价格、发布时间、出发时间以及用户信息（包含用户的图像、注册地）等。以下是司机发布行程核心逻辑，这里省略有关认证状态的验证逻辑: 1publishRoute: function (event) {\r\n 2    var userInfo = getApp().globalData.userInfo\r\n 3    var openId = getApp().globalData.openId\r\n 4    var that=this\r\n 5    userInfo.openId = openId\r\n 6    var route_collection = that.data.isDriver ? 'driver_route': 'passenger_route';\r\n 7    console.log(\"publish \" + route_collection)\r\n 8    publishRoute.addRoute(db, route_collection, event, userInfo)\r\n 9     wx.navigateTo({\r\n10     url: '../drivers/drivers?isDriver=' + that.data.isDriver\r\n11      })\r\n12}\r\npublishRoute.addRoute根据当前用户角色是司机还是乘客将记录存到不同的集合里面，定义如下： 1var utils = require('util.js');\r\n 2function addRoute(db,collect,event,userInfo){\r\n 3  db.collection(collect).add({\r\n 4    // data 字段表示需新增的 JSON 数据\r\n 5    data: {\r\n 6      // _id: 'todo-identifiant-aleatoire', \r\n 7      // 可选自定义 _id，在此处场景下用数据库自动分配的就可以了\r\n 8      publishDate: utils.formatTime(new Date()),\r\n 9      userInfo: userInfo,\r\n10      // endPoint: new db.Geo.Point(113, 23),\r\n11      startLocation: {\r\n12        address:event.detail.value.startLocation,\r\n13        addr: event.detail.value.startAddr,\r\n14        longitude: event.detail.value.startLongitude,                          \r\n15        latitude:event.detail.value.startLatitude\r\n16      },\r\n17      endLocation: {\r\n18        address:event.detail.value.endLocation,\r\n19        addr: event.detail.value.endAddr,\r\n20        longitude: event.detail.value.endLongitude, \r\n21        latitude:event.detail.value.endLatitude\r\n22      },\r\n23      price: event.detail.value.price,\r\n24      routeTime: event.detail.value.routeTime,\r\n25      routeTimeMills: new Date(event.detail.value.routeTimeMills).getTime()\r\n26    }\r\n27  })\r\n28}\r\ne.出行列表在出行列表里面，我们主要披露行程的创建人昵称、价格、起始位置和出发时间。我们新建driver页面模块。driver.wxml实现页面展示内容： 1{{isDriver?\"寻找的乘客列表\":\"寻找的司机列表\"}}\r\n 2<block wx:for=\"{{routes}}\" wx:for-item=\"route\">\r\n 3  <view class=\"list-item\" data-routeId=\"{{route._id}}\" bindtap=\"detail\">\r\n 4    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 5        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" mode=\"{{driver}}\" src=\"{{route.userInfo.avatarUrl}}\"></image>\r\n 6    </view>\r\n 7    <view class='right'>\r\n 8      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 9          <label class='title'>{{route.userInfo.gender}}</label>\r\n10          <label class='title'>{{route.userInfo.nickName}}</label>\r\n11      </view>\r\n12      <label class='price'>¥{{route.price}}</label>\r\n13    </view>\r\n14  </view>\r\n15  <view style=\"margin-top:30px;\">\r\n16    <view style=\"display: flex;flex-direction: column;margin:10px\">\r\n17        <label class='position'>{{route.startLocation.addr}}</label>\r\n18        <label class='position'>{{route.endLocation.addr}}</label>\r\n19        <label class='position'>{{route.routeTime}}</label>\r\n20      </view>\r\n21  </view>\r\n22</block>\r\n其中routes就是我们获取到的出行记录列表，注意到 每条记录绑定了一个到达详情页的回调函数和当前行程记录id，接下来再介绍。获取记录列表的函数定义如下： 1//pages/drivers/drivers.js\r\n 2const db = wx.cloud.database()\r\n 3 onLoad: function (options) {\r\n 4    this.setData({ isDriver: options.isDriver=='true'?true:false })\r\n 5    if (this.data.isDriver)\r\n 6      publishRoute.get_passenger_route(db, this,null)\r\n 7    else\r\n 8      publishRoute.get_driver_route(db, this, null)\r\n 9  }\r\n10这里我们同样是根据当前用户角色加载不同的出行记录：\r\n11function get_driver_route(db, that, condition){\r\n12  var coll=db.collection('driver_route')\r\n13  if (condition != null)\r\n14    coll = coll.where(condition)\r\n15   coll.get({\r\n16      success: function (res) {\r\n17        // res.data 是一个包含集合中有权限访问的所有记录的数据，不超过 20 条\r\n18        that.setData({ routes: res.data})\r\n19      }\r\n20    })\r\n21}\r\nf. 出行记录详情我们创建新的页面模块：detail，用用于展示记录详情，在详情页可以根据不同的角色进行不同的操作，比如如果是司机的出行记录，那么乘客可以邀请司机接单，如果是乘客记录，那么司机可以主动接单。原型图如下所示：detail.wxml页面展示内容为： 1  <view wx:for=\"{{routes}}\" wx:for-item=\"route\">\r\n 2   <view class=\"list-item\">\r\n 3    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 4        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" mode=\"{{driver}}\" src=\"{{route.userInfo.avatarUrl}}\"></image>\r\n 5    </view>\r\n 6    <view class='right'>\r\n 7      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 8          <label class='title'>{{route.userInfo.gender}}</label>\r\n 9          <label class='title'>{{route.userInfo.nickName}}</label>\r\n10      </view>\r\n11      <label class='price'>¥{{route.price}}</label>\r\n12    </view>\r\n13  </view>\r\n14  <view>\r\n15    <view style=\"display: flex;flex-direction: column;\">\r\n16        <label class='position'>{{route.startLocation.addr}}</label>\r\n17        <label class='position'>{{route.endLocation.addr}}</label>\r\n18        <label class='position'>{{route.routeTime}}</label>         \r\n19    </view>\r\n20  </view>\r\n21  <map class=\"map\" longitude=\"{{route.startLocation.longitude}}\" latitude=\"{{route.startLocation.latitude}}\"></map>\r\n22</view>\r\n23\r\n24<form bindsubmit=\"formSubmit\" report-submit=\"true\">\r\n25   <view>\r\n26    <input name=\"receiver_openid\" style='display:none;' value=\"{{route.publish_openid}}\"></input>\r\n27    <button formType=\"submit\" lang=\"zh_CN\" type=\"primary\">{{isDriver=='true'?'接单':'请他来接我'}}</button>\r\n28  </view>\r\n29</form>\r\n其中详情页面的内容跟列表中每个出行记录内容差不多，唯一差别就是样式而且多了个map地图组件，用户可视化展示出行记录的地点。map组件只需要告诉需要展示的经纬度既可。有关地图组件的详细信息可以参考文档：地图组件。记录详情页面根据行程id从集合读取一条记录： 1// pages/drivers/drivers.js\r\n 2const db = wx.cloud.database()\r\n 3 onLoad: function (options) {\r\n 4    var isDriver=(options.isDriver == 'true' ? true : false);\r\n 5    var routeId=options.routeId\r\n 6    console.log(options)\r\n 7    if (isDriver)\r\n 8      publishRoute.get_driver_route(db, this, { _id: routeId})\r\n 9    else\r\n10      publishRoute.get_passenger_route(db, this, { _id: routeId })\r\n11    this.setData({\r\n12      isDriver: isDriver,\r\n13    })\r\n14  }\r\n15})\r\n集合读取记录跟读取记录列表一样，唯一的区别就是可以根据出行id筛选一条记录。当乘客邀请接单时候，触发表单提交： 1formSubmit: function (event) {\r\n 2    console.log(event.detail.formId)\r\n 3    wx.navigateTo({\r\n 4      url: '../chat/chat?id=' + event.detail.value.receiver_openid,\r\n 5      success: function (res) {\r\n 6        console.log(res)\r\n 7      }, fail: function (res) {\r\n 8        console.log(res)\r\n 9      }\r\n10    })\r\n11  }\r\n实现逻辑是跳转到聊天页面，参数是司机的openid。有关聊天会话页面的实现逻辑，下文详细介绍。消息Tab消息Tab页面主要由最近的消息聊天列表组成，点击消息列表项，进入聊天详情页面。我们在这里只实现一个简单的聊天窗口，能够发送消息和展示聊天内容。系统交互图如下：a.聊天列表我们先创建一个message的页面模块，message.wxml内容为： 1<block wx:for=\"{{partners}}\" wx:for-item=\"partner\">\r\n 2  <view class=\"list-item\" data-id=\"{{partner._id}}\" bindtap=\"chat\">\r\n 3    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 4        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" src=\"{{partner.receiver_avatar}}\"></image>\r\n 5    </view>\r\n 6    <view class='right'>\r\n 7      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 8          <label class='title'>{{partner.receiver_nick}}</label>\r\n 9      </view>\r\n10    </view>\r\n11  </view>\r\n12</block>\r\nmessage.js实现从数据库集合中获取最近的聊天对象列表，当点击聊天对象进入会话详情页： 1Page({\r\n 2  data: {\r\n 3    partners: null\r\n 4  },\r\n 5  onLoad: function () {\r\n 6    this.setData({\r\n 7      partners: publishMessage.getPartners(db,this)\r\n 8      })\r\n 9  },\r\n10  chat: function (event) {\r\n11    wx.navigateTo({\r\n12      url: '../chat/chat?id=' + event.currentTarget.dataset.id,\r\n13      success: function (res) {\r\n14        console.log(res)\r\n15      }\r\n16    })\r\n17  }\r\n18})\r\npublishMessage.getPartners从数据集合中读取聊天列表，这里将最近聊天的搭档单独存储，提高读取效率，格式如下：b.会话详情会话详情不仅可以展示历史聊天记录，还可以实时互动发送消息。创建一个chat的页面模块，chat.wxml内容定义如下： 1<view class='news'>\r\n 2  <view class='new_top_txt'>您正在与{{tabdata.nickname}}进行沟通</view>\r\n 3  <view class=\"historycon\">\r\n 4    <scroll-view scroll-y=\"true\" scroll-top=\"{{scrollTop}}\" class=\"history\" wx:for=\"{{messages}}\" wx:key=''>\r\n 5      <view>\r\n 6        <text class='time'>18:30</text>\r\n 7      </view>\r\n 8      <block wx:if='{{item.sender_openid==\"222\"}}'>\r\n 9        <view class='my_right'>\r\n10          <view class='page_row'>\r\n11            <text class='new_txt'>{{item.content}}</text>\r\n12            <image wx:if='{{item.sender_openid==\"222\"}}' src='{{item.sender_avatar}}' class='new_imgtent'></image>\r\n13            <view class='sanjiao my'></view>\r\n14          </view>\r\n15        </view>\r\n16      </block>\r\n17      <block wx:else>\r\n18        <view class='you_left'>\r\n19          <view class='page_row'>\r\n20            <image class='new_img' src='{{item.receiver_avatar}}'></image>\r\n21            <view class='sanjiao you'></view>\r\n22            <text class='new_txt'>{{item.content}}</text>\r\n23          </view>\r\n24        </view>\r\n25      </block>\r\n26    </scroll-view>\r\n27  </view>\r\n28</view>\r\n29<view class='hei' id=\"hei\"></view>\r\n30<view class=\"sendmessage\">\r\n31  <input type=\"emoji\" bindinput=\"input\" confirm-type=\"done\" value='' placeholder=\"\" />\r\n32  <button style=\"width:80px;\" catchtap=\"send\">发送</button>\r\n33  <input style='display:none' type=\"\" bindinput=\"input\" confirm-type=\"done\" placeholder=\"\" />\r\n34  <image bindtap=\"upimg1\" class='jia_img' src='../../../images/jia_img.png'></image>\r\n35  </view>\r\n在chat.j里面主要关注两个函数，onLoad和send。前者是页面加载渲染历史聊天记录，后者发送及时消息: 1Page({\r\n 2  data: {\r\n 3    //当前聊天内容\r\n 4    message: '',\r\n 5    //聊天记录\r\n 6    messages:null,\r\n 7    logs:null\r\n 8  },\r\n 9  onLoad: function () {\r\n10    publishMessage.getMessages(db,this,{})\r\n11  },\r\n12  input: function (e) {\r\n13    this.data.message = e.detail.value\r\n14  },\r\n15  send: function (e) {\r\n16    var data = {\r\n17      receiver_openid: '222',\r\n18      sender_openid: getApp().globalData.openid,\r\n19      sender_nick: getApp().globalData.userInfo.nickName,\r\n20      receiver_nick: getApp().globalData.userInfo.nickName,\r\n21      sender_avatar: getApp().globalData.userInfo.avatarUrl,\r\n22      receiver_avatar: getApp().globalData.userInfo.avatarUrl,\r\n23      content: this.data.message,\r\n24    }\r\n25    publishMessage.sendMessage(db,'messages',data)\r\n26  }\r\n27})\r\n聊天消息我们也适用云数据库存储，存储格式如下：“我的”Tab“我的”Tab由两部分组成：功能列表和logo展示。其中功能列表包含3项，分别为车主认证、历史行程和联系我们。功能列表通过列表组件展示，点击列表项进入到详情页面。logo展示我们用个人信息来展示。a.功能列表我们创建mine页面模块：mine.wxml，页面展示核心内容为：1    <view class='myItemList' wx:for=\"{{itemList}}\" wx:key=\"{{index}}\" data-url=\"{{item.url}}\" bindtap='navBtn'>\r\n2        <image src='{{item.icon}}'></image>\r\n3        <view class='myItemName'>{{item.name}}</view>\r\n4    </view>\r\n列表项定义在mine.js中： 1Page({\r\n 2  /**\r\n 3   * Page initial data\r\n 4   */\r\n 5  data: {\r\n 6    itemList: [\r\n 7    { 'name': '车主认证', 'icon': '../../../images/address.png', 'url': '../certificate/certificate' },\r\n 8      { 'name': '历史行程', 'icon': '../../../images/order.png', 'url': '../myroutes/myroutes' },\r\n 9    { 'name': '联系我们', 'icon': '../../../images/contact.png', 'url': '' }\r\n10    ]\r\n11  },\r\n12  navBtn: function (e) {\r\n13    wx.navigateTo({\r\n14      url: e.currentTarget.dataset.url\r\n15    })\r\n16  }\r\n17})\r\n其中navBtn定义了列表项被点击时的跳转动作。我们以车主认证为例详细介绍。b 车主认证为简便起见，车主认证逻辑一次性上传所有证件材料，如身份证正反面照片、行驶证和驾驶证，上传图像组件支持多选和删除功能。证件材料上传之后，系统标记当前车主处于审核状态，当审核通过后，车主才可以进行运营接单。上传图片的交互图如下：创建certificate文件模块，certificate.wxml页面展示内容核心代码： 1<block>\r\n 2  <view class=\"question-form\">\r\n 3    <view class=\"question-images-area\">\r\n 4        <!-- 添加图片按钮 -->\r\n 5      <view class=\"question-images-tool\">\r\n 6        <button type=\"default\" size=\"mini\" bindtap=\"chooseImage\" wx:if=\"{{images.length < 6}}\">上传图片</button>\r\n 7      </view>\r\n 8      <view class=\"question-images\">\r\n 9        <block wx:for=\"{{images}}\" wx:key=\"*this\">\r\n10          <view class=\"q-image-wrap\">\r\n11            <!-- 图片缩略图  -->\r\n12            <image class=\"q-image\" src=\"{{item}}\" mode=\"aspectFill\" data-idx=\"{{index}}\" bindtap=\"handleImagePreview\"></image>\r\n13            <!-- 移除图片的按钮  -->\r\n14            <view class=\"q-image-remover\" data-idx=\"{{index}}\" bindtap=\"removeImage\">删除</view>\r\n15          </view>\r\n16        </block>\r\n17      </view>\r\n18    </view>\r\n19      <!-- 提交表单按钮 -->\r\n20    <button class=\"weui-btn\" type=\"primary\" bindtap=\"submitForm\">提交</button>\r\n21  </view>\r\n22</block>\r\n这里上传图像绑定了4个函数，分别是选取图像时候触发的函数chooseImage、点击图像预览触发的函数handleImagePreview、点击删除图片时候触发的函数removeImage以及表单提交触发的函数submitForm，在certificate.js详细来看：chooseImage：选取图像chooseImage使用了小程序API ：wx.chooseImage(Object object)，从本地相册选择图片或使用相机拍照，支持多选和压缩。有关该API的详细信息可以参考文档：chooseImage API。 1  chooseImage(e) {\r\n 2    wx.chooseImage({\r\n 3      sizeType: ['original', 'compressed'],  //可选择原图或压缩后的图片\r\n 4      sourceType: ['album', 'camera'], //可选择性开放访问相册、相机\r\n 5      success: res => {\r\n 6        const images = this.data.images.concat(res.tempFilePaths)\r\n 7        // 限制最多只能留下5张照片\r\n 8        this.data.images = images.length <= 5 ? images : images.slice(0, 5)\r\n 9        $digest(this)\r\n10      }\r\n11    })\r\n12  }\r\n在函数定义中将选取的图像存放在本地变量data.images中。removeImage：removeImage函数在点击删除按钮时候触发，实现逻辑很简单，只需要从本地变量data.images中去掉即可，splice(idx, 1)从指定位置处删除1张图片。1removeImage(e) {\r\n2    const idx = e.target.dataset.idx\r\n3    this.data.images.splice(idx, 1)\r\n4    $digest(this)\r\n5  }\r\nhandleImagePreviewhandleImagePreview图像预览使用了另一个API：wx.previewImage(Object object)，在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作。有关该接口的详细信息可以参考：wx.previewImage API。1  handleImagePreview(e) {\r\n2    const idx = e.target.dataset.idx\r\n3    const images = this.data.images\r\n4    wx.previewImage({\r\n5      current: images[idx],//当前预览的图片\r\n6      urls: images, //所有要预览的图片\r\n7    })\r\n8  }\r\nsubmitFormsubmitForm提交表单函数这里用到了腾讯的云存储服务，云存储提供了云端的文件上传和下载功能。其中上传接口为：wx.cloud.uploadFile，有关该接口的详细信息可以参考：cloud.uploadFile。使用云存储第一步就是初始化云存储： 1const db = wx.cloud.database() \r\n 2  submitForm(e) {\r\n 3    const arr = []\r\n 4    for (let path of this.data.images) {\r\n 5      var file = path.substr(path.indexOf('.')+1,path.length)\r\n 6      wx.cloud.uploadFile({\r\n 7        cloudPath: 'upload/' + file,\r\n 8        filePath: path, // 小程序临时文件路径\r\n 9      }).then(res => {\r\n10        // get resource ID\r\n11        console.log(res)\r\n12        arr.push(res.fileID)\r\n13        if (arr.length >= this.data.images.length){\r\n14          var openid = getApp().globalData.openid\r\n15//将上传成功后的图像地址存储在云数据库集合中。\r\n16          publishCertificate.save_certificate_images(db,openid,arr)\r\n17          wx.hideLoading()\r\n18          this.onLoad()\r\n19        }\r\n20      }).catch(error => {\r\n21        // handle error\r\n22        console.log(error)\r\n23        wx.hideLoading()\r\n24      })\r\n25    }\r\n26    wx.showLoading({\r\n27      title: '正在上传...',\r\n28      mask: true\r\n29    })\r\n30  }\r\n31})\r\n图像上传成功后，可以在云存储后台浏览、管理和下载图片，控制台如下所示：c. logo展示mine.wxml核心展示内容为： 1  <view class=\"userinfo\">\r\n 2    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\r\n 3    <block wx:else>\r\n 4      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n 5      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n 6    </block>\r\n 7   <view class=\"usermotto\">\r\n 8    <text class=\"user-motto\">{{motto}}</text>\r\n 9   </view>\r\n10  </view>\r\n其中motto: '雁归行'表示我们的品牌名，<button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 用于获取用户信息，button可以跟获取用户信息、进入客服会话和打开app等动作绑定，有关button的详细信息可以参考这里：button。获取用户信息我们用到API：wx.getUserInfo(Object object)。有关该接口的详细信息可以参考：getUserInfo API。需要注意的是该接口返回的用户信息仅包括用户昵称，性别，所在城市等，不包括用户openid等敏感信息，如果需要获取这些敏感信息，需要对返回的字段 encryptedData解密，有关获取这些这些信息的解密方法可以参考这里，本文不做进一步介绍：encryptedData解密。mine.js里面调用获取用户信息如下：1      wx.getUserInfo({\r\n2        success: res => {\r\n3          app.globalData.userInfo = res.userInfo\r\n4          this.setData({\r\n5            userInfo: res.userInfo,\r\n6          })\r\n7        }\r\n8      })\r\n但是openid是小程序不可少的一部分，那如何获取当前用户的openid呢？这就需要调用登录接口：wx.login(Object object)，通过该接口获取登录凭证（code），然后再通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等。这个过程分为两步：登录获取code 1wx.login({\r\n 2  success (res) {\r\n 3    if (res.code) {\r\n 4      //发起网络请求\r\n 5      wx.request({\r\n 6        url: 'https://test.com/onLogin',\r\n 7        data: {\r\n 8          code: res.code\r\n 9        }\r\n10      })\r\n11    } else {\r\n12      console.log('登录失败！' + res.errMsg)\r\n13    }\r\n14  }\r\n15})\r\n这里通过登录拿到code，有效期5分钟。有关该接口的详细信息可以参考：login。2. code换取openid开发者需要在开发者服务器后台调用 auth.code2Session，使用 code 换取 openid 和 session_key 等信息，请求地址为：GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code有关该接口的详细信息可以参考： auth.code2Session。其中appi和secret是申请小程序时候分配的。完整的调用过程如下： 1//app.js\r\n 2 var conf = require('config.js');\r\n 3    // 登录\r\n 4    wx.login({\r\n 5      success: res => {\r\n 6        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n 7        var l = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + conf.getAppKey() + '&secret=' +conf.getAppSecret()+'&js_code=' + res.code + '&grant_type=authorization_code';\r\n 8        wx.request({\r\n 9          url: l,\r\n10          data: {},\r\n11          method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT  \r\n12          // header: {}, // 设置请求的 header  \r\n13          success: function (res) {\r\n14            console.log(res.data.openid)\r\n15            that.globalData.openid = res.data.openid\r\n16          }\r\n17        });\r\n18      }\r\n19    })\r\n开发调试举例1. apis.map.qq.com不在合法请求域名列表中，如下图所示。原因是小程序对访问的请求有个白名单机制，凡不在这个名单列表的域名都被视为有安全风险，是不被允许访问的，解决办法就是登录 小程序后台 “开发”>“开发”设置的”服务器域名“将该域名添加到列表即可。然后在小程序的开发集成工具“项目设置”刷新域名列表。2. 调用qqmapsdk.reverseGeocoder接口提示IP未授权，如下图所示。解决办法：进入腾讯位置服务控制台https://lbs.qq.com/dev/console/key/manage，选择“Key管理”>\"Key设置\"，将当前机器IP添加到授权IP框。"}
{"title": "小程序多端差异调研报告(微信，支付宝，头条，QQ) ", "author": "Rolan", "pub_time": "2019-11-4 00:32", "content": "已经使用uni-app开发并发布了一个跨端小程序啦，嘻嘻嘻！须知这是一份详细的小程序各特性各端真机调研对比报告测试机：iPhone7 plus IOS 12.4.1客户端：微信7.0.5，支付宝10.1.72，今日头条7.4.0，抖音8.1.0，QQ8.1.5.461:no_entry_sign:️ 百度小程序只有商户才能注册，个人开发者无法注册，没有appid功能受限（如百度开发者工具无法使用预览功能导致无法真机测试），所以暂时不测百度小程序用户信息授权授权方式：【\t头条 】用户信息授权方式还停留在微信小程序第一版，即直接调用 getUserInfo 弹出授权弹窗，如果用户选择\t允许 ，则后续调用不再出弹窗，而是直接走 success 回调。如果用户选择\t取消 ，则后续调用也不再出弹窗，而是直接走 fail 回调【\t微信 】【QQ】【\t支付宝 】则采用 button + 回调事件的方式调起授权弹窗，如果用户选择\t允许 ，则后续点击不再出弹窗，直接走回调。如果用户选择\t取消 ，则后续点击继续弹窗询问授权授权信息清除方式：【微信】删除小程序即可清除授权信息【支付宝】我的-设置-安全设置-账号授权【今日头条】我的-系统设置-清除缓存。【抖音】未找到清除方法【QQ】未找到清除方法（据说开放小程序的QQ版本尚未灰度发布）小程序登录【微信】\twx.login【QQ】\tqq.login 基本同微信【支付宝】\tmy.getAuthCode【\t头条 】大致同微信，未找到模型文档分享行为：【微信】直接调起聊天对话列表进行选择【QQ】调起分享渠道列表：QQ好友QQ空间点右上角三个点调起的列表还有微信好友和朋友圈两个项，在微信中打开qq小程序是走中间页【\t支付宝 】调起分享渠道列表：支付宝朋友圈支付宝联系人微信好友|QQ好友(保存支付宝生成的分享图片后打开支付宝扫码)钉钉好友(中间页自动打开支付宝小程序，中间页不自动关闭)新浪微博(中间页自动打开支付宝小程序，和钉钉一个中间页)【\t头条 】调起分享渠道列列表：转发到头条微信好友|微信朋友圈(生成口令，复制口令后打开今日头条弹出识别弹窗)QQ|QQ空间(打开中间页，点击打开(QQ空间点了没反应)，出现另一个中间页，自动打开AppStore，再点打开调起今日头条，最后居然没打开那个小程序 !!!)【抖音】调起分享渠道列列表：多闪好友微信好友|微信朋友圈|QQ好友|QQ空间(生成抖音码图片，打开抖音扫码识别)【头条】\twebview的转发暂未支持 ：【今日头条】能转发，但转发的链接点击后总是提示加载失败！也可能是小程序未发布的原因，扫\tuni-app官方demo 进行 webview转发是能正常打开的【抖音】不支持转发，右上角胶囊只有一个关闭按钮跳转到其他小程序【微信】\t支持 (navigateToMiniProgramAppIdList + navigateToMiniProgram)【QQ】\t支持【头条】\t支持 (navigateToMiniProgramAppIdList + navigateToMiniProgram)【支付宝】\t支持 (后台配置 + navigateToMiniProgram):no_entry_sign:️ ️QQ，支付宝和头条未真机验证，因为须要一个其他小程序的appId客服会话【微信】支持(\tbutton open-type=\"contact\" )【QQ】支持，须用户加一个客服机器人为好友【支付宝】支持(\tcontact-button )【头条】\t不支持 。支付【微信】\t支持 (调起微信支付)【QQ】\t支持 (调起QQ支付)【支付宝】\t支持 (调起支付宝支付)【头条】\t支持 (调起支付宝App进行支付):no_entry_sign: ️QQ，支付宝和头条未真机验证，因为支付接口只有商户才有权限地理位置【微信】\t支持 (\t须在app.json中配置permission字端 )，用户拒绝授权后再次调用不再出询问弹窗，而是直接走fail回调【QQ】支持。真机行为同微信。QQ开发者工具上拒绝授权再次调用仍会出询问弹窗【头条】\t支持 ，同微信【支付宝】\t支持 ，用户拒绝授权后再次调用继续出询问弹窗视频播放【微信】\t支持【QQ】支持【头条】\t支持【支付宝】支持？(\tuni-app里说 支付宝不支持，\t支付宝文档 也没找到video组件，但放在页面里video能正常渲染和播放，难道是昨天刚支持 )复制文字行为：【微信】【QQ】复制成功后有一个默认的复制成功toast且无法控制【支付宝】【头条】复制成功后没有toast权限：【支付宝】\tmy.setClipboard 此功能仅支持企业支付宝账号。实际情况是：在IDE上个人账号是可以复制的，但在真机上调用就会报\tERROR 4: 无权调用该接口 错误【微信】【QQ】【头条】无限制打电话【微信】【QQ】【支付宝】【头条】都支持收货地址【微信】\t支持【QQ】不支持【头条】\t支持 （实测【今日头条】支持，【抖音】不支持）【支付宝】\t支持 。但仅商户才有使用权限。且目前 my.getAddress 接口暂不支持在开发者工具调试和真机调试，仅支持真机预览相机/图片相关拍照/相册选图片【微信】【QQ】支持【支付宝】支持。IDE上会弹一个相册授权询问弹窗，真机上并没有弹窗【头条】支持。但会弹出两个询问弹窗（相机权限，相册权限）拍摄/相册选视频【微信】【QQ】支持【支付宝】支持。IDE上会弹一个相册授权询问弹窗，真机上并没有弹窗。须调用 my.chooseVideo(文档未找到)，uni.chooseVideo会报错【头条】支持。但会弹出两个询问弹窗（相机权限，相册权限）:warning:chooseVideo的maxDuration选项在【微信】和【支付宝】是只限制拍摄时长，在【头条】是同时限制相册选择视频时长和拍摄时长图片预览【微信】【QQ】【支付宝】【头条】都支持保存图片到相册【微信】【QQ】【头条】支持，弹窗仅询问一次【支付宝】\ttt.saveImageToPhotosAlbum 在IDE上报错\ttt.saveImageToPhotosAlbum is not a function ，在真机上报错\t无权调用该接口 ，文档未提及，猜测是仅商户可用，且不支持在开发者工具调试和真机调试，仅支持真机预览接口返回值差异getUserInfo【\t微信 】【\tQQ 】【\t支付宝 】【\t头条 】// 支付宝\r\n{\r\n  'nickName': 'test',\r\n  'gender': 'm',\r\n  'city': '北京市',\r\n  'province': '北京'\r\n  'countryCode': 'CN',\r\n  'avatar': 'https:\\/\\/tfs.alipayobjects.com\\/images\\/partner\\/T1_38eXnRiXXXXXXXX',\r\n  'code': '10000',\r\n  'msg': 'Success',\r\n}\r\n// 微信\r\n{\r\n  'nickName': 'test',\r\n  'gender': 1,\r\n  'city': 'Xinxiang',\r\n  'province': 'Henan',\r\n  'country': 'China',\r\n  'avatarUrl': 'https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCzUl7llykqrMLicpULvVfkbbL2bVDua4tI8ibjxq5E9ib1oPW3F4QazLIUdS2GsFMAGnrWSYjN05Ew/132'\r\n  'language': 'zh_CN',\r\n}\r\n// QQ\r\n{\r\n  'nickName': 'test',\r\n  'gender': 1,\r\n  'city': '新乡',\r\n  'province': '河南'\r\n  'country': '中国',\r\n  'avatarUrl': 'https://thirdqq.qlogo.cn/qqapp/1108100302/D64611B2AE700324589177922EEBA5F4/100',\r\n  'language': 'zh_CN',\r\n}\r\n// 头条系（今日头条，抖音，皮皮虾，西瓜视频分别取各自用户信息）\r\n{\r\n  'nickName': 'test',\r\n  'gender': 1,\r\n  'city': '新乡市',\r\n  'province': '河南省'\r\n  'country': '中国',\r\n  'avatarUrl': 'http://wx.qlogo.cn/mmhead/Q3auHgzwzM5uibSytRCXFs0Y3xSpdy12thibjWIoMrBIsf7FiaPp2ibnFg/0',\r\n  'language': '',\r\n}getSetting【\t微信 】【\t支付宝 】【\t头条 】【\tQQ 】// 微信 https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html\r\n[\r\n  'scope.userInfo', // 用户信息\r\n  'scope.userLocation', // 地理位置\r\n  'scope.address', // 通讯地址\r\n  'scope.record', // 录音功能\r\n  'scope.camera', // 摄像头\r\n  'scope.writePhotosAlbum', // 保存到相册\r\n\r\n  'scope.userLocationBackground', // 后台定位\r\n  'scope.invoiceTitle', // 发票抬头\r\n  'scope.invoice', // 获取发票\r\n  'scope.werun', // 微信运动步数\r\n]\r\n// 头条 https://developer.toutiao.com/dev/miniapp/uQjMy4CNyIjL0IjM\r\n[\r\n  'scope.userInfo', // 用户信息\r\n  'scope.userLocation', // 地理位置\r\n  'scope.address', // 通讯地址\r\n  'scope.record', // 录音功能\r\n  'scope.camera', // 摄像头\r\n  'scope.album',  // *保存到相册*\r\n]\r\n// 支付宝 https://docs.alipay.com/mini/api/xmk3ml#-1\r\n[\r\n  'userInfo', // 用户信息\r\n  'location', // 地理位置\r\n  'audioRecord', // 录音功能\r\n  'camera', // 摄像头\r\n  'album', // 保存到相册\r\n]\r\n// QQ https://q.qq.com/wiki/develop/game/frame/open-ability/authorize.html\r\n[\r\n  'scope.userInfo', // 用户信息\r\n  'scope.userLocation', // 地理位置\r\n  'scope.qqrun', // QQ运动步数\r\n  'scope.writePhotosAlbum', // 保存到相册\r\n  'scope.appMsgSubscribed', // 订阅消息\r\n]主要入口【微信】首屏对话列表下拉扫一扫发现->小程序搜索【支付宝】扫一扫搜索首页我的小程序【今日头条】我的->扫一扫搜索【抖音】搜索->扫一扫【QQ】扫一扫:bomb: 头条小程序陷阱目前仅在头条Android版本7.2.9及以上版本支持真机调试功能。iOS暂时不支持真机调试抖音App的小程序上没有打开调试器选项，右上角胶囊只有一个关闭按钮:bomb: 支付宝小程序陷阱my.getOpenUserInfo 用于获取支付宝会员基础信息，\t只能在真机上调试，无法在 IDE 中调试 ，也就是只要有用户授权的页面都需要推送到真机上开发调试！支付宝授权平台只返回tocken和uid，由\t开发者自己维护session有效期 ，\tcheckSession 方法不可用打开调试的调试器面板在调起用户授权弹窗时会消失，此时须使用真机调试:bomb: uni-app 陷阱uni.getSetting ，文档上说【支付宝】支持，调用却报错\t支付宝小程序，暂不支持getSetting，而直接调支付宝的api\tmy.getSetting 确是支持的uni.chooseVideo ，文档上说【支付宝】支持，调用却报错\t支付宝小程序，暂不支持chooseVideo ，而直接调支付宝的api my.chooseVideo(文档未找到) 确是支持的uni.chooseAddress ，文档上说【支付宝】不支持，实际上是支持的，只是需要调用\tmy.getAddress ，且仅商户才能使用uni.getImageInfo ，文档上说【头条】支持，调用却报错\t头条小程序，暂不支持getImageInfo，而直接调头条的api\ttt.getImageInfo 确是支持的:pushpin: TODO模版消息第三方插件uni-app 跨端小程序风险点后端接口。不同端的后端接口不一样，需要后端评估一下。举例：模版消息(\t微信 |\t支付宝 |头条 )；设计用户系统时需注意微信和QQ都有各自的openID和unionID，支付宝只有uid，头条只有openID；接入微信，QQ，支付宝支付时各种传参不一样分享转发。支付宝，头条小程序分享至微信和QQ的主要方式是生成口令或者生成小程序码图片或者走中间页，导致传播路径较长某些端重要功能缺失。举例：【头条】不支持客服会话。【抖音】不支持webview转发。【QQ】不支持收货地址某些端api缺失，可能导致某些功能无法实现第三方插件支持度"}
{"title": "如何实现微信小程序图像剪切？代码拿去用，不谢！ ", "author": "Rolan", "pub_time": "2019-11-4 00:41", "content": "前情回顾\r\n我在早先发布的文章《如何实现微信小程序换头像？三步帮你搞定！》中，提到实现微信小程序换头像需要三步：\r\n\r\n获取用户头像\r\n图片模板\r\n图片合成\r\n\r\n前文已经就获取用户头像和图片模板两个步骤进行了讲解，本文就来详细说说如何合成图片。\r\n图片合成的过程中非常重要的一块功能对图片进行剪切。该功能点很固定，大都是对图片进行拖拽、缩放后，在一定区域内剪切出一个固定长宽的图片。这类功能在app端和H5中都有很多成熟的插件供使用，接下来就来看看我在海豚趣图小程序中的头像剪切插件是如何实现的，欢迎大家提意见。\r\n为了更好地理解接下来的代码，建议大家先扫描体验一下图片裁剪效果。\r\n\r\n实现效果\r\n界面实现\r\n在H5中要实现图片的拖拽和缩放需要一大坨代码，具体实现网上有很多。小程序实现就简单的多了，通过 <movable-area> 和 <movable-view> 就可以实现上述功能\r\n<view class=\"clip-view\">\r\n  <!--\r\n    clipHeight、clipWidth 分别为剪切框的高和宽\r\n    imgHeight、imgWidth 分别对应图片的初始高和宽\r\n    imgUrl 为剪切图片的url地址\r\n  -->\r\n  <movable-area class=\"moveare\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \">\r\n    <movable-view scale=\"true\" scale-min=\"{{1}}\" damping=\"1000\" style=\"height: {{imgHeight}}px; width: {{imgWidth}}px; \" direction=\"all\" x=\"{{x}}\" y=\"{{y}}\" bindchange=\"_onChange\" bindscale=\"_onScale\">\r\n      <image class=\"clip-img\" src=\"{{imgUrl}}\" />\r\n    </movable-view>\r\n  </movable-area>\r\n  <!--剪切框 装饰用-->\r\n  <view class=\"clip-box\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \">\r\n    <!--剪切框四个角-->\r\n    <view class=\"clip-border clip-border-lt\"></view>\r\n    <view class=\"clip-border clip-border-rt\"></view>\r\n    <view class=\"clip-border clip-border-lb\"></view>\r\n    <view class=\"clip-border clip-border-rb\"></view>\r\n  </view>\r\n  <!--剪切图片用的canvas-->\r\n  <canvas class=\"clip-canvas\" id=\"img_clip_canvas\" canvas-id=\"img_clip_canvas\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \"></canvas>\r\n</view>\r\n复制代码组件属性\r\n组件的入参只需要原始图片的地址和图片剪切框的宽高\r\n/**\r\n * 组件的属性列表\r\n */\r\nproperties: {\r\n  // 原始图片路径（要剪切的图片）\r\n  imgUrl: {\r\n    type: String,\r\n    value: ''\r\n  },\r\n  // 剪切的宽度 (rpx)\r\n  clipWidth: {\r\n    type: Number,\r\n    value: 500\r\n  },\r\n  // 截切的高度 (rpx)\r\n  clipHeight: {\r\n    type: Number,\r\n    value: 500\r\n  }\r\n}\r\n复制代码组件data\r\n组件的data就会多一些记录图片拖拽缩放的数据，需要注意的是，图片初始位置和图片拖拽位置没有使用同一变量存储，是为了防止在拖拽过程中产生抖动。\r\n/**\r\n * 组件的初始数据\r\n */\r\ndata: {\r\n  baseScale: 1,\r\n  imgPath: '',\r\n  imgWidth: 0, // 图片宽\r\n  imgHeight: 0, // 图片高\r\n  x: 0, // 图片初始时x轴位置\r\n  y: 0, // 图片初始时y轴位置，之所以不和top共用一个变量，是因为如果频繁改变y值，图片会闪烁，x同理\r\n  left: 0, // 图片拖拽后的x轴位置\r\n  top: 0, // 图片拖拽后的y轴位置\r\n  scale: 1 // 拖拽后的缩放比例\r\n}\r\n复制代码组件初始化\r\n组件的初始化方法用于把图片缩放到合适的大小，并使剪切框位于图片中央\r\n/**\r\n * 初始化方法\r\n * 获取图片宽高后，把图片缩放至剪切框大小，\r\n * 并使剪切框位于图片中央\r\n **/\r\n_init() {\r\n  if (!this.data.imgUrl) return\r\n  // 获取屏幕宽度\r\n  let {\r\n    screenWidth\r\n  } = wx.getSystemInfoSync()\r\n  // 计算屏幕rpx\r\n  const rpx = screenWidth / 750\r\n  // 获取图片宽高，然后缩放至剪切框大小\r\n  wx.getImageInfo({\r\n    src: this.data.imgUrl,\r\n    success: ({\r\n      width,\r\n      height,\r\n      path\r\n    }) => {\r\n      const cw = this.data.clipWidth * rpx\r\n      const ch = this.data.clipHeight * rpx\r\n      let scale = Math.max(cw / width, ch / height)\r\n      const imgWidth = width * scale\r\n      const imgHeight = height * scale\r\n      this.setData({\r\n        imgPath: path,\r\n        imgWidth,\r\n        imgHeight,\r\n        baseScale: scale,\r\n        x: (cw - imgWidth) / 2,\r\n        y: (ch - imgHeight) / 2\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码图片拖拽缩放处理\r\n完成初始化后就可以监听用户的拖拽和缩放操作了，主要是记录拖拽的位置和缩放的比例，具体到代码实现就是监听<movable-view> 的拖拽(bindchange)和缩放(bindscale)事件\r\n  // 拖拽事件响应函数\r\n  _onChange: function(e) {\r\n    this.setData({\r\n      x: e.detail.x,\r\n      y: e.detail.y\r\n    })\r\n  }\r\n\r\n  // 缩放事件响应函数\r\n  _onScale: function(e) {\r\n    this.setData({\r\n      x: e.detail.x,\r\n      y: e.detail.y,\r\n      scale: e.detail.scale\r\n    })\r\n  }\r\n复制代码图片剪切实现\r\n拖拽缩放完成后就是剪切了,剪切是利用了<canvas>重新绘制图片的剪切区域，保存到微信临时目录里，并返回保存路径。需要注意的是拖拽和缩放后记录的图片剪切位置并不是原图的位置，利用canvas 的drawImage 进行绘制的时候需要转换成原图位置，或者先把canvas的坐标系进行缩放。注意：在自定义组件下调用 wx.createCanvasContext(string canvasId, Object this)方法时，第二个参数this不能省略，否则canvas绘制无响应\r\n/**\r\n  * 图片剪切入口方法\r\n  */\r\nclip() {\r\n  const scale = this.data._scale * this.data._baseScale\r\n  const canvasId = 'img_clip_canvas'\r\n  imageClip(canvasId, this.data.imgPath, {\r\n    x: this.data._left * -1,\r\n    y: this.data._top * -1,\r\n    scale,\r\n    width: this.data.clipWidth,\r\n    height: this.data.clipHeight\r\n  }, this)\r\n}\r\n\r\n/**\r\n * 图片剪切\r\n *\r\n * @param canvas canvas组件id，用于绘制剪切图片\r\n * @param img 要剪切的图片\r\n * @param option 剪切的位置宽高等信息\r\n * @param option.left 剪切图片左边距\r\n * @param option.top 剪切图片上边距\r\n * @param option.width 剪切图片宽度\r\n * @param option.height 剪切图片高度\r\n * @param context 组件实例对象\r\n * \r\n * @return new Promise(resolve=>ctx)\r\n */\r\nimageClip(canvas, img, option, context) {\r\n  return new Promise((resolve, reject) => {\r\n    option = Object.assign({\r\n      left: 0,\r\n      top: 0,\r\n      scale: 1,\r\n      width: 0,\r\n      height: 0\r\n    }, option)\r\n    let x = option.left / option.scale\r\n    let y = option.top / option.scale\r\n    let clipW = option.width / option.scale\r\n    let clipH = option.height / option.scale\r\n    const ctx = wx.createCanvasContext(canvas, context)\r\n    ctx.drawImage(img,\r\n      x,\r\n      y,\r\n      clipW,\r\n      clipH,\r\n      0,\r\n      0,\r\n      option.width,\r\n      option.height)\r\n\r\n    ctx.draw(false, (e) => {\r\n      console.log(e)\r\n      resolve()\r\n    })\r\n\r\n  })\r\n},\r\n\r\n/**\r\n * canvas 保存为临时文件\r\n */\r\nfunction saveCanvasToTemp(canvas, option) {\r\n  return new Promise((resolve, reject)=>{\r\n    wx.canvasToTempFilePath({\r\n      ...option,\r\n      canvasId: canvas,\r\n      success:resolve,\r\n      fail:reject\r\n    }, this)\r\n  })\r\n}\r\n复制代码写在最后\r\n这就是小程序版图片剪切的主要代码实现，里面还有一些小点儿需要注意\r\n\r\n<movable-view> 的damping的值要设置大写，否则可能会出现拖出界外的情况\r\n在自定义组件下调用 wx.createCanvasContext(string canvasId, Object this)方法时，第二个参数this不能省略，否则canvas绘制无响应\r\n切图时要记住转换成实际图片的大小"}
{"title": "一个简单日历的实现（以小程序为例） ", "author": "Rolan", "pub_time": "2019-11-5 00:32", "content": "最近做的小程序，有个页面要求展示日历。于是，结合网络上的一些文章，做了一个简单版，即拿即用。\r\n效果图：\r\n\r\njs代码：\r\n逻辑都写在注释中，这里就不啰嗦了。\r\n        const dat = new Date(); // 今天的标准时间\r\n        const timeY = dat.getFullYear() // 本年度\r\n        const timeM = dat.getMonth()// 本月，注意值是0-11\r\n        const timeD = dat.getDate() // 日期\r\n        // 获取本月长度\r\n        const start = new Date(timeY, timeM, 1) // 本月第一天的中国标准时间，\r\n        console.log(start);//Fri Nov 01 2019 00:00:00 GMT+0800\r\n        const end = new Date(timeY, timeM+1, 0) // 本月最后一天的中国标准时间\r\n        console.log(end);\r\n        const thisMLastD = end.getDate() // 本月最后一天的日期，也是本月的长度\r\n        // 获取下个月的第一天\r\n        const nextFirst = new Date(timeY, timeM+1, 1); // 下个月第一天的标准时间\r\n        const nextFirstW = nextFirst.getDay(); // 下个月第一天的星期数，周天是0，其他跟星期几一致\r\n        console.log(nextFirstW);\r\n\r\n        const lastMLast = new Date(timeY, timeM, 0) // 上个月最后一天的中国标准时间\r\n        const lastMLastW = lastMLast.getDay(); // 上个月最后一天的星期数,+1就是上个月要展示的天数\r\n        const lastMLength = lastMLast.getDate(); // 上个月最后一天的日期数\r\n        console.log(lastMLength)\r\n        console.log(lastMLastW)\r\n        // 上月要展示的数组\r\n        let lastMonthDate = []\r\n        // 由于星期日排第一位，上个月要展示的日期数量应该是上个月最后一天星期数+1，比如最后一天是周四，那就展示5天\r\n        for (var i = 0; i< lastMLastW+1; i++ ) {\r\n            let index = lastMLength - lastMLastW + i // 上个月总长度减去上月最后一天的星期数等于上月应该展示的第一天的日期数\r\n            let item = {num:index}\r\n            console.log(item)\r\n            lastMonthDate.push(item);\r\n        }\r\n        console.log(lastMonthDate)\r\n\r\n        // 本月要展示的数组\r\n        let thisMonthDate = []\r\n        for (var i = 0; i< thisMLastD + 1; i++ ) {\r\n            let item = {num:i}\r\n            console.log(item)\r\n            thisMonthDate.push(item);\r\n        }\r\n        console.log(thisMonthDate)\r\n\r\n        // 下月要展示的数组\r\n        let nextMonthDate = []\r\n        if (nextFirstW !== 0) { // 为0说明是周天，也就没必要展示下月了\r\n            for (let i = 0; i < 7 - 2; i++) {\r\n            let item = {num:i+1}\r\n                nextMonthDate.push(item)\r\n            }\r\n        }\r\n        console.log(nextMonthDate)\r\n        \r\n        //页面中做三个循环，依次循环lastMonthDate、thisMonthDate和nextMonthDate。\r\n        // 为啥要搞成数组，不根据月份长度直接循环？\r\n        // 方便做UI，毕竟一般日历肯定都是某些日期会有状态的，比如5号是生日，要加个背景色啥的，可以把状态值也添加进数组\r\n\r\n复制代码html代码(以小程序为例)\r\n分为四个部分：星期（你做成数组循环也可以，这里直接写死）；上月日期，本月完整日期；下月日期。完整点的话，你可以自己做个判断，看上月和下月是否需要展示，比如上个月的最后一天刚好星期六，本月第一天正好星期天，那上月就没有展示必要了。\r\n        <view>\r\n        <ul>\r\n          <li>日</li>\r\n          <li>一</li>\r\n          <li>二</li>\r\n          <li>三</li>\r\n          <li>四</li>\r\n          <li>五</li>\r\n          <li>六</li>\r\n        </ul>\r\n        <ul>\r\n            /*li标签里不加view也行，看自己需要*/\r\n            <li wx:for=\"{{lastMonthDate}}\">\r\n              <view class=\"calendar-view\">{{item.num}}</view>\r\n            </li>\r\n            <li wx:for=\"{{thisMonthDate}}\">\r\n              <view class=\"calendar-view\">{{item.num}}</view>\r\n            </li>\r\n            <li wx:for=\"{{nextMonthDate}}\">\r\n              <view class=\"calendar-view\">{{item.num}}</view>\r\n            </li>\r\n        </ul>\r\n    </view>\r\n复制代码css代码：\r\n样式也很简单，浮动布局可以让li标签每铺满一行后自动换行。\r\n        ul {\r\n            width: 500px;\r\n        }\r\n        li {\r\n            list-style-type: none;\r\n            float: left;\r\n            width: 13.6%;\r\n            height: 20px;\r\n        }\r\n复制代码回头有空会传到GitHub～欢迎关注\r\ngithub.com/suosuojiang…"}
{"title": "写给小程序开发者的“一大堆”建议 ", "author": "Rolan", "pub_time": "2019-11-5 00:46", "content": "从工作到现在，我已经累计写了超过6个小程序，总结以及探索到了许多便于开发的解决方案，在这里分享给大家。编码规范缘由编码规范应放在首位。当一个项目需要多个人同时进行编码时，编码规范尤为重要，当我看见我编写的代码里被其他人写的其他风格的代码“污染”了时，那感觉像吃了屎一样。这就是为什么我要求团队有一个统一的代码规范，这会极大地提升代码的可读性，以及协同开发的开发效率。不过现实是，即便开发之前已经订好了规范，总有人在不经意间去在项目里“大展拳脚”，体现自己的独特性，这个时候就需要代码review了。在国外，开发工作并不是最繁琐的，最繁琐的是代码review，Google、Microsoft这些建立在代码上的“帝国”都有一套成熟完善的代码review机制，这足以说明对于建立在代码上的“帝国”而言，编码规范在某种程度上就相当于法律，严酷的惩罚将每个开发人员的“邪念”压制住，这是我们应该了解和学习的。规范文件命名：文件及文件夹统一使用下划线命名，比如\tgoods_detail.wxml ，不使用中横线的原因是其严重影响可读性。组件命名：组件统一使用首字母驼峰命名，比如\tNavBar.wxml ，使用首字母驼峰的原因是组件在页面中是一类特殊元素，需要明显的标识让它与其他便签或方法区别开来。变量命名：变量统一使用下划线命名，比如\tgoods_coupon ，对于方法内的特殊私有变量，使用下划线开头，比如\tconst _that = this ，对于系统级别的变量，采用大写下划线命名，比如\tMAX_VALUE 。方法命名：方法统一使用驼峰命名，比如\tGetUserInfo ，私有方法使用下划线开头的驼峰命名，比如\t_onClose ，在wxs文件中定义的全局方法使用大写的下划线命名，比如：\tFORMAT_PRICE 。其他：在js文件中，省略语句后面分号，提升可读性。对于使用次数不超过两次的值，不单独设置变量。在方法中，对于不同类型的语句，使用空行分隔，便于阅读。CSS属性排列顺序为：绝对定位>flex定位>float定位>width/height>padding/margin>border>background>font相关>特殊属性。更多内容请参照这篇文章：大前端团队代码规范借助wxss-cli在小程序中使用less安装win\tnpm i wxss-cli -gmac\tsudo npm i wxss-cli -g使用使用终端（CMD）进入到项目目录，执行\twxss . ，\t. 表示当前目录。即可看到less文件将被编译成同名的wxss文件。使用CSS原生变量场景有时候我们与一些不适用less进行开发的小伙伴进行协同，需要统一变量，这个时候CSS原生变量就派上了用场。定义app.wxsspage{\r\n    --color_main:#333333;\r\n    --color_sub:#555555;\r\n}\r\n复制代码使用index.wxss@import '../app.wxss';\r\n\r\n.section .title{\r\n    color:var(--color_main);\r\n}\r\n\r\n.section .content{\r\n    color:var(--color_sub);\r\n}\r\n复制代码使用defineProperty定义app.globalData 构建全局数据中心缘由有时，我们会遇到一些很特殊的需求，比如需要在自定义的tabbar上与页面进行交互，而微信的自定义tabbar又没法使用triggerEvent（在页面里不需要引用tabbar），这个时候就需要借助\tconst app = getApp() 来实现类似于数据中心的功能。现在的需求是，进入到购物车页面，选择完商品之后需要在tabbar上显示总的价格，然后点击tabbar上的付款按钮。那我们首先得拿到实时的购物车选中商品的数据，也就是做我们得监听购物车选中了哪些商品，同时在tabbar里面做出响应，这个时候，熟悉JS的同学就会想到defineProperty这个方法，它允许我们定义一个变量，同时提供get、set等钩子函数，类似于C#中的getter、setter方法。首先我们在app里定义这个变量，同时构建这个“数据中心”所需的“基础设施”：app.jsApp({\r\n    globalData:{\r\n        orders:[]\r\n    },\r\n    \r\n    // watcher start\r\n    watchCallBack: {},\r\n    watchingKeys: [],\r\n    initWatcher () {\r\n    \tthis.globalData$ = Object.assign({}, this.globalData)\r\n    },\r\n    setGlobalData (obj) {\r\n    \tObject.keys(obj).map((key) => {\r\n    \t\tthis.globalData[key] = obj[key]\r\n    \t})\r\n    },\r\n    watch$ (key, cb) {\r\n    \tthis.watchCallBack = Object.assign({}, this.watchCallBack, {\r\n    \t\t[key]: this.watchCallBack[key] || []\r\n    \t})\r\n    \r\n    \tthis.watchCallBack[key].push(cb)\r\n    \r\n    \tif (!this.watchingKeys.find((x) => x === key)) {\r\n    \t\tconst that = this\r\n    \t\tthis.watchingKeys.push(key)\r\n    \t\tObject.defineProperty(this.globalData, key, {\r\n    \t\t\tconfigurable: true,\r\n    \t\t\tenumerable: true,\r\n    \t\t\tset: function (val){\r\n    \t\t\t\tconst old = that.globalData$[key]\r\n    \t\t\t\tthat.globalData$[key] = val\r\n    \t\t\t\tthat.watchCallBack[key].map((func) => func(val, old))\r\n    \t\t\t},\r\n    \t\t\tget: function (){\r\n    \t\t\t\treturn that.globalData$[key]\r\n    \t\t\t}\r\n    \t\t})\r\n    \t}\r\n    },\r\n    // watcher end\r\n    \r\n)\r\n\r\n复制代码cart.jsonChangeOrders() {\r\n    const _that = this\r\n    \r\n\tapp.setGlobalData({\r\n\t\torders: _that.data.orders\r\n\t})\r\n}\r\n复制代码tabbar.jswatchOrders () {\r\n\tconst _that = this\r\n\r\n\tapp.watch$('orders', (new_val) => {\r\n\t\tif (new_val.length) {\r\n\t\t\t_that.setData({\r\n\t\t\t\torders: new_val\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n},\r\n复制代码了解更多请看这篇文章：\t50行代码监听watch小程序的globalData使用wxs文件定义模板filter缘由写过Vue的同学知道，在Vue里有一个特别方便的东西，就是filter，它可以很方便地处理模板变量，尤其是在循环数组时，但小程序并没有直接提供相关功能，其实我们可以借助小程序的wxs来实现（目前wxs对ES6的支持有限，许多高级特性都无法使用，比如Object、Array）。实现app.wxsmodule.exports = {\r\n\tFORMAT_PRICE: function (price){\r\n\t\tvar value = (price / 100).toFixed(2)\r\n\r\n\t\treturn value\r\n\t},\r\n\tFORMAT_ORDER_NUMBER: function (number){\r\n\t\tvar value = number.slice(0, 12)\r\n\r\n\t\treturn value\r\n\t},\r\n\tFORMAT_JSON_TO_STRING: function (string){\r\n\t\treturn JSON.parse(string)\r\n\t}\r\n}\r\n复制代码使用cart.wxml<wxs\r\n      src=\"../app.wxs\"\r\n      module=\"app\"\r\n/>\r\n\r\n<text class=\"price\">{{app.FORMAT_PRICE(item.price)}}</text>\r\n复制代码使用atom.css配合vs code插件IntelliSense for CSS class names in HTML快速出页面缘由由于小程序体积限制（2M），在小程序中基本上无法使用那种大而全UI框架，而这个时候CSS框架似乎是更好的选择，这里推荐使用\tatom.css 。安装npm i @verts/atom.css --save使用然后复制里面的\tatom-miniapp.min.wxss 文件到项目目录即可。如果要在less中使用，将\tatom-miniapp.min.wxss 更改为\tatom-miniapp.min.less 即可。配合vscode使用时需要安装\tIntelliSense for CSS class names in HTML ，并将atom.css项目文件夹引入到vscode中，让上述插件将atom.css的所有class缓存到vscode中（wxss 插件无法识别，故无法缓存）。效果使用async包装wx.request 简单实现拦截器的功能实现request.jsconst request = (url, method, data, header) => {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\twx.request({\r\n\t\t\turl: url,\r\n\t\t\tmethod: method,\r\n\t\t\tdata: data,\r\n\t\t\theader: Object.assign(\r\n\t\t\t\t{ token: wx.getStorageSync('token') },\r\n\t\t\t\theader\r\n\t\t\t),\r\n\t\t\tsuccess (res) {\r\n\t\t\t    //拦截器相关逻辑\r\n\t\t\t    if(res.code==='200'){\r\n\t\t\t        resolve(res.data)\r\n\t\t\t    }\r\n\t\t\t},\r\n\t\t\tfail (error) {\r\n\t\t\t\treject(error)\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\nexport const get = async (url, data) => {\r\n\treturn request(url, 'get', data)\r\n}\r\n\r\nexport const post = async (url, data, header) => {\r\n\treturn request(url, 'post', data, header)\r\n}\r\n\r\n复制代码使用import API from '../../utils/api'\r\nimport { get } from '../../utils/request'\r\n\r\nexport const Service_getGoodsDetail = (data) => get(API.API_getGoodsDetail, data)\r\n复制代码集中管理api接口缘由在项目进行的过程中，由于需求随时会产生变化，所以接口也可能会变化，这个时候就需要统一管理和配置接口，并保持接口的“无状态”，便于后期开发和维护。API命名格式为：\tAPI_[methodtype][Someone][Do][Something]实现api.js//线上地址\r\n// const API_BASE_URL = 'https://api.***.com'\r\n\r\n//测试地址\r\nconst API_BASE_URL = 'https://test.***.com'\r\n\r\n//开发地址\r\n// const API_BASE_URL = 'http://***:8080'\r\n\r\n//登录\r\nexport const API_postUserLogin = API_BASE_URL + '/***/login'\r\n\r\n//获取 用户信息\r\nexport const API_getUserInfo = API_BASE_URL + '/***/userInfo'\r\n\r\nconst API = {\r\n    API_postUserLogin,\r\n    API_getUserInfo,\r\n}\r\n\r\nexport default API\r\n复制代码使用mark对长列表做事件代理缘由过去我们使用Jquery，很容易通过on方法实现列表中的子项的操作进行代理操作，我们称之为事件委托。但在小程序中如何实现这一点呢？除了使用\tdata -，小程序提供给了我们一个比\tdata- 更加好用的方案——mark。使用coupon.wxml<view\r\n    class=\"coupon_items w_100 border_box flex flex_column\"\r\n    catchtap=\"onSelectCoupon\"\r\n>\r\n    <view\r\n          class=\"coupon_item w_100 border_box flex relative\"\r\n          wx:for=\"{{coupon_list}}\"\r\n          wx:key=\"{{index}}\"\r\n          mark:index=\"{{index}}\"\r\n    >\r\n        ***\r\n    </view>\r\n</view>\r\n复制代码coupon.jsonSelectCoupon(e){\r\n    const _that = this\r\n    const { index } = e.mark\r\n    \r\n    if(index){\r\n        _that.setData(\r\n            {\r\n                select_coupon_index:index\r\n            }\r\n        )\r\n    }\r\n}\r\n复制代码在setData之前对目标数据进行复杂操作const _that = this\r\nconst { index } = e.detail\r\n\r\n_that.data.coupon_list[index].selected = true\r\n_that.data.coupon_list[index].text_style = 'bold'\r\n\r\n_that.setData(\r\n    {\r\n        coupon_list:_that.data.coupon_list\r\n    }\r\n)\r\n复制代码使用recycle-view进行长列表渲染优化缘由之前做过一个新闻+购物的小程序，由于首页滚动列表的图片内容比较多，滚动加载很多条之后就会出现卡顿甚至直接卡出微信的情况，后来通过使用一些第三方的长列表优化插件优化了一下，至少不会直接卡出微信了，微信现在有一个官方的长列表优化方案，那就是revcycle-view，使用recycle-view能够极大地节省内存，同时提升用户体验，在angular7中，该功能已被集成到angular官方sdk中，而在react中，也有着很多虚拟滚动的方案，Facebook的Instagram Web端的PWA应用很多地方都用到了虚拟滚动。使用index.wxml<recycle-view\r\n            id=\"chosen\"\r\n            class=\"chosen w_100 border_box flex justify_between flex_wrap\"\r\n            batch=\"{{batchSetRecycleData}}\"\r\n            scroll-y=\"{{true}}\"\r\n            scroll-with-animation=\"{{true}}\"\r\n            lower-threshold=\"{{100}}\"\r\n            bindscrolltolower=\"onScrollToLower\"\r\n            enable-back-to-top=\"{{true}}\"\r\n            scroll-top=\"{{scroll_top}}\"\r\n            bindscroll=\"onScroll\"\r\n      >\r\n    <view\r\n          class=\"w_100 border_box flex flex_column\"\r\n          slot=\"before\"\r\n    >\r\n        ***\r\n    </view>\r\n    <view class=\"goods_card_items w_100 border_box flex justify_between flex_wrap\">\r\n          <recycle-item\r\n                class=\"goods_card_wrap\"\r\n                wx:for=\"{{recycleList}}\"\r\n                wx:key=\"{{item.__index__}}\"\r\n          >\r\n                <GoodsCard\r\n                      class=\"goods_card\"\r\n                      goods_id=\"{{item.goods_id}}\"\r\n                ></GoodsCard>\r\n          </recycle-item>\r\n    </view>\r\n</recycle-view>\r\n复制代码index.jsdata:{}\r\nrecycle_view_context:{},\r\ncreateRecycleView () {\r\n\tconst _that = this\r\n\r\n\tconst ctx = createRecycleContext({\r\n\t\tid: 'chosen',\r\n\t\tdataKey: 'recycleList',\r\n\t\tpage: _that,\r\n\t\titemSize: {\r\n\t\t\twidth: '100%',\r\n\t\t\theight: 350\r\n\t\t}\r\n\t})\r\n\r\n\t_that.recycle_view_context = ctx\r\n},\r\n复制代码追加数据getGoodsData () {\r\n\tconst _that = this\r\n\r\n\tService_getGoodsData.then((res) => {\r\n\t\tif (res.data) {\r\n\t\t\t_that.recycle_view_context.append(res.data.goods_list)\r\n\t\t}\r\n\t})\r\n},\r\n复制代码使用watch来实现dialog动效缘由之前写一个商城的时候，研究淘宝的商品属性选择弹窗的动效是一个什么过程，然后如何实现。过程如下：点击选择属性/购买/加入购物车按钮 => 蒙版层占满整个屏幕，然后渐渐显现出来，与此同时，下方的窗口从底部渐渐滑出。OK，其实这个过程很简单，点击按钮的时候，弹窗（占满整个屏幕）其实以及出现了，但是要等待蒙版层的背景颜色从transparent变为rgba(0, 0, 0, 0.6)，同时也在等待弹窗内容从transform:translate(-100%)变为transform:translate(0)。这个时候需要用到小程序官方开源的一个插件：\tminiprogram-computed实现Dialog.wxml<view\r\n      class=\"fixed_wrap\"\r\n      wx:if=\"{{is_show}}\"\r\n      catchtouchmove=\"onStopPageScroll\"\r\n>\r\n      <view class=\"dialog_wrap\">\r\n            <view\r\n                  class=\"mask\"\r\n                  style=\"background-color: {{bg_modal}}\"\r\n                  catchtap=\"onClose\"\r\n            ></view>\r\n            <view\r\n                  class=\"dialog_absolute_wrap\"\r\n                  style=\"transform:{{position_dialog}}\"\r\n            >\r\n                  <view\r\n                        class=\"dialog\"\r\n                        style=\"background-color: {{is_show_bg?'white':'transparent'}}\"\r\n                  >\r\n                        <image\r\n                              class=\"img_close\"\r\n                              src=\"../../assets/images/icon_close.svg\"\r\n                              mode=\"widthFix\"\r\n                              bindtap=\"onClose\"\r\n                              wx:if=\"{{is_show_close}}\"\r\n                        ></image>\r\n                        <slot></slot>\r\n                  </view>\r\n            </view>\r\n      </view>\r\n</view>\r\n复制代码dialog.jsimport computedBehavior from 'miniprogram-computed'\r\n\r\nComponent({\r\n\tbehaviors: [\r\n\t\tcomputedBehavior\r\n\t],\r\n\tproperties: {\r\n\t\tid: {\r\n\t\t\ttype: String\r\n\t\t},\r\n\t\tis_show_dialog: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tvalue: false\r\n\t\t},\r\n\t\tis_show_close: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tvalue: true\r\n\t\t},\r\n\t\tis_show_bg: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tvalue: true\r\n\t\t}\r\n\t},\r\n\tdata: {\r\n\t\tis_show: false,\r\n\t\tbg_modal: 'transparent',\r\n\t\tposition_dialog: 'translateY(120%)'\r\n\t},\r\n\twatch: {\r\n\t\tis_show_dialog: function (new_val){\r\n\t\t\tconst _that = this\r\n\r\n\t\t\tif (new_val) {\r\n\t\t\t\t_that.setData({\r\n\t\t\t\t\tis_show: true\r\n\t\t\t\t})\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t_that.setData({\r\n\t\t\t\t\t\tbg_modal: 'rgba(0, 0, 0, 0.6)',\r\n\t\t\t\t\t\tposition_dialog: 'translateY(0)'\r\n\t\t\t\t\t})\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_that.setData({\r\n\t\t\t\t\tbg_modal: 'transparent',\r\n\t\t\t\t\tposition_dialog: 'translateY(120%)'\r\n\t\t\t\t})\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t_that.setData({\r\n\t\t\t\t\t\tis_show: false\r\n\t\t\t\t\t})\r\n\t\t\t\t}, 300)\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\tonClose () {\r\n\t\t\tconst _that = this\r\n\r\n\t\t\t_that.setData({ is_show_dialog: false })\r\n\t\t},\r\n\t\tonTapDialog (e) {\r\n\t\t\tconst _that = this\r\n\r\n\t\t\t_that.triggerEvent('OnBottomDialog', { id: _that.data.id, event: e })\r\n\t\t},\r\n\t\tonStopPageScroll () {}\r\n\t}\r\n})\r\n复制代码dialog.less@import '../../theme/vars.less';\r\n\r\n.fixed_wrap {\r\n      position: fixed;\r\n      top: 0;\r\n      left: 0;\r\n      z-index: 10000;\r\n      width: 100vw;\r\n      height: 100vh;\r\n     \r\n}\r\n\r\n.dialog_wrap {\r\n      position: relative;\r\n      width: 100%;\r\n      height: 100%;\r\n\r\n      .mask {\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            transition: all ease 0.3s;\r\n      }\r\n\r\n      .dialog_absolute_wrap {\r\n            position: absolute;\r\n            bottom: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            transition: all ease 0.3s;\r\n\r\n            .dialog {\r\n                  position: relative;\r\n                  display: flex;\r\n                  flex-direction: column;\r\n                  width: 100%;\r\n                  box-sizing: border-box;\r\n                  background-color: white;\r\n                  border-top-left-radius: @radius_normal;\r\n                  border-top-right-radius: @radius_normal;\r\n\r\n                  .img_close {\r\n                        position: absolute;\r\n                        top: 10rpx;\r\n                        right: 10rpx;\r\n                        z-index: 1;\r\n                        width: 40rpx;\r\n                        height: 40rpx;\r\n                        padding: 20rpx;\r\n                        opacity: 0.3;\r\n                  }\r\n            }\r\n      }\r\n}\r\n复制代码自定义顶部NavBar缘由现在有很多商城app都会有在顶部NavBar上放各种“东西”比如搜索框的需求，但是NavBar上的胶囊又没办法自定义，这就导致NavBar上的搜索框或是其他元素会与胶囊错位，看起来效果很差，详情可看“网易严选小程序”，但是其实是有办法做到顶部NavBar完美布局的，这里就要用到一个获取胶囊定位以及尺寸的api\twx.getMenuButtonBoundingClientRect() ，通过这个api，然后使用\tres.statusBarHeight 这个变量，我们可以做很多事情。不过经过测试，目前已知在小米的一些型号的全面屏手机上，高度会有略微的偏移，需要做一定的适配。wx.getSystemInfo({\r\n\tsuccess(res){\r\n\t    console.log(res.statusBarHeight)\r\n\t},\r\n})\r\n复制代码实现具体实现我就不写了，等有时间抽空把组件重构一次后再分享给大家，下面写部分关键代码：//获取设备顶部 状态栏高度 和 顶部标题栏高度\r\nexport const GetDeviceBarHeight = () => {\r\n\tlet statusBarHeight\r\n\tlet titleBarHeight\r\n\r\n\twx.getSystemInfo({\r\n\t\tsuccess(res){\r\n\t\t\tlet totalTopHeight = 68\r\n\r\n\t\t\tif (res.model.indexOf('iPhone X') !== -1) {\r\n\t\t\t\ttotalTopHeight = 88\r\n\t\t\t}\r\n\t\t\telse if (res.model.indexOf('iPhone') !== -1) {\r\n\t\t\t\ttotalTopHeight = 64\r\n\t\t\t}\r\n\r\n\t\t\tstatusBarHeight = res.statusBarHeight\r\n\t\t\ttitleBarHeight = totalTopHeight - res.statusBarHeight\r\n\t\t},\r\n\t\tfailure () {\r\n\t\t\tstatusBarHeight = 0\r\n\t\t\ttitleBarHeight = 0\r\n\t\t}\r\n\t})\r\n\r\n\treturn {\r\n\t\tstatusBarHeight: statusBarHeight,\r\n\t\ttitleBarHeight: titleBarHeight\r\n\t}\r\n}\r\n\r\ndata: {\r\n        statusBarHeight: app.globalData.statusBarHeight + 'px',\r\n\t\ttitleBarHeight: app.globalData.titleBarHeight + 'px',\r\n\t\tnavigationBarHeight: app.globalData.statusBarHeight + 44 + 'px',\r\n\r\n\t\theight: 0,\r\n\t\ttop: 0\r\n},\r\n\r\n//动态设定 顶部操作按钮的高度和位置\r\nsetOptionsHeight () {\r\n\tconst _that = this\r\n\tconst { top, height } = wx.getMenuButtonBoundingClientRect()\r\n\r\n\t_that.setData({\r\n\t\theight: height - 1,\r\n\t\ttop: top + 2\r\n\t})\r\n}\r\n复制代码小程序分包加载但小程序的大小超过2M之后可以采用分包加载的方式加载页面，具体使用方式看官方文档\t小程序分包加载最后后续我会写一些单独的小程序组件并开源出来，不同于有赞的小程序库，他们提供的是一辆长得像淘宝的“改装车”，而我开源出来的是一些，跟谁都长的不像，想怎么改就怎么改的“改装车零件”。我在github开源了一个\t小程序开发手册 ，后续更多内容将在这个开源项目上更新，大家可以分享给开发小程序的同事，让他们少踩一点坑，大家少加一点班。周末愉快。"}
{"title": "VUE 组件转换为微信小程序组件 ", "author": "Rolan", "pub_time": "2019-11-6 00:03", "content": "简介：首先我们介绍一下本文的关键点：抽象语法树，它是以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。通过操作这棵树，可以精确的定位到声明、赋值、运算语句，从而实现对代码的优化、变更等操作。本文通过对 VUE 组件的 JavaScript 、CSS模块进行转换，比如 JavaScript模块，包括外层对象，生命周期钩子函数，赋值语句，组件的内部数据，组件的对外属性等等来实现把一个 VUE 组件转换为 一个小程序组件。AST 抽象语法树，似乎我们平时并不会接触到。实际上在我们的项目当中，CSS 预处理，JSX 亦或是 TypeScript 的处理，代码格式化美化工具，Eslint， Javascript 转译，代码压缩，Webpack， Vue-Cli，ES6 转 ES5，当中都离不开 AST 抽象语法树这个绿巨人。先卖个关子，让我们看一下 AST 到的官方解释：It is a hierarchical program representation that presents source code structure according to the grammar of a programming language, each AST node corresponds to an item of a source code.中文的解释有：抽象语法树（abstract syntax tree或者缩写为 AST ），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。抽象语法树，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。通过操作这棵树，可以精确的定位到声明、赋值、运算语句，从而实现对代码的优化、变更等操作。这些并不是我们想要看到的。对于 AST 面纱的神秘感，似乎已经将要揭开。不错，在我刚接触到他的时候，同样感觉确实是难。但是当你开始了解了它以后，你就会越来越喜欢它。因为他实在太强大了。AST 本身并不难，难点在于转换的目标对象与源对象的语法差异，当中水深毋庸置疑。但是，这才能更加激起我们探索他的欲望。在开始之前，我们先看一下 抽象语法树到底长什么样子。一、 一探究竟 AST通过\tastexplorer [1] （AST树查看网站），通过他你可以方便的查看代码的语法树，挑你喜欢的库。你可以在线把玩 AST，而且除了 JavaScript，HTML， CSS 还有很多其它语言的 AST 库，让我们对他有一个感性而直观的认识。请看下图，看看AST语法树长什么样子：此图看到的是一个 ExportDefaultDeclaration 也就是export default {}，还有他的位置信息，注释失信，tokens等等。国际惯例，先来一个小demo输入数据function square(n) {\r\n  return n * n;\r\n}复制代码处理数据astFn() {\r\n    const code = `function square(n) {\r\n        return n * n;\r\n      }`;\r\n    //得到 AST 语法树\r\n    const ast = babylon.parse(code);\r\n\r\n    traverse(ast, {\r\n      enter(path) {\r\n        console.log(\"enter: \" + path.node.type);\r\n        //如下的语句匹配到 return 中的 n 与参数 n，并且将它替换为 x。\r\n        if (path.node.type === \"Identifier\" && path.node.name === \"n\") {\r\n          path.node.name = \"x\";\r\n        }\r\n      }\r\n    });\r\n    generate(ast, {}, code);//将 AST 转换为代码\r\n    console.log(generate(ast, {}, code).code );//打印出转换后的 JavaScript 代码\r\n  }复制代码输出数据function square(x) {\r\n  return x * x;\r\n}复制代码我们看一下我们得到的 AST 树接下来我们插入一段 把 VUE 组件转换为微信小程序组件正则版本的处理二、 简单粗暴的版本（VUE 组件转换为微信小程序组件）没有使用 AST 将 VUE 组件转换成小程序组件的简易版本介绍下方是两段代码，简单的逻辑，实现思路，匹配目标字符串，替换字符，然后生成文件。regs:{//通过标签匹配来替换对应的小程序支持的标签\r\n  toViewStartTags: /(<h1)|(<s)|(<em)|(<ul)|(<li)|(<dl)|(<i)|(<span)/g,\r\n  toViewEndTags: /(<\\/h1>)|(<\\/s>)|(<\\/em>)|(<\\/ul>)|(<\\/li>)|(<\\/dl>)|(<\\/i>)|(<\\/span>)/g,\r\n  toBlockStartTags: /(<div)|(<p)/g,\r\n  toBlockEndTags: /(<\\/div>)|(<\\/p>)/g,\r\n},\r\nsignObj: {//通过标签查找来分离脚本，模板和CSS\r\n  tempStart: '<template>',\r\n  tempEnd: '</template>',\r\n  styleStart: '<style scoped>',\r\n  styleEnd: '</style>',\r\n  scriptStart: '<script>',\r\n  scriptEnd: '</script>'\r\n}复制代码上方是正则版本的一些模板匹配规则，经过后续的一系列处理把一个 VUE组件处理得到对应的小程序的 WXML ，WXSS，JSON，JS，4个文件。//文件\r\nconst wxssFilePath = path.join(dirPath, `${mpFile}.wxss`);\r\nconst jsFilePath = path.join(dirPath, `${mpFile}.js`);\r\nconst wxmlFilePath = path.join(dirPath, `${mpFile}.wxml`);\r\nconst jsonFilePath = path.join(dirPath, `${mpFile}.json`);\r\nif (!fs.existsSync(dirPath)) {\r\n  fs.mkdirSync(dirPath);\r\n}\r\nfs.writeFile(wxssFilePath, wxssContent, err => {\r\n  if (err) throw err;\r\n  //console.log(`dist目录下生成${mpFile}.wxss文件成功`);\r\n  fs.writeFile(jsFilePath, jsContent, err => {\r\n  if (err) throw err;\r\n       // console.log(`dist目录下生成${mpFile}.js文件成功`);\r\n        fs.writeFile(wxmlFilePath, wxmlContent, err => {\r\n          if (err) throw err;\r\n          //console.log(`dist目录下生成${mpFile}.wxml文件成功`);\r\n          fs.writeFile(jsonFilePath, jsonContent, err => {\r\n            if (err) throw err;\r\n           console.log(`dist目录下生成${mpFile}.json文件成功`)\r\n            resolve(`生成${mpFile}.json文件成功`);\r\n          })\r\n       })\r\n    });\r\n});复制代码上方是处理得到的 WXML ，WXSS，JSON，JS，4个文件，并且生成到对应的目录下。代码实现用时较短，后续更改方案，并没有做优化，这里就不做详细展开讨论这个实现方案了。回到正题 介绍一下，AST 抽象语法树的核心部分：三、 抽象语法树三大法宝Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“ 转换编译器（transpiler）”。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。babel-core：Babel 的编译器；它暴露了 babel.transform 方法。[1] babylon：Babylon 是 Babel 的解析器。用于生成 AST 语法树。[2] babel-traverse：Babel 的遍历器，所有的transformers都使用该工具遍历所有的 AST (抽象语法树)，维护了整棵树的状态，并且负责替换、移除和添加节点。我们可以和 Babylon 一起使用来遍历和更新节点。[3] babel-generator：Babel 的代码生成器。它读取AST并将其转换为代码。整个编译器就被分成了三部分：分析器、转换器、生成器，大致的流程是：输入字符串 -> babylon分析器 parse -> 得到 AST -> 转换器 -> 得到 AST -> babel-generator -> 输出总结核心三步：AST 三大法宝babylon.parse => traverse 转换 AST => generate(ast, {}, code).code) 生成感兴趣的童鞋，可以在网上或者看参考资料都有介绍。该铺垫的都铺垫的差不多了，进入正题。我们到底是如何通过 AST 将 VUE 组件转换为微信小程序组件的呢？四、 VUE 组件转换为微信小程序组件中 组件的对外属性、赋值语句的转换处理转换之前的 VUE 组件代码 Demoexport default {\r\n              //组件的对外属性\r\n              props: {\r\n                  max: {\r\n                      type: Number,\r\n                      value: 99\r\n                  }\r\n              },\r\n              //组件的内部数据\r\n              data(){\r\n                  return {\r\n                    num:10000\r\n                  }\r\n              },\r\n              //组件的方法\r\n              methods: {\r\n                 textFn() {\r\n                   this.num = 2\r\n                },\r\n                 onMyButtonTap: function(){\r\n                  this.num = 666\r\n                },\r\n              }\r\n            }复制代码处理后我们得到的微信小程序组件 JavaScript 部分代码export default {\r\n  properties: {\r\n    //组件的对外属性\r\n    max: {\r\n      type: Number,\r\n      value: 99\r\n    }\r\n  },\r\n //组件的内部数据\r\n data(){\r\n    return {\r\n      num: 10000\r\n    }\r\n  },\r\n  //组件的方法\r\n  methods: {\r\n    textFn() {\r\n      this.setData({\r\n        num: 2\r\n      });\r\n    },\r\n    onMyButtonTap: function () {\r\n      this.setData({\r\n        num: 666\r\n      });\r\n    }\r\n  }\r\n};复制代码我们对js动了什么手脚(亦可封装成babel插件)://to AST\r\nconst ast = babylon.parse(code, {\r\n  sourceType: \"module\",\r\n  plugins: [\"flow\"]\r\n});\r\n\r\n//AST 转换 node，nodetype很关键\r\ntraverse(ast, {\r\n   enter(path) {\r\n     //打印出node.type\r\n     console.log(\"enter: \" + path.node.type);\r\n   }\r\n})\r\n\r\nObjectProperty(path) {\r\n   //props 替换为 properties\r\n    if (path.node.key.name === \"props\") {\r\n      path.node.key.name = \"properties\";\r\n    }\r\n}\r\n\r\n//修改methods中使用到数据属性的方法中。this.prop至this.data.prop等 与 this.setData的处理。\r\nMemberExpression(path) {\r\n let datasVals =  datas.map((item,index) =>{\r\n    return item.key.name //拿到data属性中的第一级\r\n  })\r\n  if (//含有this的表达式 并且包含data属性\r\n    path.node.object.type === \"ThisExpression\" &&\r\n    datasVals.includes(path.node.property.name)\r\n  ) {\r\n   path.get(\"object\").replaceWithSourceString(\"this.data\");\r\n    //判断是不是赋值操作\r\n    if (\r\n      (t.isAssignmentExpression(path.parentPath) &&\r\n        path.parentPath.get(\"left\") === path) ||\r\n      t.isUpdateExpression(path.parentPath)\r\n    ) {\r\n      const expressionStatement = path.findParent(parent =>\r\n        parent.isExpressionStatement()\r\n      );\r\n      //......\r\n    }\r\n  }\r\n}复制代码转换之前的js代码的部分 AST 树：具体的 API 使用，童鞋们看一下 babel 相关的文档了解一下。五， VUE 组件转换为微信小程序组件中 Export Default 到 Component 构造器的转换 与 生命周期钩子函数，事件函数的处理首先我们看一下要转换前后的语法树与代码如下（明确转换目标）：转换之前的 AST 树与代码export default {// VUE 组件的惯用写法用于导出对象模块\r\n    data(){\r\n    },\r\n    methods:{\r\n    },\r\n    props:{\r\n    }\r\n}复制代码转换之后的 AST 树与代码components({//小程序组件的构造器\r\n    data(){\r\n    },\r\n    methods:{\r\n    },\r\n    props:{\r\n    }\r\n})复制代码通过以上转换之前和转换之后代码和 AST 的对比我们明确了转换目标就是 ExportDefault 到 Component构造器的转换，下面看一下我们是如何处理的：我们做了什么（在转换中进入到 ExportDefault 中做对应的处理）://ExportDefault 到 Component构造器的转换\r\nExportDefaultDeclaration(path) {\r\n//创建  CallExpression  Component({})\r\nfunction insertBeforeFn(path) {\r\n  const objectExpression = t.objectExpression(propertiesAST);\r\n  test = t.expressionStatement(\r\n      t.callExpression(//创建名为 Compontents 的调用表达式，参数为 objectExpression\r\n          t.identifier(\"Compontents\"),[\r\n            objectExpression\r\n          ]\r\n      )\r\n  );\r\n  //最终得到的语法树\r\n  console.log(\"test\",test)\r\n}\r\nif (path.node.type === \"ExportDefaultDeclaration\") {\r\n  if (path.node.declaration.properties) {\r\n    //提取属性并存储\r\n    propertiesAST = path.node.declaration.properties;\r\n    //创建 AST 包裹对象\r\n    insertBeforeFn(path);            \r\n  }\r\n  //得到我们最终的转换结果\r\n  console.log(generate(test, {}, code).code);复制代码对于 ExportDefault => Component 构造器转换还有一种转换思路 下面我们看一下：[1] 第一种思路是先提取 ExportDefault 内部所有节点的 AST ，并做处理，然后创建Component构造器，插入提取处理后的 AST，得到最终的 AST//propertiesAST 这个就是我们拿到的 AST，然后在对应的分支内做对应的处理 以下分别为 data，methods，props，其他的钩子同样处理即可\r\npropertiesAST.map((item, index) => {\r\n  if (item.type === \"ObjectProperty\") {\r\n    //props 替换为 properties\r\n    if (item.key.name === \"props\") {\r\n      item.key.name = \"properties\";\r\n    }\r\n  } else if (item.type === \"ObjectMethod\") {\r\n     if (path.node.key.name === \"mounted\") {\r\n          path.node.key.name = \"ready\";\r\n        } else if (path.node.key.name === \"created\") {\r\n          path.node.key.name = \"attached\";\r\n        } else if (path.node.key.name === \"destroyed\") {\r\n          path.node.key.name = \"detached\";\r\n        } else if (path.node.type === \"ThisExpression\") {\r\n           if (path.parent.property.name === \"$emit\") {\r\n            path.parent.property.name = \"triggerEvent\";\r\n           }\r\n        } else {\r\n          void null;\r\n        }\r\n     }\r\n  } else if (path.node.key.name === \"methods\") {\r\n      path.traverse({\r\n        enter(path) {\r\n           if (path.node.type === \"ThisExpression\") {\r\n              if (path.parent.property.name === \"$emit\") {\r\n                path.parent.property.name = \"triggerEvent\";\r\n              }\r\n            }\r\n        }\r\n      })\r\n  }\r\n  else {\r\n    //...\r\n    console.log(\"node type\", item.type);\r\n  }\r\n});复制代码[2] 第二种思路呢，就是我们上面展示的这种，不过有一个关键的地方要注意一下：//我把 ExportDefaultDeclaration 的处理放到最后来执行，拿到 AST 首先进行转换。然后在创建得到新的小程序组件JS部分的 AST 即可\r\ntraverse(ast, {\r\n      enter(path) {},\r\n      ObjectProperty(path) {},\r\n      ObjectMethod(path) {},\r\n      //......\r\n      ExportDefaultDeclaration(path) {\r\n      //...\r\n      }\r\n})复制代码如果你想在 AST 开始处与结尾处插入，可使用 path 操作：path.insertBefore(\r\n  t.expressionStatement(t.stringLiteral(\"start..\"))\r\n);\r\npath.insertAfter(\r\n  t.expressionStatement(t.stringLiteral(\"end..\"))\r\n);复制代码注：关于微信小程序不支持 computed , 与 watch，我们具体的初期采用的方案是挂载 computed 和 watch 方法到每一个微信小程序组件，让小程序组件也支持这两个功能。六，VUE 组件转换为微信小程序组件中 的 Data 部分的处理：关于 Data 部分的处理实际上就是：函数表达式转换为对象表达式 （FunctionExpression 转换为 ObjectExpression）转换之前的 JavaScript 代码export default {\r\n    data(){//函数表达式\r\n      return {\r\n        num: 10000,\r\n        arr: [1, 2, 3],\r\n        obj: {\r\n          d1: \"val1\",\r\n          d2: \"val2\"\r\n        }\r\n      }\r\n    }\r\n}复制代码处理后我们得到的export default {\r\n  data: {//对象表达式\r\n    num: 10000,\r\n    arr: [1, 2, 3],\r\n    obj: {\r\n      d1: \"val1\",\r\n      d2: \"val2\"\r\n    }\r\n  }\r\n};复制代码通过如上的代码对比，我们看到了我们的转换前后代码的变化：转换前后 AST 树对比图明确转换目标：我们对 JavaScript 动了什么手脚(亦可封装成babel插件):const ast = babylon.parse(code, {\r\n  sourceType: \"module\",\r\n  plugins: [\"flow\"]\r\n});\r\n\r\n//AST 转换node、nodetype很关键\r\ntraverse(ast, {\r\n  enter(path) {\r\n    //打印出node.type\r\n    console.log(\"enter: \" + path.node.type);\r\n  }\r\n})复制代码我们的转换部分都尽量在一个 Traverse 中处理，减少 AST 树遍历的性能消耗//Data 函数表达式 转换为 Object\r\nObjectMethod(path) {\r\n  // console.log(\"path.node \",path.node )// data, add, textFn\r\n  if (path.node.key.name === \"data\") {\r\n    // 获取第一级的 BlockStatement，也就是 Data 函数体\r\n    path.traverse({\r\n      BlockStatement(p) {\r\n        //从 Data 中提取数据属性\r\n        datas = p.node.body[0].argument.properties;\r\n      }\r\n    });\r\n    //创建对象表达式\r\n    const objectExpression = t.objectExpression(datas);\r\n    //创建 Data 对象并赋值\r\n    const dataProperty = t.objectProperty(\r\n      t.identifier(\"data\"),\r\n      objectExpression\r\n    );\r\n    //插入到原 Data 函数下方\r\n    path.insertAfter(dataProperty);\r\n    //删除原 Data 函数节点\r\n    path.remove();\r\n  }\r\n}复制代码七，VUE 组件转换为微信小程序组件中 CSS 部分的处理：那 CSS 我们也是必须要处理的一部分，let try以下是我们要处理的css样本const code = `\r\n  .text-ok{\r\n    position: absolute;\r\n    right: 150px;\r\n    color: #e4393c;\r\n   }\r\n  .nut-popup-close{\r\n    position: absolute;\r\n    top: 50px;\r\n    right: 120px;\r\n    width: 50%;\r\n    height: 200px;\r\n    display: inline-block;\r\n    font-size: 26px;\r\n  }`;复制代码处理后我们得到的.text-ok {\r\n  position: absolute;\r\n  right: 351rpx;\r\n  color: #e4393c;\r\n}\r\n\r\n.nut-popup-close {\r\n  position: absolute;\r\n  top: 117rpx;\r\n  right: 280.79rpx;\r\n  width: 50%;\r\n  height: 468rpx;\r\n  display: inline-block;\r\n  font-size: 60.84rpx;\r\n}复制代码通过前后代码的对比，我们看到了单位尺寸的转换（比如：top: 50px; 转换为 top: 117rpx;）。单位的转换( px 转为了 rpx )CSS 又做了哪些处理呢？同样也有不少的 CSS Code Parsers 供我们选择 Cssom ，CssTree等等，我们拿 Cssom 来实现上方css代码的一个简单的转换。var ast = csstree.parse(code);\r\n   csstree.walk(ast, function(node) {\r\n     if(typeof node.value == \"string\" && isNaN(node.value) != true){\r\n       let newVal = Math.floor((node.value*2.34) * 100) / 100;//转换比例这个根据情况设置即可\r\n         if(node.type === \"Dimension\"){//得到要转换的数字尺寸\r\n           node.value = newVal;\r\n         }\r\n     }\r\n     if(node.unit === \"px\"){//单位的处理\r\n       node.unit = \"rpx\"\r\n     }\r\n });\r\n console.log(csstree.generate(ast));复制代码当然这只是一个 demo，实际项目中使用还的根据项目的实际情况出发，SCSS，LESS等等的转换与考虑不同的处理场景哦！注：本文有些模块的转换实现还未在小程序开发工具中测试。插播一个通过 AST 实现的好东东：将 JavaScript 代码转化生成 SVG 流程图 js2flowchart( 4.5 k stars 在 GitHub )当你拥有 AST 时，可以做任何你想要做的事。把AST转回成字符串代码并不是必要的，你可以通过它画一个流程图，或者其它你想要的东西。js2flowchart使用场景是什么呢？通过流程图，你可以解释你的代码，或者给你代码写文档；通过可视化的解释学习其他人的代码；通过简单的js语法，为每个处理过程简单的描述创建流程图。马上用最简单的方式尝试一下吧，去线上编辑看看\tjs-code-to-svg-flowchart [8]。此处有必要附上截图一张。八、总结：通过以上我们的介绍，我们大概对抽象语法树有了初步的了解。总体思路是：我们用Babel的解析器 把 JavaScript 源码转化为抽象语法树，再通过 Babel 的遍历器遍历 AST (抽象语法树)，替换、移除和添加节点，得到一个新的 AST 树。最后， 使用，Babel 的代码生成器 Babel Generator 模块 读取 处理后的 AST 并将其转换为代码。任务就完成了！本文通过对 VUE 组件转换为微信小程序组件的转换部分包括如下内容：VUE 组件 JavaScript模块 对外属性转换为小程序对外属性的处理VUE 组件 JavaScript模块 内部数据的转换为小程序内部数据的处理VUE 组件 JavaScript模块 methods 中的赋值语句转换为小程序赋值语句的处理VUE 组件 JavaScript模块 外层对象，生命周期钩子函数的处理与 CSS 模块的简易处理希望，本文对大家有所帮助，在技术探索的路上，我们一往无前， Paladin 精神永存！感谢大家的耐心阅读，也欢迎大家关注【全栈探索公众号】，每周都会有技术好文推出！扩展阅读[1]\tastexplorer.net/[2]\tbabeljs.io/docs/en/nex…[3]\tgithub.com/babel/babel…[4]\tesprima.org/demo/parse.…[5]\tsegmentfault.com/a/119000001…[6]\tzh.wikipedia.org/wiki/%E6%8A…[7]\titnext.io/ast-for-jav…[8]\tgithub.com/Bogdan-Lyas…"}
{"title": "小程序的双线程模型 ", "author": "Rolan", "pub_time": "2019-11-6 00:10", "content": "官方文档给出的双线程模型:  小程序的宿主环境 微信客户端提供双线程去执行wxml,wxss，js文件。双线程模型1.上述的渲染层上面运行着wxml文件，渲染层使用是的webview线程进行渲染（一个程序会有多个页面，也就会有多个view线程进行运作）2.js文件是运行在逻辑层，逻辑层的js是通过jscore进行运行的。通过双线程界面的渲染过程是怎样的？wxml与DOM树其实我们wxml文件与我们html中的DOM树是一样的，这样我们就可以有js来模拟一个虚拟的DOM树：初始化渲染如果我们的wxml文件中如果有变量：要与js逻辑层共同渲染页面成为一个真正的DOM树：界面数据发生变化1如果通过setDat把hell改成dsb，则js对象的的节点会发生改变.2 这时会用diff算法对比两个对象的变化，3 然后将变化的部分应用到DOM树上4 从而达到更新页面的目的，这也就是数据驱动的原理总结界面渲染的整体流程1在渲染层将wxml文件与wxss文件转化成js对象也就是虚拟DOM2 在逻辑成将虚拟的DOM对象配合生成，真实的DOM树，在交给渲染层渲染3 当数据变化是，逻辑层提供更新数据，js对象发生改变，用diff算法进行比较4 将更新的内容，反馈到真实的DOM树中，更新页面"}
{"title": "小程序 setData 修改 data 中数组内不定对象的数据 ", "author": "Rolan", "pub_time": "2019-11-6 00:31", "content": "小程序 setData 修改 data 中数组内不定对象的数据普通变量的 setData()在某些时候，我们的小程序中存在的不只是像下面这样的简单的变量: 变量值这种形式data: {\r\n    name: 'Kyle',\r\n    age: 28,\r\n    mail: 'kylebing@163.com'\r\n}这种形式的数据，在需要修改的时候，只需要如下形式修改就可以了 this.setData({\r\n    name: 'Tina'\r\n })数组内部的 setData()有时候，里面会有对象数组，需要修改数组内部的变量，如下面的 people 数组：people: [\r\n  {\r\n    name: 'Kyle',\r\n    age: 24,\r\n    products: [\r\n      {name: 'iPhone', price: 4550},\r\n      {name: 'AirPods Pro', price: 1999},\r\n    ]\r\n  },\r\n  {\r\n    name: 'Tina',\r\n    age: 26,\r\n    products: [\r\n      {name: 'Dell P2415Q', price: 1800},\r\n      {name: 'Macbook Pro', price: 8500},\r\n    ]\r\n  }\r\n]像这种改变数组内部属性的值，需要不同于普通变量的 setData()，格式如下：方括号里接收的是字符串this.setData({\r\n    [ 定位数据的字符串 ]: 数据\r\n})如: 修改 Kyle 的 agethis.setData({\r\n    ['people[0].age']: 25\r\n})上面这是修改数组中固定位置元素的数据，比如现在已经知道需要修改的数据下标变量为 index，修改不定下标的数据又该怎么写呢？因为 [] 方括号中接收的是字符串，所以我们只需要放入对应的字符串即可，可以是 单引号拼接的字符串，也可以是 ES6 反引号形式的字符串，说白了只要是字符串就可以。对比两种形式的写法就能明白什么意思了，写法如下：普通字符串拼接：let index = 1;\r\nthis.setData({\r\n  ['people[' + index + '].age']: 25\r\n})ES6 形式字符串：let index = 1;\r\nthis.setData({\r\n  [`people[${index}].age`]: 25\r\n})修改数组中数组的值这个无非就是再加一层而已，如：修改第二个人的第二个产品的价格，每次点击加 2定义一个方法 changeAirPodsPrice 绑定中页面中的按钮上，代码如下：changeAirPodsPrice: function() {\r\n    let index = 1;  // people 下标，也就是第二个人\r\n    let productIndex = 1 // 产品 下标，也就是第二个产品\r\n    this.setData({\r\n      [`people[${index}].products[${productIndex}].price`]: this.data.people[index].products[productIndex].price + 2\r\n    })\r\n},\r\n效果如图："}
{"title": "当微信小程序遇上filter~ ", "author": "Rolan", "pub_time": "2019-11-6 00:32", "content": "在微信小程序的开发过程中，当你想要实现不同页面间的数据绑定，却为此抓耳饶腮时，不妨让微信小程序与filter 来一场完美的邂逅，相信会给你带来别样的惊喜~前段时间被安利了一个很实用的公众号—前端早读课，它简洁、大方的页面和方便、实用的功能深深地吸引着我~(＾Ｕ＾)ノ 恰好这段时间学了小程序，就自己仿着写了个前端早读课的小程序。实现的功能不同页面间的数据绑定随机显示数组里的元素实时显示系统的日期鼠标点击和页面跳转等基本功能swiper组件和template样式模板的使用使用easy mock模拟后台数据并进行动态传参项目展示整个项目包括“每日一看”、“看看世界”、“情报局”和“介绍”四个主页面。完美邂逅~在开发“每日一看”页面的过程中，我遇到了一个难题，如何将“每日一看”页面中获取的数据与阅读详情页的数据绑定起来，也就是从这时起，微信小程序开始邂逅filter~下面简单介绍一下filter~filter华丽登场~filter 是一个基于数组的方法，通过一个回调函数对数组进行筛选，并返回数组中满足条件的元素，相当于过滤器的效果。filter的三要素数组对象(arry)每个filter 方法都有一个数组对象，通过该方法对数组里的元素进行筛选。 具体用法： arry.filter();\r\n回调函数(callbackfn)对于数组中的每个元素，filter 方法都会调用callbackfn 函数一次。 具体用法： function callbackfn(value, index, array);\r\n其中 value 表示数组元素的值，index 表示数组元素的下标， array 表示包含该元素的数组。返回值filter 方法的返回值是一个数组，包含所有满足回调函数条件的值。更多详情： filter文档别样的惊喜~filter的骚操作—实现数据的动态绑定敲黑板的重点来啦！！！在 dairy.wxml 页面中用 navigator 组件实现 ‘每日一看’ 页面和 ‘阅读详情’ 页的跳转，并传递一个 id 参数，每篇文章都有唯一的一个 id，这样就可以通过 js 使用 filter 过滤器筛选出两个 id 相等的文章数据，也就实现了数据的动态绑定。<navigator url=\"./detail/detail?id={{id}}\">\r\n    <button class=\"page_bd_motto_read\">阅读</button>\r\n</navigator>\r\n在 dairy.js 中，因为页面每次都是随机显示一篇文章，这时就需要获取该文章的id，并作为参数，当页面跳转时作为一个钩子把两个页面联系起来。that.setData({\r\n            headline: arr[index].headline,\r\n            from: arr[index].from,\r\n            // 设置id作为阅读详情页的一个钩子\r\n            id: arr[index].acticle_id\r\n          })\r\n        }\r\n      })\r\n当页面跳转到详情页时，在 detail.js 中使用 filter 把 acticle_id 等于上一页面文章 id 的数据赋值给 datas，再对其进行操作，就实现了数据的动态绑定。Page({\r\n  data: {\r\n    // 表示该篇文章\r\n    item: []\r\n  },\r\n  onLoad: function(params) {\r\n    // 检验id是否传递成功\r\n    console.log(params.id);\r\n    var that = this;\r\n    wx.request({\r\n      url: 'https://www.easy-mock.com/mock/5a2b5f76158e7b70032804d0/getActicleInfo/getActicleInfo',\r\n      success: function(res) {\r\n        // 使用过滤器把id等于上一页面id的数组赋值给datas\r\n        var datas = res.data.data.acticle_List.filter(item => {\r\n          return item.acticle_id == params.id;\r\n        });\r\n        that.setData({\r\n          item: datas\r\n        });\r\n        console.log(datas);\r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n在 detail.wxml 中对传入的 item 数据进行调用，于是别样的惊喜就出现啦~<!--pages/dairy/detail/detail.wxml-->\r\n    <view class=\"page__hd\">\r\n        <view class=\"page__hd_title center\">{{item[0].headline}}</view>\r\n        <view class=\"page__hd_author\">作者：@{{item[0].author}}</view>\r\n    </view>\r\n    <view class=\"page__bd\">\r\n        <text class=\"page__bd_content center\">{{item[0].content}}</text>\r\n    </view>\r\n\r\n特别注意： 可能有细心的人儿已经发现为什么这里用的是 item[0]. 来调用，而不是 **item.**来调用，这是数据索引的问题。如下图所示，我的数据是个三级结构，item 表示的是最外层的文章数组元素，要获取文章的作者或标题等信息，必须使用 item[0]. 才能进行调用。只有理解数据索引的本质，才能准确地调用数据。于是，小程序在遇上filter后，就创造出了别样的惊喜 O(∩_∩)O~一起排坑~在开发过程中，遇到了一些坑，在此总结一下~1. 随机显示数组里的元素这个公众号一大亮点就是可以随机显示文章，每次点进去的文章都不一样，感受度极佳。这里采用随机函数来获取数组的下标，Math.random()函数是获取[0,1)之间的数，Math.floor()函数是向下取整，这样就可以随机获取相应的下标数。 onLoad: function () {\r\n    var that = this;\r\n      wx.request({\r\n        url: 'https://www.easy-mock.com/mock/5a2b5f76158e7b70032804d0/getActicleInfo/getActicleInfo',\r\n        method: 'GET',\r\n        data: {},\r\n        success: function(res) {\r\n          //获取文章数据的列表\r\n          var arr = res.data.data.acticle_List;\r\n          //用随机函数随机获取数组的下标\r\n          var index = Math.floor(Math.random()*arr.length);\r\n          // console.log(arr[index].acticle_id);\r\n          that.setData({\r\n            headline: arr[index].headline,\r\n            from: arr[index].from,\r\n            // 设置id作为阅读详情页的一个钩子\r\n            id: arr[index].acticle_id\r\n          })\r\n        }\r\n      })\r\n  },\r\n})\r\n2. 实时显示系统的日期之前开发的时候觉得这个方法如果自己写还蛮难的，后面百度了一下，发现js里面提供了相应的API，直接使用就好，特别方便。有关系统时间的API  //监听页面显示\r\n  // day：星期几\r\n  // date：某日\r\n  // month：月份\r\n  onShow: function () {\r\n      var myDate = new Date();\r\n      // setData设置或更新数据\r\n      this.setData({\r\n        date: myDate.getDate(),\r\n        month: myDate.getMonth() + 1,\r\n        day: week(),\r\n      });\r\n      function week(day) {\r\n          switch(myDate.getDay()) {\r\n            case 1: day=\"星期一\"; break;\r\n            case 2: day=\"星期二\"; break;\r\n            case 3: day=\"星期三\"; break;\r\n            case 4: day=\"星期四\"; break;\r\n            case 5: day=\"星期五\"; break;\r\n            case 6: day=\"星期六\"; break;\r\n            default: day=\"星期天\";\r\n          }\r\n          return day;\r\n        }\r\n  },\r\n3. 用hover实现鼠标点击效果在对首页进行鼠标点击效果的开发过程中，一开始想到的就是使用伪元素来添加点击按钮的样式效果，后面出现了一个bug，当我点击按钮跳转到另一个页面，再回退到原页面时，还是处于点击态的样式，这时百度就起了很大的作用，我上网百度了很久，才发现有hover属性中的hover-stay-time为动画持续的时间，hover-class 为定义点击按钮时的样式，于是这个bug就解决啦~<view class=\"page__bd\">\r\n    <view class=\"page__bd_tab\" hover-class=\"active\" hover-stay-time=\"2000\">\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"dairyRead\">每日一看</view>\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"lookWorld\">看看世界</view>\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"intelligence\">情报局</view>\r\n      <view class=\"page__bd_tab_item\" hover-class=\"active1\" hover-stay-time=\"2000\" bindtap=\"introduction\">简介</view>\r\n    </view>\r\n  </view>\r\n4. 页面左右滑动的效果使用swiper组件实现对页面的左右滑动的效果。5. template 模板样式的使用当一串代码面临复制粘贴时，这时就应该考虑对其进行封装，这样直接在不同的地方调用就好了，也完成了代码的优化。小程序中的 template 模板就很好地帮我们解决了这个问题，并通过 is 属性来实现调用。template 模板的定义：<!--pages/common/list_intelligence/list_intelligence.wxml-->\r\n<template name = \"intelligence_list\">\r\n <view class=\"page__cell\">\r\n    <view class=\"page__cell_headline center\">\r\n        <view class=\"page__cell_headline_img\">\r\n            <image src=\"{{avatar}}\"/>\r\n        </view>\r\n\r\n        <view class=\"page__cell_headline_author\">{{author}}分享于</view>\r\n        <view class=\"page__cell_headline_time\">{{share_time}}</view>\r\n    </view>\r\n    <view class=\"page__cell_detail center\">{{content}}</view>\r\n </view>\r\n</template>\r\n\r\n\r\ntemplate 模板的调用：  <view class=\"page__bd\">\r\n    <block wx:for=\"{{intelligence_list}}\" wx:key=\"{{index}}\" center >\r\n        <template is=\"intelligence_list\" data=\"{{...item}}\"></template>\r\n    </block>\r\n  </view>\r\n  \r\n我有话要说~开发的过程中难免会出现各种各样的bug，记得一定要百度，百度，百度呀！！！这是个独立思考的过程，对能力的提高也非常有帮助~做这个项目最大的心得便是看太多不如干一场，肯定会干货满满，收获满满哟~这个小程序后续还会完善，感兴趣的可以持续关注哟(＾Ｕ＾)ノ~一波安利~微信小程序开发教程手册微信小程序官方开发文档使用 easy-mock 构造后台虚拟数据使用微信开发者工具进行开发"}
{"title": "小程序页面统计埋点设计思路 ", "author": "Rolan", "pub_time": "2019-11-7 00:02", "content": "需要对小程序的页面访问进行统计，但小程序并没有页面或者路由拦截，如果要重写page或者写mixs函数太麻烦，所以希望有个之后扩展方便，改动成本低的方式进行页面埋点统计。思路埋点页面中的请求方法我们知道在不同页面中写入同一功能的代码是件很烦恼的事情，重复的工作量，各个页面间的差异性处理，都很糟心。所以在小程序这资源有限的环境里，我们希望尽量减少这部分的工作量，最好每个页面的功能代码都一样，并且精。，考虑到每个页面的差异可以用路由体现，并且能拿到当前页面的路由参数，于是采用了这个策略。page({\r\n    ...\r\n    onLoad() {\r\n        app.countViewer(this.route) //数据埋点\r\n        ...\r\n    }\r\n    ...\r\n})\r\n复制代码路由——页面id映射表后端接口需要格式大概是：{\r\n    id: 0, // 页面id\r\n    detailId: 255 // 具体业务情况下的id，例如商品的id、广告的id等\r\n}\r\n复制代码所以我们需要维护的映射表大概会长这样：const RouteList = [\r\n    {\r\n      id: 1,\r\n      route: 'page/index/index',\r\n      name: '活动专题',\r\n    },\r\n    {\r\n      id: 2,\r\n      route: 'page/active/inde',\r\n      name: '活动专题',\r\n    },\r\n]\r\n复制代码封装成个类，构造函数接受当前页的route，和具体的业务id作为参数，并向外提供获得完整RouteList的方法，和当前页面对映信息的方法：// router.js\r\nclass Route {\r\n    RouteList = [\r\n    {\r\n      id: 1,\r\n      route: 'page/index/index',\r\n      name: '活动专题',\r\n    },\r\n    {\r\n      id: 2,\r\n      route: 'page/active/inde',\r\n      name: '活动专题',\r\n    }]\r\n    \r\n    constructor(route, detailId) {\r\n        const currentRoute = this.RouteList.find(item => item.route === route) || {} // 查找符合的当前route的对象， 如果没找到返回空对象，避免报错\r\n        this.page_id = currentRoute.id\r\n        this.page_detail_id = page_detail_id\r\n    }\r\n    \r\n    getRouteList() { // 返回完成对映表\r\n        return RouteList\r\n    }\r\n    \r\n    getData() { // 返回当前对映项\r\n        return {\r\n          page_id: this.page_id,\r\n          page_detail_id: this.page_detail_id\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Route\r\n\r\n复制代码发送方法// countViewer.js 假设$request是已经封装好的方法\r\n\r\nlet Router = require('./router.js')\r\n\r\nexport default function countViewer(router, detailId = 0) { // 给业务id一个默认值\r\n  const app = getApp() // 获得全局的$request封装好的小程序请求\r\n  const params = new Router(router, detailId).getData() //获得当前路由对映的参数信息\r\n\r\n  app.$request('countviewer', params)\r\n}\r\n\r\n复制代码并将该方法绑定到全局的app实例上，页面中使用就不用引入了。页面深度不同，小程序里引入真的很麻烦。// app.js\r\n\r\nimport countViewer from \"./utils/countViewer.js\"\r\n\r\nApp({\r\n    ...\r\n    countViewer,\r\n    ...\r\n})\r\n复制代码结尾好久不更新了，最近正好来了个需求，想想之前刚接手这个小程序的时候想写个路由/页面拦截器，发现网上提供的方法都挺麻烦的，每个页面戳进去改一大段page简直难过，所以一开始听到这个需求是有点想哭的。当任务真砸到头上，还是能想出办法的。怎么说呢，开发原则大概就是，避免去戳页面和糟糕的重复代码，实在要重复，就尽量抽出公共部分把之后更改的时候的工作量降低扒。"}
{"title": "小程序技能进阶回忆录 - 在缺少组件化的日子里 ", "author": "Rolan", "pub_time": "2019-10-21 00:23", "content": "战争，信念，意志和情感，这些散发着光芒和硝烟的词汇，象一枚枚炮弹轰入我们现在的生活。历史的记忆不会被抹灭。当我们在各自项目里幸福的拷贝着官方代码 demo，在 componnets 文件夹里使用 Component方法书写一个个组件时，不要忘记，在 2018 年上半年以前，小程序是没有提供组件化方案的。当时，主要有两种解决方法，一种是 WePY 拷贝法，另一种则是 template 法。WePY 拷贝法比如有个最简单的按钮组件：<!-- components/button.wpy -->\r\n<template>\r\n  <view class=\"button\">\r\n    <button @tap=\"onTap\">点这里</button>\r\n  </view>\r\n</template>\r\n\r\n<!-- pages/index.wpy -->\r\n<template>\r\n  <view class=\"container\">\r\n    <wpy-button /> // button 组件1\r\n    <wpy-button2 /> // button 组件2\r\n  </view>\r\n</template>\r\n复制代码经过编译后结果如下：<view class=\"container\">\r\n  <view class=\"button\">\r\n    <button bindtap=\"$wpyButton$onTap\">点这里</button>\r\n  </view>\r\n  <view class=\"button\">\r\n    <button bindtap=\"$wpyButton2$onTap\">点这里</button>\r\n  </view>\r\n</view>\r\n复制代码为了方便变量隔离，所以引入到页面中的组件得单独命名：import wepy from 'wepy'\r\nimport Button from '@/components/button'\r\nexport default class Index extends wepy.page {\r\n  components = {\r\n    'wpy-button': Button,\r\n    'wpy-button2': Button\r\n  }\r\n  ...\r\n}\r\n复制代码如果多个页面引入同一组件会拷贝多份，有一些不便的地方，但也很好的解决了当时组件化缺失的问题。template 法有心的同学可能记得当初我们发了这篇文章： 微信小程序组件化解决方案wx-component ，当时主要讲了如何使用，这次讲讲技术的细节。主要利用小程序当时提供的 template 模板方法，使用方式如下：<!-- pages/template/login.wxml -->\r\n<template name=\"login\">\r\n  <view class=\"login\">这是登录组件</view>\r\n</template>\r\n复制代码<!-- pages/login/index.wxml -->\r\n<import src='../../components/login/index.wxml'/>\r\n<view class=\"login-box\">\r\n  <template is=\"login\" data=\"{{...}}\"></template>\r\n</view>\r\n复制代码由于知道这只是临时的解决方法，最终还会迁移到微信官方组件化方案。了解到微信团队正在开发，就死皮赖脸找了微信研发同学要下技术方案，以便后期迁移成本做到最低。最后微信同学不耐烦的扔给我们如下代码，并特别嘱咐 不要泄露出去 -_-：Component({\r\n  // 组件名\r\n  name: '',\r\n  // 为其他组件指定别名\r\n  using: {},\r\n  // 类似mixins，组件间代码复用\r\n  behaviors: [],\r\n  // 组件私有数据\r\n  data: {\r\n  },\r\n  // 外部传入的组件属性\r\n  propties: {\r\n  },\r\n  // 当组件被加载\r\n  attached () {\r\n  },\r\n  // 当组件被卸载\r\n  detached () {\r\n  },\r\n  // 组件私有方法\r\n  methods: {\r\n  }\r\n})\r\n复制代码一目了然，依照此文档实现一个简单的组件化方案也有了思路。如何引入组件由于没有办法在小程序全局注入 Component 方法，可以将组件代码以模块方式导出，在页面的 Page 方法里引入：// components/login/index.wxml\r\n<template name=\"login\">\r\n  <form bindsubmit=\"onLoginSubmit\">\r\n    ...\r\n    <button type=\"primary\" formType=\"submit\">{{btnText}}</button>\r\n  </form>\r\n</template>\r\n复制代码// components/login/index.js\r\nmodule.exports = {\r\n  name: 'login',\r\n  data: {\r\n    btnText: ''\r\n  }\r\n  ....\r\n}\r\n复制代码// pages/index/index.js\r\nPage({\r\n  data: {\r\n    ...\r\n  },\r\n  components: {\r\n    login: {\r\n      btnText: '开始',\r\n      onLoginCallback() { ... }\r\n    }\r\n  }\r\n})\r\n复制代码<!-- pages/index/index.wxml -->\r\n<import src='../../components/login/index.wxml'/>\r\n<view class=\"login-box\">\r\n  <template is=\"login\" data=\"{{...login}}\"></template>\r\n</view>\r\n复制代码在 Page 的传参里多了 components 属性，传入了组件名 login ，以及组件对应的属性值和方法。为了使这些新增传参生效，那势必需要对 Page 进行改造。改造 Page如何用一行代码毁掉你的小程序，在小程序根目录的 app.js 里加入这段代码即可：Page = funtion() {}\r\n复制代码这样核心的 Page 的方法就被覆盖掉了，所以利用这个“特性”，可以改造 Page 方法：// utils/wx.js\r\nvar page = function() {\r\n  // 改造代码\r\n  ...\r\n}\r\nmodule.exports = {\r\n  page\r\n}\r\n复制代码// app.js\r\nPage = require('./utils/wx').page\r\n复制代码这就完成了独一无二的自定义的小程序 Page 的方法。Component 怎么写精简了核心的代码如下：function noop() {}\r\n\r\nclass Component {\r\n  constructor (config) {\r\n    // 兼容 onLoad onUnload 的写法\r\n    config.onLoad = config.onLoad || config.attached || noop\r\n    config.onUnload = config.onUnload || config.detached || noop\r\n    this.data = config.data || {}\r\n    this.config = config\r\n    this.methods = config.methods || {}\r\n    for (let name in this.methods) {\r\n      // 为了使组件事件绑定生效，直接挂在到 this 下\r\n      this[name] = methods[name]\r\n    }\r\n  }\r\n  setData (data, deepExtend) {\r\n    let name = this.name\r\n    let parent = this.parent\r\n    let mergeData = extend(deepExtend !== false, parent.data[name], data)\r\n    let newData = {}\r\n    newData[name] = mergeData\r\n    this.data = mergeData\r\n    // 更新页面的 data\r\n    parent.setData(newData)\r\n  }\r\n  setName (name) {\r\n    this.name = name\r\n  }\r\n  setParent (parent) {\r\n    this.parent = parent\r\n  }\r\n}\r\n复制代码主要完成了三件事：配置了组件的生命周期事件 attached 和 detached绑定了组件的事件，使得 template 的 bindtap 等代码生效实现了组件的 setData 功能有个细节，为了让大家容易理解，分享到外部用 onLoad 、 onUnload 代替了 attached 、 detached ，但内部早就开始用微信命名的这两个属性名，才有了代码中的兼容写法。自定的 Page 怎么写整理了大致的核心代码如下：// 缓存下微信的 Page\r\nconst originalPage = Page\r\n// 组件生命周期\r\nconst LIFETIME_EVENT = [\r\n  'onLoad',\r\n  'onUnload'\r\n]\r\nclass MyPage {\r\n  constructor (origin) {\r\n    this.origin = origin\r\n    this.config = {}\r\n    this.children = {}\r\n    this.childrenEvents = {}\r\n\r\n    // 是否需要`components`\r\n    let components = this.components = origin.components\r\n\r\n    if (components) {\r\n      this.config.data = {}\r\n      for (let item in components) {\r\n        let props = components[item] || {}\r\n        let component = new Component(require(`../components/${item}/index`))\r\n\r\n        this.children[name] = component\r\n        // 合并组件的 data\r\n        extend(component.data, component.props)\r\n        // ...\r\n        // 合并组件的 method\r\n        for (let fnName in component.methods) {\r\n          this.config[fnName] = component.methods[fnName].bind(component)\r\n        }\r\n        // ...\r\n        let childrenEvents = this.childrenEvents[item] = {}\r\n        LIFETIME_EVENT.forEach((prop) => {\r\n          childrenEvents[item][prop] = component.config[prop]\r\n        })\r\n      }\r\n      \r\n      // 合并所有依赖组件的生命周期函数\r\n      LIFETIME_EVENT.forEach((prop) => {\r\n        this.config[prop] = () => {\r\n          for (let item in this.components) {\r\n            this.childrenEvents[item][prop].apply(this.component, arguments)\r\n          }\r\n          this.origin[prop] && this.origin[prop].apply(this, arguments)\r\n        }\r\n      })\r\n\r\n      // 把新生成的 config 传给原始的微信的 Page 方法\r\n      originalPage(this.config)\r\n    } else {\r\n      // 没有依赖组件，直接透传给微信的 Page 方法\r\n      originalPage(origin)\r\n    }\r\n\r\n  }\r\n}\r\n复制代码可能有点乱，其实就是不断 merge data 和 method 的过程。最终所有组件自定的数据和方法都被挂在到了 Page 的传参里。最后，导出自定义的 page ：// utils/wx.js\r\nconst page = function (config) {\r\n  return new MyPage(config)\r\n}\r\n\r\nmodule.exports = {\r\n  page\r\n}\r\n复制代码在 app.js 中覆盖掉原有的 Page 方法：// app.js\r\nPage = require('./utils/wx').page\r\n复制代码不完善的地方虽然满足业务了，但也是有些问题的，例如上面 MyPage 方法里的这段：for (let fnName in component.methods) {\r\n  this.config[fnName] = component.methods[fnName].bind(component)\r\n}\r\n复制代码可以看出，直接把组件内部定义的方法，挂在到 config 中去了，这就要求页面的方法和组件的方法不能重名，这是为了方便 template 可以直接绑定组件定义的事件，只能通过把组件事件转移到页面的事件方法里。也有很多其他不完善的地方，但早期通过内部约束代码规范也基本可以解决。结语这种近乎 Hack 的方式支撑了摩拜单车小程序业务大半年的时间，期间产出了大大小小十多个组件。而由于组件内部基本是按照微信官方组件化 api 书写，待官方推出组件化方案后，全部迁移过去的成本也大大减小。传送门小程序技能进阶回忆录 - 也许你并不需要小程序框架小程序技能进阶回忆录 - 在缺少组件化的日子里小程序技能进阶回忆录 - 如何自主实现数据侦听器和计算器 （待发布）小程序技能进阶回忆录 - 如何自主实现拦截器（待发布）小程序技能进阶回忆录 - globalData 的那些事儿（待发布）小程序技能进阶回忆录 - 什么时候执行 onLoad（待发布）小程序技能进阶回忆录 - 增强型的 wx.navigateBack（待发布）广告时间美团单车事业部（摩拜单车）诚招前端 / 小程序研发工程师，有兴趣可以发简历到 zhangshibing@mobike.com ）"}
{"title": "小程序技能进阶回忆录 - 自主实现数据侦听器和计算器 ", "author": "Rolan", "pub_time": "2019-10-22 00:32", "content": "熟悉 Vue 的同学对 computed 和 watch 一定很熟悉，这些特性大大方便了我们对代码中的数据进行处理：\r\nvar vm = new Vue({\r\n  el: '#example',\r\n  data: {\r\n    message: 'Hello'\r\n  },\r\n  computed: {\r\n    // 计算属性的 getter\r\n    reversedMessage: function () {\r\n      // `this` 指向 vm 实例\r\n      return this.message.split('').reverse().join('')\r\n    }\r\n  }\r\n})\r\n复制代码var vm = new Vue({\r\n  el: '#demo',\r\n  data: {\r\n    firstName: 'Foo',\r\n    lastName: 'Bar',\r\n    fullName: 'Foo Bar'\r\n  },\r\n  watch: {\r\n    firstName: function (val) {\r\n      this.fullName = val + ' ' + this.lastName\r\n    },\r\n    lastName: function (val) {\r\n      this.fullName = this.firstName + ' ' + val\r\n    }\r\n  }\r\n})\r\n复制代码这是 Vue 官网中两段代码。\r\n官方实现\r\n如今小程序也有了自己的实现，详见官方文档 observer 。小程序官方 github\r\n中也开源了通过 Behaviors 实现的 Vue 风格的computed和watch：github.com/wechat-mini…。\r\n那么在微信没有提供这些方法之前，如何自主实现数据的侦听器和计算属性呢？\r\n自主实现\r\n先看看定义的使用文档：\r\nPage({\r\n data: {\r\n   list: [],\r\n   list2: [],\r\n   size: 0\r\n },\r\n // 侦听器函数名必须跟需要被侦听的 data 对象中的属性同名，\r\n // 其参数中的 newValue 为属性改变后的新值，oldValue 为改变前的旧值\r\n watch: {\r\n   // 如果 `list` 发生改变，这个函数就会运行\r\n   list(newValue, oldValue) {\r\n     console.log(oldValue + '=>' + newValue)\r\n   }\r\n },\r\n // 传入的参数list必须是 data 里面的属性\r\n // 这里可以传入多个 data 属性\r\n computed({\r\n   list,\r\n   list2\r\n }) {\r\n   return {\r\n     size: list.length,\r\n     size2: list2.length\r\n   }\r\n }\r\n})\r\n复制代码在 Page 的传参中多了两个熟悉的属性，用法不用解释太多。需要继续对小程序提供的 Page 方法进行改造，此外，因为所有数据变化都会用到 setData 方法去触发，所以还需要改造这个方法。\r\n改造 Page 和 setData\r\n想要基于原有的 setData 进行封装，那就得先得到这个函数缓存下来（像是缓存原有的 Page 一样）。想到 onLoad 是小程序页面的第一个生命周期函数，可以在这里进行操作：\r\n// 缓存原有的 `Page`\r\nlet originPage = Page\r\n\r\n// 定义新的 Page\r\nfunction MyPage(config) {\r\n  let that = this\r\n  this.watch = config.watch\r\n  this.computed = config.computed\r\n  this.lifetimeBackup = {\r\n    onLoad: config.onLoad\r\n  }\r\n  config.onLoad = function(options) {\r\n    // 缓存下原有的 `setData`\r\n    this._setData = this.setData.bind(this)\r\n    this.setData = (data) => {\r\n      // 侦听器\r\n      that.watching(data)\r\n      // 计算器\r\n      let newData = that.getComputedData(data)\r\n      this._setData(extend(data, newData))\r\n    }\r\n    // 备份下页面实例\r\n    that.context = this\r\n    // 执行真正的 `onLoad`\r\n    this.lifetimeBackup.onLoad.call(this, options)\r\n  }\r\n  \r\n  // ...\r\n\r\n  originPage(config)\r\n}\r\n\r\nMyPage.prototype.watching = funtion(data) {\r\n  // 执行侦听器\r\n  // ...\r\n}\r\n\r\n// 计算器\r\nMyPage.prototype.getComputedData = function(data) {\r\n  // 开始生成新的数据\r\n  // ...\r\n}\r\n\r\nfunction page (config) {\r\n  return new MyPage(config)\r\n}\r\n复制代码大致代码如上，重新定义了 this.setData，备份了原有的 setData 到 this._setData。当然，这里只考虑了 setData 传一个参数的情况，多个参数需要再对代码优化下。\r\n注意：调用 watching 和 createNewData 的对象是 that，因为 this 指向小程序页面实例，没有自定的这个方法。\r\n做完上述改造，后续的 watch 和 computed 就简单多了。\r\n侦听器 watch\r\nMyPage.prototype.watching = function(data) {\r\n  var context = this.context\r\n  var oldData = context.data\r\n  // 开始生成新的数据\r\n  var watch = this.watch\r\n  if (watch) {\r\n    Object.keys(watch).forEach(function (k) {\r\n      // 如果新的 data 中属性被侦听，执行侦听函数\r\n      if (k in data) {\r\n        var newValue = data[k]\r\n        var oldValue = oldData[k]\r\n        watch[k].apply(context, [\r\n          newValue,\r\n          oldValue\r\n        ])\r\n      }\r\n    })\r\n  }\r\n}\r\n复制代码简易的侦听器就写好了，通过 setData 触发自定的 watch 中的侦听函数。\r\n计算器 computed\r\nMyPage.prototype.getComputedData = function(data) {\r\n  var context = this.context\r\n  var computed = this.computed\r\n  var computedData\r\n  if (computed) {\r\n    computedData = computed.call(context, data)\r\n  }\r\n  return computedData\r\n}\r\n复制代码这样就得到了计算后的新生成的数据：computedData。\r\n总结\r\n不断的通过备份、代理微信原有的方法，自主实现了简单的侦听器和计算器。当然这些代码只是为了方便分享提取出来了提供思路，实际业务中遇到情况复杂的多，代码量远远也不止这些。\r\n传送门\r\n\r\n小程序技能进阶回忆录 - 也许你并不需要小程序框架\r\n小程序技能进阶回忆录 - 在缺少组件化的日子里\r\n小程序技能进阶回忆录 - 如何自主实现数据侦听器和计算器\r\n小程序技能进阶回忆录 - 如何自主实现拦截器（待发布）\r\n小程序技能进阶回忆录 - globalData 的那些事儿（待发布）\r\n小程序技能进阶回忆录 - 什么时候执行 onLoad（待发布）\r\n小程序技能进阶回忆录 - 增强型的 wx.navigateBack（待发布）\r\n\r\n广告时间\r\n美团单车事业部（摩拜单车）诚招前端 / 小程序研发工程师，位置北京，有兴趣可以发简历到 zhangshibing@mobike.com ）"}
{"title": "微信小程序登录、支付（小程序、微信H5、非微信H5）即请求加密方法 ... ", "author": "Rolan", "pub_time": "2019-10-22 00:55", "content": "本文档 当中所用到的:\r\n\t\tconst $request = this.request\r\n\t\tconst post = $request.call('passport/wxLogin',data)\r\n\t\tpost.then(res=>{}).catch()\r\n\t\t是自己封装的请求方法，如axios，参考时可自行更改\r\n复制代码1、js生成接口请求参数签名加密定义规则：对所有发起请求的参数(包括公共参数)，按key进行升序排序 ，然后组合成key1=value1&key2=value2的形式如： parames = {b:value-b, c:value-c,a:value-a}; 排序后应为： string = \"a=value-a&b=value-b&c=value-c\";排序后对其进行md5: string = md5(string);//注意：这里要过滤掉所有为空的参数，空参数，不传将md5的串与密钥再做一次md5: sign = md5( string + secret ); //sceret为密钥，后端分配/** \r\n * 定义对象排序方法\r\n */\r\nobjectSort(parames) \r\n{ \r\n    var newkeys = Object.keys(parames).sort();\r\n    var newObj = {};\r\n    for(var i = 0; i < newkeys.length; i++) \r\n    {\r\n        newObj[newkeys[i]] = parames[newkeys[i]]; \r\n    }\r\n    return newObj;\r\n}\r\n/** \r\n * 计算签名方法\r\n */\r\nmakeSign(params)\r\n\t{\r\n\t    var sign = '';\r\n\t    var parm = '';\r\n\t    \r\n\t    params = objectSort(params);\r\n\t    for (let i in params)\r\n\t    {\r\n\t        var j = params[i];\r\n\t        parm += i + '=' + j + '&';\r\n\t    }\r\n\t    parm = parm.slice(0,-1);\r\n\t    parm.trim();\r\n\t    \r\n\t    sign = Md5.md5(Md5.md5(parm)+$secret);//$secret为密钥，后端分配 \r\n\t    return sign;\r\n\t},\r\n/** \r\n * 过滤data参数中的空字符\r\n */\t\r\nfilterData(data){\r\n\t\tvar result = {};\r\n\t\tfor (let i in data) \r\n\t\t{\r\n\t\t\tvar value = data[i];\r\n\t\t\tif (typeof (value) == 'undefined') {\r\n\t\t\t\tvalue = '';\r\n\t\t\t}\r\n\t\t\tif(typeof(value) == 'string'){\r\n\t\t\t\tvalue = value.trim();\r\n\t\t\t}\r\n\t\t\tif(value)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result; \r\n\t},\r\n/** \r\n * 构建data参数\r\n */\r\nbulidData(data) {\r\n\t\tif(typeof(data) != 'object'){\r\n\t\t\tdata = {};\r\n\t\t}\r\n\t\t//构建参数\r\n\t\tdata.timestamp = (new Date()).valueOf();\r\n\t\tdata.app_id = Config.app_info.app_id;\r\n\t\t//过滤\r\n\t\tdata = this.filterData(data);\r\n\t\t//检测用户是否登录\r\n\t\tvar token = Helper.user.getToken();\r\n\t\tif(token)\r\n\t\t{\r\n\t\t\tdata.token = token;\r\n\t\t}\r\n\t\tdata.sign = this.makeSign(data);\r\n\t\treturn data;\r\n\t},\r\n复制代码微信登录这里采用 button的开放属性 open-type 触发@getuserinfo事件 获取到code 发送给后台 换取token 存到storge;详细参考微信官方文档<template>\r\n\t<button openType=\"getUserInfo\" lang=\"zh_CN\" @getuserinfo=\"getUserInfo\">授权登录</button>\r\n</template>\r\n\r\n\r\nmethods: {\r\n    getCode(callback) {\r\n    \twx.login({\r\n    \t\tsuccess: res => {\r\n    \t\t\tconsole.log(res);\r\n    \t\t\tif (res.errMsg == 'login:ok') {\r\n    \t\t\t\tif (callback) {\r\n    \t\t\t\t\tcallback(res.code)\r\n    \t\t\t\t}\r\n    \t\t\t\tthis.code = res.code\r\n    \t\t\t}\r\n    \t\t}\r\n    \t});\r\n    },\r\n    getUserInfo(e) {\r\n    \tthis.getCode(code => {\r\n    \t\tif (e.detail.errMsg !== 'getPhoneNumber:ok') {\r\n    \t\t\treturn false;\r\n    \t\t}\r\n    \t\twx.showLoading({\r\n    \t\t\ttitle: '正在登录',\r\n    \t\t\tmask: true\r\n    \t\t});\r\n    \t\tconst data = {\r\n    \t\t\tcode:this.code,\r\n    \t\t\tiv:e.detail.iv,\r\n    \t\t\tencryptedData:e.detail.encryptedData\r\n    \t\t}\r\n    \t\t\r\n    \t\t//发起请求登录\r\n    \t\tconst $request = this.request\r\n    \t\tconst post = $request.call('passport/wxLogin',data)\r\n    \t\tpost.then(res =>{\r\n    \t\t\tconsole.log(res)\r\n    \t\t\tuni.setStorageSync('_user_login_token', res.data.token)\r\n    \t\t}).catch(err => {\r\n    \t\t\t\t//常规catch, 一般不用修改\r\n    \t\t\t\t$request.callError(err)\r\n    \t\t})\r\n    \t});\r\n    }\r\n}\r\n复制代码微信小程序支付首先获取code{uni.login()} 然后调后台接口 把code和订单好传给后台，后台 返回的数据就是小程序调支付的参数{uni.requestPayment()} 就这么简单const $request = this.request\r\nconst resLogin = await uni.login()\r\nif (resLogin[0] !== null || resLogin[1].errMsg !== 'login:ok') {\r\n\treturn uni.showToast({\r\n\t\ttitle: 'code获取失败',\r\n\t\ticon: 'none'\r\n\t})\r\n}\r\nconst code = resLogin[1].code\r\n\r\nconst post = $request.call('order/doPay', {\r\n\torder_id: this.order_id,\r\n\tpay_type: '无忌微信小程序支付',\r\n\tcode: code\r\n})\r\npost.then(data => {\r\n\t// 返回数据，只返回接口中的data\r\n\tconst result = JSON.parse(data.data.pay_data)//字符串转对象\r\n\tuni.requestPayment({\r\n\t\tprovider: 'wxpay',\r\n\t\ttimeStamp: result.timeStamp,\r\n\t\tnonceStr: result.nonceStr,\r\n\t\tpackage: result.package,\r\n\t\tsignType: result.signType,\r\n\t\tpaySign: result.paySign,\r\n\t\tsuccess: res => {\r\n\t\t\tconsole.log('success:' + JSON.stringify(res))\r\n\t\t\tthis.requestDetail()\r\n\t\t},\r\n\t\tfail: err => {\r\n\t\t\tconsole.log('fail:' + JSON.stringify(err))\r\n\t\t}\r\n\t})\r\n}).catch(function(e) {\r\n\t//常规catch, 一般不用修改\r\n\t$request.callError(e)\r\n复制代码4、H5支付(微信内浏览器/JSPAI)获取code在登录时就获取code，后台得到openId将其存起来，之后后台在用到openId的地方就不用再获取了（不会过期）getCode(){\r\n\tlet appid = {appid}\r\n\tlet redirect_uri = encodeURIComponent({url})//回调页面地址\r\n\twindow.location.href = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=\" + appid + \"&redirect_uri=\" + redirect_uri + \"&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect\"\r\n}\r\n复制代码封装H5支付代码**\r\n * 支付\r\n * 这里的 $request.call()为自己封装的请求方法，使用时请自行更改\r\n */\r\nvar payH5 = {\r\n\tonBridgeReady: function(url, $params,success) {\r\n\t\tconst post_H5 = $request.call(url, $params)\r\n\t\tpost_H5.then(data => {\r\n\t\t\t// 返回数据，只返回接口中的data\r\n\t\t\tconst result_H5 = JSON.parse(data.data.pay_data)//后台返回的数据为字符串，转换对象\r\n\t\t\tWeixinJSBridge.invoke(\r\n\t\t\t\t'getBrandWCPayRequest', {\r\n\t\t\t\t\t\"appId\": result_H5.appId, //公众号名称，由商户传入\r\n\t\t\t\t\t\"timeStamp\": result_H5.timeStamp, //时间戳，自1970年以来的秒数\r\n\t\t\t\t\t\"nonceStr\": result_H5.nonceStr, //随机串     \r\n\t\t\t\t\t\"package\": result_H5.package,\r\n\t\t\t\t\t\"signType\": result_H5.signType, //微信签名方式：     \r\n\t\t\t\t\t\"paySign\": result_H5.paySign //微信签名 \r\n\t\t\t\t},\r\n\t\t\t\tfunction(res) {\r\n\t\t\t\t\tif (res.err_msg == \"get_brand_wcpay_request:ok\") {\r\n\t\t\t\t\t\tvar msg = '支付成功';\r\n\t\t\t\t\t\tsuccess(msg)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar msg = '支付失败';\r\n\t\t\t\t\t\tsuccess(msg)\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t}).catch(function(e) {\r\n\t\t\t//常规catch, 一般不用修改\r\n\t\t\t$request.callError(e)\r\n\t\t})\r\n\t},\r\n\r\n\tdoPay(url, $params,success) {\r\n\t\tif (typeof WeixinJSBridge == \"undefined\") {\r\n\t\t\tif (document.addEventListener) {\r\n\t\t\t\tdocument.addEventListener('WeixinJSBridgeReady', this.onBridgeReady, false);\r\n\t\t\t} else if (document.attachEvent) {\r\n\t\t\t\tdocument.attachEvent('WeixinJSBridgeReady', this.onBridgeReady);\r\n\t\t\t\tdocument.attachEvent('onWeixinJSBridgeReady', this.onBridgeReady);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.onBridgeReady(url, $params,success)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default payH5\r\n复制代码支付调用将这个文件引入需要的页面或者挂载到vue原型上（这里以uni-app中介绍）在main.js中 引入： \r\n\t\t\t\timport H5Pay from './api/h5Pay.js'\r\n\t\t\t\tVue.prototype.H5Pay = H5Pay\r\n\r\n页面引用:\r\n\r\n\t\t\tthis.H5Pay.doPay(url,params,callback)\r\n参数：\t \t  url:接口请求地址\r\n\t\t\tparams：请求参数\r\n\t\t\tcallback:回调方法（回调支付结果）\r\n\r\nH5pay(){\r\n\tthis.H5Pay.doPay('order/doPay', {\r\n\t\t\t\t\torder_id: order_id,//订单号\r\n\t\t\t\t\tpay_type: '',//支付方式\r\n\t\t\t\t}, function(msg) {\r\n\t\t\t\t\tuni.showToast({\r\n\t\t\t\t\t\ttitle: msg,\r\n\t\t\t\t\t\ticon:'none'\r\n\t\t\t\t\t})\r\n\t\t\t\t\tuni.navigateBack()\r\n\t\t\t\t})\r\n}\r\n复制代码5、H5支付（非微信内置浏览器）相对来说前端简单很多，没什么麻烦要求 后台会返回一个mwev_url ，window.location.href = mwev_url + redirect_uri （这里的redirect_uri 是重定向的页面地址，域名要和支付域名一致 ！！！做编译encodeURIComponent(url)）dopayWeb() { //非微信浏览器支付\r\n\tconst $request = this.request;\r\n\tconst post = $request.call('order/doPay', {\r\n\t\torder_id: this.order_id,//订单号\r\n\t\tpay_type: 'nweb'//支付方式\r\n\t});\r\n\tpost.then(res => {\r\n\t\tconsole.log(res);\r\n\t\tlet url = res.mwev_url\r\n\t\tlet redirect_uri = encodeURIComponent(url)\r\n\t\twindow.location.href = url + \"&redirect_uri=\" + redirect_uri \r\n\t}).catch(function(e) {\r\n\t\t$request.callError(e)\r\n\t});\r\n},\r\n复制代码6、 区分是否是微信内置浏览器function isMicroMessenger() {\r\n    let result = false;\r\n    let userAgent = window.navigator.userAgent;    \r\n    if(userAgent.indexOf('MicroMessenger') > -1) {\r\n        result = true;\r\n    }\r\n    return result;\r\n}\r\n复制代码"}
{"title": "小程序自定义头部导航栏“完美”解决方案 ", "author": "Rolan", "pub_time": "2019-10-23 00:03", "content": "为什么要做这个？主要是在项目中，智酷君发现的一些问题一些页面是通过扫码和订阅消息访问后，没有直接可以点击去首页的，需要添加一个home链接需要添加自定义搜索功能需要自定义一些功能按钮其实,第一个问题，在最近的微信版本更新中已经优化了，通过 小程序模板消息 过来的，系统会自动加上 home按钮 ，但对于其他的访问方式则没有支持~一个不大不小的问题：两边ICON不对齐问题智酷君之前尝试了各种解决方法，发现有一个问题，就是现在手机屏幕太多种多样，有 传统头部、宽/窄刘海屏、水滴屏等等 ，无法八门，很多解决方案都无法解决特殊头部，系统 “胶囊按钮” 和 自定义按钮在Android屏幕可能有 几像素不对齐 的问题（强迫症的噩梦）。下面分享下一个相对比较完善的解决方案：小程序代码段DEMOLink: https://developers.weixin.qq.... ID: cuUaCimT72cH智酷君做了一个demo代码段，方便大家直接用IDE工具查看源码~页面配置1、页面JSON配置{\r\n  \"usingComponents\": {\r\n    \"NavComponent\": \"/components/nav/common\"  //以插件的方式引入\r\n  },\r\n  \"navigationStyle\": \"custom\"  //自定义头部需要设置\r\n}如果需要自定义头部，需要设置navigationStyle为 “custom”2、页面代码<!-- home 类型的菜单 -->\r\n<NavComponent v-title=\"自定义头部\" bind:commonNavAttr=\"commonNavAttr\"></NavComponent>\r\n<!-- 搜索菜单 -->\r\n<NavComponent is-search=\"true\" bind:commonNavAttr=\"commonNavAttr\"></NavComponent>可以在自定义导航标签上添加属性配置来设置功能，具体按照实际需要来3、目录结构│\r\n├─components\r\n│  └─nav\r\n│          common.js\r\n│          common.json\r\n│          common.wxml\r\n│          common.wxss\r\n│\r\n├─images\r\n│      back.png\r\n│      home.png\r\n│\r\n└─index\r\n        index.js\r\n        index.json\r\n        index.wxml\r\n        index.wxss\r\n        search.js\r\n        search.json\r\n        search.wxml\r\n        search.wxss仅供参考插件对应的JS部分components/nav/common.js部分const app = getApp();\r\nComponent({\r\n  properties: {\r\n    vTitle: {\r\n      type: String,\r\n      value: \"\"\r\n    },\r\n    isSearch:{\r\n      type: Boolean,\r\n      value: false\r\n    }\r\n  },\r\n  data: {\r\n    haveBack: true, // 是否有返回按钮，true 有 false 没有 若从分享页进入则没有返回按钮\r\n    statusBarHeight: 0, // 状态栏高度\r\n    navbarHeight: 0, // 顶部导航栏高度\r\n    navbarBtn: { // 胶囊位置信息\r\n      height: 0,\r\n      width: 0,\r\n      top: 0,\r\n      bottom: 0,\r\n      right: 0\r\n    },\r\n    cusnavH: 0, //title高度\r\n  },\r\n  // 微信7.0.0支持wx.getMenuButtonBoundingClientRect()获得胶囊按钮高度\r\n  attached: function () {\r\n    if (!app.globalData.systeminfo) {\r\n      app.globalData.systeminfo = wx.getSystemInfoSync();\r\n    }\r\n    if (!app.globalData.headerBtnPosi) app.globalData.headerBtnPosi = wx.getMenuButtonBoundingClientRect();\r\n    console.log(app.globalData)\r\n    let statusBarHeight = app.globalData.systeminfo.statusBarHeight // 状态栏高度\r\n    let headerPosi = app.globalData.headerBtnPosi // 胶囊位置信息\r\n    console.log(statusBarHeight)\r\n    console.log(headerPosi)\r\n    let btnPosi = { // 胶囊实际位置，坐标信息不是左上角原点\r\n      height: headerPosi.height,\r\n      width: headerPosi.width,\r\n      top: headerPosi.top - statusBarHeight, // 胶囊top - 状态栏高度\r\n      bottom: headerPosi.bottom - headerPosi.height - statusBarHeight, // 胶囊bottom - 胶囊height - 状态栏height （胶囊实际bottom 为距离导航栏底部的长度）\r\n      right: app.globalData.systeminfo.windowWidth - headerPosi.right // 这里不能获取 屏幕宽度，PC端打开小程序会有BUG，要获取窗口高度 - 胶囊right\r\n    }\r\n    let haveBack;\r\n    if (getCurrentPages().length != 1) { // 当只有一个页面时，并且是从分享页进入\r\n      haveBack = false;\r\n    } else {\r\n      haveBack = true;\r\n    }\r\n    var cusnavH = btnPosi.height + btnPosi.top + btnPosi.bottom // 导航高度\r\n    console.log( app.globalData.systeminfo.windowWidth, headerPosi.width)\r\n    this.setData({\r\n      haveBack: haveBack, // 获取是否是通过分享进入的小程序\r\n      statusBarHeight: statusBarHeight,\r\n      navbarHeight: headerPosi.bottom + btnPosi.bottom, // 胶囊bottom + 胶囊实际bottom\r\n      navbarBtn: btnPosi,\r\n      cusnavH: cusnavH\r\n    });\r\n    //将实际nav高度传给父类页面\r\n    this.triggerEvent('commonNavAttr',{\r\n      height: headerPosi.bottom + btnPosi.bottom\r\n    });\r\n  },\r\n  methods: {\r\n    _goBack: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      });\r\n    },\r\n    bindKeyInput:function(e){\r\n      console.log(e.detail.value);\r\n    }\r\n  }\r\n})解决不同屏幕头部不对齐问题的终极办法是 wx.getMenuButtonBoundingClientRect()这个方法从微信7.0.0开始支持，通过这个方法我们可以获取到右边系统胶囊的top、height、right等属性，这样无论是水滴屏、刘海屏、异形屏，都能完美对齐右边系统默认的胶囊bar，完美治愈强迫症~APP.js 部分//app.js\r\nApp({\r\n  /**\r\n   * 加载页面\r\n   * @param {*} options \r\n   */\r\n  onShow: function (options) {\r\n   \r\n  },\r\n  onLaunch: async function () {\r\n    let self = this;\r\n\r\n    //设置默认分享\r\n    this.globalData.shareData = {\r\n      title: \"智酷方程式\"\r\n    }\r\n\r\n    // this.getSysInfo();\r\n  },\r\n  globalData: {\r\n    //默认分享文案\r\n    shareData: {},\r\n    qrCodeScene: false, //二维码扫码进入传参\r\n    systeminfo: false,   //系统信息\r\n    headerBtnPosi: false,  //头部菜单高度\r\n  }\r\n});将获取的参数存储在一个全局变量globalData中，可以减少反复调用的性能消耗。插件HTML部分<view class=\"custom_nav\" style=\"height:{{navbarHeight}}px;\">\r\n    <view class=\"custom_nav_box\" style=\"height:{{navbarHeight}}px;\">\r\n        <view class=\"custom_nav_bar\" style=\"top:{{statusBarHeight}}px; height:{{cusnavH}}px;\">\r\n            <!-- 搜索部分-->\r\n            <block wx:if=\"{{isSearch}}\">\r\n                <input class=\"navSearch\"\r\n                    style=\"height:{{navbarBtn.height-2}}px;line-height:{{navbarBtn.height-4}}px; top:{{navbarBtn.top+1}}px; left:{{navbarBtn.right}}px; border-radius:{{navbarBtn.height/2}}px;\"\r\n                    maxlength=\"10\" bindinput=\"bindKeyInput\" placeholder=\"输入文字搜索\" />\r\n            </block>\r\n            <!-- HOME 部分-->\r\n            <block wx:else>\r\n                <view class=\"custom_nav_icon {{!haveBack||'borderLine'}}\"\r\n                    style=\"height:{{navbarBtn.height}}px;line-height:{{navbarBtn.height-2}}px; top:{{navbarBtn.top}}px; left:{{navbarBtn.right}}px; border-radius:{{navbarBtn.height/2}}px;\">\r\n                    <view wx:if=\"{{haveBack}}\" class=\"icon-back\" bindtap='_goBack'>\r\n                        <image src='/images/back.png' mode='aspectFill' class='back-pre'></image>\r\n                    </view>\r\n                    <view wx:if=\"{{haveBack}}\" class='navbar-v-line'></view>\r\n                    <view class=\"icon-home\">\r\n                        <navigator class=\"home_a\" url=\"/pages/home/index\" open-type=\"switchTab\">\r\n                            <image src='/images/home.png' mode='aspectFill' class='back-home'></image>\r\n                        </navigator>\r\n                    </view>\r\n                </view>\r\n                <view class=\"nav_title\" style=\"height:{{cusnavH}}px; line-height:{{cusnavH}}px;\">\r\n                    {{vTitle}}\r\n                </view>\r\n            </block>\r\n        </view>\r\n    </view>\r\n</view>主要是对几种状态的判断和定位的计算。插件CSS部分/* components/nav/test.wxss */\r\n.custom_nav {\r\n    width: 100%;\r\n    background: #3a7dd7;\r\n    position: relative;\r\n    z-index: 99999;\r\n}\r\n.custom_nav_box {\r\n    position: fixed;\r\n    width: 100%;\r\n    background: #3a7dd7;\r\n    z-index: 99999;\r\n    border-bottom: 1rpx solid rgba(255, 255, 255, 0.3);\r\n}\r\n.custom_nav_bar {\r\n    position: relative;\r\n    z-index: 9;\r\n}\r\n.custom_nav_box .nav_title {\r\n    font-size: 28rpx;\r\n    color: #fff;\r\n    text-align: center;\r\n    position: absolute;\r\n    max-width: 360rpx;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    margin: auto;\r\n    z-index: 1;\r\n}\r\n.custom_nav_box .custom_nav_icon {\r\n    position:absolute;\r\n    z-index: 2;\r\n    display: inline-block;\r\n    border-radius: 50%;\r\n    vertical-align: top;\r\n    font-size:0;\r\n    box-sizing: border-box;\r\n}\r\n.custom_nav_box .custom_nav_icon.borderLine {\r\n    border: 1rpx solid rgba(255, 255, 255, 0.3);\r\n    background: rgba(0, 0, 0, 0.1);\r\n}\r\n.navbar-v-line {\r\n    width: 1px;\r\n    margin-top: 14rpx;\r\n    height: 32rpx;\r\n    background-color: rgba(255, 255, 255, 0.3);\r\n    display: inline-block;\r\n    vertical-align: top;\r\n}\r\n.icon-back {\r\n    display: inline-block;\r\n    width: 74rpx;\r\n    padding-left: 20rpx;\r\n    vertical-align: top;\r\n    /* margin-top: 12rpx;\r\n    vertical-align: top; */\r\n    height: 100%;\r\n}\r\n.icon-home {\r\n    /* margin-top: 8rpx;\r\n    vertical-align: top; */\r\n    display: inline-block;\r\n    width: 80rpx;\r\n    text-align: center;\r\n    vertical-align: top;\r\n    height: 100%;\r\n}\r\n.icon-home .home_a {\r\n    height: 100%;\r\n    display: inline-block;\r\n    vertical-align: top;\r\n    width: 35rpx;\r\n}\r\n.custom_nav_box .back-pre,\r\n.custom_nav_box .back-home {\r\n    width: 35rpx;\r\n    height: 35rpx;\r\n    vertical-align: middle;\r\n}\r\n.navSearch {\r\n  width: 200px;\r\n  background: #fff;\r\n  font-size: 14px;\r\n  position: absolute;\r\n  padding: 0 20rpx;\r\n  z-index: 9;\r\n}总结通过微信API:getMenuButtonBoundingClientRect(),结果各类手机屏幕的适配问题将算好的参数存储在全局变量中，一次计算全局使用，爽YY~"}
{"title": "小程序技能进阶回忆录 - 如何自主实现拦截器 ", "author": "Rolan", "pub_time": "2019-10-23 00:23", "content": "窗外，是5月明媚的阳光，澄澈蔚蓝的天空，有炮弹欢快地叫着飞过。50多年过去了，我依然如此清晰地记得。在一些框架中发现会提供一个很实用的功能：拦截器（interceptor）。例如要实现这个需求：小程序每次获取到定位后都存到\tglobalData 里：wx.getLocation({\r\n  // ..\r\n  success(res) {\r\n    getApp().globalData.location = res\r\n    // ...\r\n  }\r\n})\r\n复制代码如果每一处使用\twx.getLocation 的地方都这么写也没啥大问题，但总显得不够“智能”，一方面是多了重复代码，另一方面如果需求变动，获取到定位后存到别的地方，那要改很多次。优雅的拦截器有了拦截器，可以更优雅的实现它：intercept('getLocation', {\r\n  success(res) {\r\n    getApp().globalData.location = res\r\n  }\r\n})\r\n复制代码只要在一处定义如上的拦截器，其他地方直接用\twx.getLocation 即可。那么，如何实现上面的方式呢？实现 intercept 方法// utils/intercept.js\r\n// 存储拦截器定义\r\nvar interceptors = {}\r\nfunction intercept(key, config) {\r\n  intercept[key] = config\r\n}\r\nexport {\r\n  intercept,\r\n  interceptors\r\n}\r\n复制代码很简单，暴露出\tintercept 方法，定义一个存储器也一并暴露出去。代理 wx要实现使用\twx.getLocation 自动应用拦截器，就必须基于原有方法重新定义它。import { interceptors } from './intercept'\r\n\r\n// 备份原有微信方法\r\nvar wxBackup = {}\r\n[\r\n  'getLocation'\r\n  // 还可以有很多其他方法 ...\r\n].forEach((key) => {\r\n  wxBackup[key] = wx[key]\r\n  wx[key] = (config) => {\r\n    if (interceptors[key]) {\r\n      // 备份业务代码传入的回调方法\r\n      var backup = {}\r\n      var interceptor = interceptors[key]\r\n      [\r\n        'success',\r\n        'fail',\r\n        'complete'\r\n      ].forEach((k) => {\r\n        backup[k] = config[k]\r\n        config[k] = (res) => {\r\n          interceptor[k](res)\r\n          backup[k](res)\r\n        }\r\n      })\r\n    }\r\n    wxBackup[key](config)\r\n  }\r\n})\r\n复制代码当然，上述代码用数组列出了所有可能被定义拦截器的微信函数，也可以使用\tObject.keys(wx) 通用处理。更多使用场景上面的场景比较简单，拦截器的应用还有更多场景。比如每次请求传参带上公参经纬度，接口返回的数据都会约定包裹在\tobject 中，请求回来需要取一遍。数据异常时还要针对错误码做特定处理，就可以很方便的用拦截器处理：intercept('request', {\r\n  data(data) {\r\n    var location = getApp().globalData.location\r\n    data.location = location.latitude + ',' + location.longitude\r\n    return data\r\n  },\r\n  success(res) {\r\n    if (res.code == 200) {\r\n      return res.object\r\n    } else {\r\n      if (res.code == 'xxx') {\r\n        // 登录失效，重新登录\r\n        // ....\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码注意，拦截器函数里多了返回值，具体实现方法就不多写，基于上述实现完善代码即可。总结细心的读者可能发现，我们代理或者改造了很多微信提供的方法，有些开发者可能不喜欢这样，希望保持原有代码的纯洁性。这要看团队喜好吧，基于此考虑，主要是不想定义太多新的方法或 api，尽量以大家最为熟悉的方式书写代码。"}
{"title": "实战分享: 小程序云开发玩转订阅消息 ", "author": "Rolan", "pub_time": "2019-10-24 00:15", "content": "微信官方为提升小程序模板消息能力的使用体验，对模板消息的下发条件进行了调整。原有的小程序模板消息接口于 2020 年 1 月 10 日下线，届时将无法使用旧的小程序模板消息接口发送模板消息，取而代之的是新的一次性订阅消息和长期订阅消息。\r\n订阅消息给小程序开发者带来了更好的触达用户的能力，在具体实施过程中，开发者如何把模板消息换成新的订阅消息，是否需要购买服务器来实现服务器鉴权，怎样才能在用户订阅之后一段时间后，给用户发送长期或一次性订阅消息呢？\r\n小程序·云开发最近支持了通过云调用免 access_token 发送订阅消息，还新增支持了在定时触发器中实现云调用，这些能力可以帮助开发者轻松玩转小程序订阅消息。\r\n我们今天会利用小程序·云开发进行一个小程序中实现订阅开课提醒的实战，帮助大家了解如何基于小程序·云开发快速接入小程序订阅消息。\r\n整体时序图\r\n\r\n环境准备\r\n\r\n注册小程序帐号\r\n开通云开发服务\r\n\r\n获取订阅消息模板 ID\r\n在微信小程序管理后台中，新增一个订阅消息的模板，这里我们新增了一个开课提醒的模板。\r\n引导用户订阅\r\n微信小程序提供了wx.requestSubscribeMessage 接口来发起申请订阅权限界面。\r\n\r\n在 \"订阅开课提醒\" 的按钮上绑定 tap 事件，事件处理器我们这里用的 onSubscribe\r\nindex.wxml\r\n<button\r\n  class=\"btn\"\r\n  data-item=\"{{ item }}\"\r\n  bindtap=\"onSubscribe\"\r\n  hover-class=\"btn-hover\"\r\n>\r\n  订阅开课提醒\r\n</button>\r\n复制代码在 onSubscribe 函数内，我们会调用微信 API wx.requestSubscribeMessage 申请发送订阅消息权限，当用户在弹窗同意订阅之后，我们会收到 success 回调，将订阅的课程信息调用云函数 subscribe 存入云开发数据库，云函数 subscribe 的实现在下文会讲。\r\nindex.js\r\nonSubscribe: function(e) {\r\n    // 获取课程信息\r\n    const item = e.currentTarget.dataset.item;\r\n\r\n    // 调用微信 API 申请发送订阅消息\r\n    wx.requestSubscribeMessage({\r\n      // 传入订阅消息的模板id，模板 id 可在小程序管理后台申请\r\n      tmplIds: [lessonTmplId],\r\n      success(res) {\r\n        // 申请订阅成功\r\n        if (res.errMsg === 'requestSubscribeMessage:ok') {\r\n          // 这里将订阅的课程信息调用云函数存入云开发数据\r\n          wx.cloud\r\n            .callFunction({\r\n              name: 'subscribe',\r\n              data: {\r\n                data: item,\r\n                templateId: lessonTmplId,\r\n              },\r\n            })\r\n            .then(() => {\r\n              wx.showToast({\r\n                title: '订阅成功',\r\n                icon: 'success',\r\n                duration: 2000,\r\n              });\r\n            })\r\n            .catch(() => {\r\n              wx.showToast({\r\n                title: '订阅失败',\r\n                icon: 'success',\r\n                duration: 2000,\r\n              });\r\n            });\r\n        }\r\n      },\r\n    });\r\n  },\r\n复制代码将订阅消息存入云开发数据库\r\n接下来我们创建一个云函数 subscribe ，这个云函数的作用是将用户的订阅信息存入云开发数据库的集合 messages 中，等待将来需要通知用户时进行调用。\r\n在微信开发者工具的云开发面板中创建数据库集合 messages\r\n创建一个 subscribe 云函数，在云函数中我们将小程序端发送过来的课程订阅信息，存储在云开发数据库集合中，开发完成后，在微信开发者工具中右键上传并部署云函数。\r\ncloudfunctions/subscribe/index.js\r\nconst cloud = require('wx-server-sdk');\r\ncloud.init();\r\nconst db = cloud.database();\r\n\r\nexports.main = async (event, context) => {\r\n  try {\r\n    const {OPENID} = cloud.getWXContext();\r\n    // 在云开发数据库中存储用户订阅的课程\r\n    const result = await db.collection('messages').add({\r\n      data: {\r\n        touser: OPENID, // 订阅者的openid\r\n        page: 'index', // 订阅消息卡片点击后会打开小程序的哪个页面\r\n        data: event.data, // 订阅消息的数据\r\n        templateId: event.templateId, // 订阅消息模板ID\r\n        done: false, // 消息发送状态设置为 false\r\n      },\r\n    });\r\n    return result;\r\n  } catch (err) {\r\n    console.log(err);\r\n    return err;\r\n  }\r\n};\r\n复制代码利用定时触发器来定期发送订阅消息\r\n接下来我们需要实现一个定时执行的云函数send，来检查数据库中是否有需要发送给用户的订阅消息。如果有需要发送的订阅消息，会通过云调用 cloud.openapi.subscribeMessage.send 将订阅消息发送给用户。\r\n创建一个名叫 send 的云函数，首先要配置云函数，在 config.json 的 permissions 中新增 subscribeMessage.send的云调用权限，然后新增一个 sendMessagerTimer 的定时触发器，定时触发器的语法和 linux 的 crontab 类似，比如，我们配置的 \"0 * * * * * *\" 代表每分钟执行一次云函数。\r\ncloudfunctions/send/config.json\r\n{\r\n  \"permissions\": {\r\n    \"openapi\": [\"subscribeMessage.send\"]\r\n  },\r\n  \"triggers\": [\r\n    {\r\n      \"name\": \"sendMessagerTimer\",\r\n      \"type\": \"timer\",\r\n      \"config\": \"0 * * * * * *\"\r\n    }\r\n  ]\r\n}\r\n复制代码接下来是实现发送订阅消息的云函数，这个云函数会从云开发数据库集合messages中查询等待发送的消息列表，检查数据库中是否有需要发送给用户的订阅消息，发送条件可以根据自己的业务实现，比如开课提醒可以根据课程开课日期来检查是否需要发送订阅消息，在我们下面的代码示例里做了简化，筛选条件只检查了状态为未发送。\r\n查询到待发送的消息列表之后，我们会循环消息列表，依次发送每条订阅消息，发送成功后将数据库中消息的状态改为已发送。\r\ncloudfunctions/send/index.js\r\nconst cloud = require('wx-server-sdk');\r\n\r\nexports.main = async (event, context) => {\r\n  cloud.init();\r\n  const db = cloud.database();\r\n\r\n  try {\r\n    // 从云开发数据库中查询等待发送的消息列表\r\n    const messages = await db\r\n      .collection('messages')\r\n      // 查询条件这里做了简化，只查找了状态为未发送的消息\r\n      // 在真正的生产环境，可以根据开课日期等条件筛选应该发送哪些消息\r\n      .where({\r\n        done: false,\r\n      })\r\n      .get();\r\n\r\n    // 循环消息列表\r\n    const sendPromises = messages.data.map(async message => {\r\n      try {\r\n        // 发送订阅消息\r\n        await cloud.openapi.subscribeMessage.send({\r\n          touser: message.touser,\r\n          page: message.page,\r\n          data: message.data,\r\n          templateId: message.templateId,\r\n        });\r\n        // 发送成功后将消息的状态改为已发送\r\n        return db\r\n          .collection('messages')\r\n          .doc(message._id)\r\n          .update({\r\n            data: {\r\n              done: true,\r\n            },\r\n          });\r\n      } catch (e) {\r\n        return e;\r\n      }\r\n    });\r\n\r\n    return Promise.all(sendPromises);\r\n  } catch (err) {\r\n    console.log(err);\r\n    return err;\r\n  }\r\n};\r\n复制代码最终效果\r\n\r\n源代码\r\ngithub.com/binggg/tcb-…\r\n\r\n关于我\r\nbinggg(Booker Zhao) @腾讯\r\n\r\n- 先后就职于迅雷、腾讯等，个人开源项目有 mrn.js 等\r\n- 创办了迅雷内部组件仓库 XNPM ，参与几个迅雷前端开源项目的开发\r\n- 热衷于优化和提效，是一个奉行“懒惰使人进步”的懒人工程师\r\n复制代码\r\n社交资料"}
{"title": "小程序技能进阶回忆录 - globalData 的那些事儿 ", "author": "Rolan", "pub_time": "2019-10-24 00:38", "content": "小程序中，除了每个页面有自己的 data，还有个全局数据存储地方：globalData，获取方式如下：\r\nlet globalData = getApp().globalData\r\n复制代码实际业务代码中总会遇到这种情况：写着写着发现需要用全局数据，但是不能直接就在当前函数里直接写上面的一段代码，因为要和别的函数共用，所以返回 js 文件顶部添加一段代码，再返回刚刚断掉的地方继续写，类似这样：\r\n// 省略12行\r\nlet globalData = getApp().globalData\r\n// 省略15行\r\nPage({\r\n  data: { ... }\r\n  //.. 省略863行\r\n  onButtonTap(e) {\r\n    // ...\r\n    let myData = globalData.myData\r\n    // ...\r\n  }\r\n})\r\n复制代码经过这么一折腾，可能刚刚的代码思路都没了。那能不能直接在想用的函数里直接方便的获取这个 globalData 呢？比如：\r\n// 省略27行\r\nPage({\r\n  data: { ... }\r\n  //.. 省略863行\r\n  onButtonTap(e) {\r\n    // ...\r\n    let myData = this.globalData.myData\r\n    // ...\r\n  }\r\n})\r\n复制代码或者换种方式获取和设置 myData：\r\nlet myData = this.$global('myData')\r\n// ...\r\nthis.$global('myData', 2)\r\n复制代码实现 global 方法\r\nfunction global(name, value) {\r\n  var globalData = getApp().globalData\r\n  var data = {}\r\n  // this.$global()\r\n  if (arguments.length === 0) {\r\n    return globalData\r\n  }\r\n  // this.$global('myData')\r\n  if (arguments.length === 1) {\r\n    if (is.string(name)) {\r\n      return globalData[name]\r\n    }\r\n    // this.$global({\r\n    //   name: 1\r\n    // })\r\n    if (is.object(name)) {\r\n      data = name\r\n    }\r\n  }\r\n  // this.$global('myData', 2)\r\n  if (arguments.length === 2) {\r\n    data[name] = value\r\n  }\r\n  return extend(data, data)\r\n}\r\n复制代码其中，is.string 和 is.object 是类型判断函数。简单实现了多种操作 globalData 的方法，详细见注释。\r\n挂载到 this\r\n函数有了，那么怎么挂在到小程序页面的 this 中呢，看过前几篇可能知道，要对小程序原有的 Page 函数进行改造。\r\n有两种方式，一种是直接添加到 config 里：\r\nvar originPage = Page\r\nvar global = require('../utils/global')\r\n\r\nfunction MyPage(config) {\r\n  // ...\r\n  config.$global = global\r\n  // ...\r\n  originPage(config)\r\n}\r\n\r\nfunction page (config) {\r\n  return new MyPage(config)\r\n}\r\n复制代码或者在代理后的 onLoad 函数里定义：\r\nvar originPage = Page\r\nvar global = require('../utils/global')\r\n\r\nfunction MyPage(config) {\r\n  this.watch = config.watch\r\n  this.lifetimeBackup = {\r\n    onLoad: config.onLoad\r\n  }\r\n  config.onLoad = function(options) {\r\n    this.$global = global\r\n    // 其他代码\r\n    this.lifetimeBackup.onLoad.call(this, options)\r\n  }\r\n  \r\n  // ...\r\n\r\n  originPage(config)\r\n}\r\n复制代码总结\r\n利用这种方式，可以定义很多通用的小程序页面的方法，比如在摩拜小程序内部封装了 this.$util、this.$navigate等适合自身业务的工具方法等。\r\n传送门\r\n\r\n小程序技能进阶回忆录 - 也许你并不需要小程序框架\r\n小程序技能进阶回忆录 - 在缺少组件化的日子里\r\n小程序技能进阶回忆录 - 如何自主实现数据侦听器和计算器\r\n小程序技能进阶回忆录 - 如何自主实现拦截器\r\n小程序技能进阶回忆录 - globalData 的那些事儿\r\n小程序技能进阶回忆录 - 什么时候执行 onLoad（待发布）\r\n小程序技能进阶回忆录 - 增强型的 wx.navigateBack（待发布）\r\n\r\n广告时间\r\n美团单车事业部（摩拜单车）诚招前端 / 小程序研发工程师，位置北京，有兴趣可以发简历到 zhangshibing@mobike.com ）"}
{"title": "微信小程序周边配套的实现 ", "author": "Rolan", "pub_time": "2019-10-24 00:50", "content": "一 需求分析：以该小区为中心，实现周边配套的检索，切换不同种类的检索条件，刷新页面，并以气泡的方式显示出来，效果如下~二 实现方式：底部我是用的vant组件的tabbar来实现切换显示 下载微信小程序JavaScriptSDK 引入SDK，并且实例化API核心类var QQMapWX = require('../../../libs/qqmap-wx-jssdk.js')var app = getApp()// 实例化API核心类var qqmapsdk = new QQMapWX({  key: app.globalData.map_key // 必填});当切换底部标签时，获取要搜索的关键字，调用接口，实现搜索// 事件触发，调用接口  nearby_search: function() {    var _this = this;    // 调用接口    qqmapsdk.search({      keyword: _this.data.kewWord, //搜索关键词      location: {        latitude: _this.data.lat,        longitude: _this.data.lng      }, //设置周边搜索中心点      success: function(res) { //搜索成功后的回调        var mks = []        //在此将小区的位置坐标点加载出来        mks.push({          latitude: _this.data.lat,          longitude: _this.data.lng        })        for (var i = 0; i < res.data.length; i++) {          mks.push({ // 获取返回结果，放到mks数组中            title: res.data[i].title,            id: res.data[i].id,            latitude: res.data[i].location.lat,            longitude: res.data[i].location.lng,            iconPath: _this.data.img, //图标路径            width: 24,            height: 28,            callout : {              color : \"#fff\",              padding : 8,              content: res.data[i].title,              borderRadius : 5,              bgColor: \"#3072f6\",              fontSize : 12            }          })        }        _this.setData({ //设置markers属性，将搜索结果显示在地图中          markers: mks        })      },      fail: function(res) {        console.log(res);      },      complete: function(res) {        console.log(res);      }    });  },到这里基本上就实现了周边配套的需求，现在你需要做的不过是，规整一下整体逻辑和交互，当点击图标会出现气泡框，具体气泡的显示方式参照微信小程序的map组件即可作者：DevinZ"}
{"title": "从 WeRequest 登陆态管理来聊聊业务代码 原 荐 ", "author": "Rolan", "pub_time": "2019-10-30 00:12", "content": "在开发微信小程序之前，个人从来没有接触过开发中涉及到第三方服务器交互的流程。在开发的过程本身倒是没有什么太大的意外，只是在维护服务器登陆状态这一点很讨厌。因为涉及到自身服务器的登录状态以及微信官方服务器登陆状态三方的关系。下图是微信登陆机制:在这种场景下，个人非常关注的点在于: 如何能够无感知的进行登陆(并且无多余请求)。微信的登陆状态倒是还好解决，可以利用 wx.checkSession 来进行判定，但是在与后台服务器交互时候，如果后台交互中返回 HTTP 状态码 401 (未授权)或者其他未登陆指示时候。则需要对其进行额外处理。当时记得为了优雅的解决这个问题，想了很多方案，也与一些伙伴讨论过这个问题。虽然当时的确实现了无感知的登陆，但是要么需要多请求服务器，要么就是代码上实现逻辑过于复杂，代码维护。虽然不满意，但是在当时也没想到什么非常好的解决方法。weRequest 自带状态管理的请求组件后面经过老大的介绍，看到这个组件时，我顿时眼前一亮，这正是我所需要的解决方案,该方案的图示如下:只需要配置一些初始化项目，便可以直接拿去使用了。// 导入\r\nimport weRequest from 'we-request';\r\n\r\nweRequest.init({\r\n    // [可选] 存在localStorage的session名称，且CGI请求的data中会自动带上以此为名称的session值；可不配置，默认为session\r\n    sessionName: \"session\",\r\n    // [可选] 请求URL的固定前缀；可不配置，默认为空\r\n    urlPerfix: \"https://www.example.com/\",\r\n    // [必填] 触发重新登录的条件，res为CGI返回的数据\r\n    loginTrigger: function (res) {\r\n        // 此处例子：当返回数据中的字段errcode等于-1，会自动触发重新登录\r\n        return res.errcode == -1;\r\n    },\r\n    // [必填] 用code换取session的CGI配置\r\n    codeToSession: {\r\n        // [必填] CGI的URL\r\n        url: 'user/login',\r\n        // [可选] 调用改CGI的方法；可不配置，默认为GET\r\n        method: 'GET',\r\n        // [可选] CGI中传参时，存放code的名称，此处例子名称就是code；可不配置，默认值为code\r\n        codeName: 'code',\r\n        // [可选] 登录接口需要的其他参数；可不配置，默认为{}\r\n        data: {},\r\n        // [必填] CGI中返回的session值\r\n        success: function (res) {\r\n            // 此处例子：CGI返回数据中的字段session即为session值\r\n            return res.session;\r\n        }\r\n    },\r\n    // [可选] 登录重试次数，当连续请求登录接口返回失败次数超过这个次数，将不再重试登录；可不配置，默认为重试3次\r\n    reLoginLimit: 2,\r\n    // [必填] 触发请求成功的条件\r\n    successTrigger: function (res) {\r\n        // 此处例子：当返回数据中的字段errcode等于0时，代表请求成功，其他情况都认为业务逻辑失败\r\n        return res.errcode == 0;\r\n    },\r\n    // [可选] 成功之后返回数据；可不配置\r\n    successData: function (res) {\r\n        // 此处例子：返回数据中的字段data为业务接受到的数据\r\n        return res.data;\r\n    },\r\n    // [可选] 当CGI返回错误时，弹框提示的标题文字\r\n    errorTitle: function(res) {\r\n        // 此处例子：当返回数据中的字段errcode等于0x10040730时，错误弹框的标题是“温馨提示”，其他情况下则是“操作失败”\r\n        return res.errcode == 0x10040730 ? '温馨提示' : '操作失败'\r\n    },\r\n    // [可选] 当CGI返回错误时，弹框提示的内容文字\r\n    errorContent: function(res) {\r\n        // 此处例子：返回数据中的字段msg为错误弹框的提示内容文字\r\n        return res.msg ? res.msg : '服务可能存在异常，请稍后重试'\r\n    },\r\n    // [可选] 当出现CGI错误时，统一的回调函数，这里可以做统一的错误上报等处理\r\n    errorCallback: function(obj, res) {\r\n        // do some report\r\n    },\r\n    // [可选] 是否需要调用checkSession，验证小程序的登录态过期，可不配置，默认为false\r\n    doNotCheckSession: true,\r\n    // [可选] 上报耗时的函数，name为上报名称，startTime为接口调用开始时的时间戳，endTime为接口返回时的时间戳\r\n    reportCGI: function(name, startTime, endTime, request) {\r\n        //wx.reportAnalytics(name, {\r\n        //    time: endTime - startTime\r\n        //});\r\n        //request({\r\n        //    url: 'reportCGI',\r\n        //    data: {\r\n        //        name: name,\r\n        //        cost: endTime - startTime\r\n        //    },\r\n        //    fail: function() {\r\n        //\r\n        //    }\r\n        //})\r\n        console.log(name + \":\" + (endTime - startTime));\r\n    },\r\n    // [可选] 提供接口的mock，若不需使用，请设置为false。url为调用weRequest.request()时的url。mock数据的格式与正式接口提供的数据格式一致。\r\n    mockJson: {\r\n        url1: require(\"../../mock1.json\"),\r\n        url2: require(\"../../mock2.json\"),\r\n        url3: require(\"../../mock3.json\")\r\n    }\r\n    // [可选] 所有请求都会自动带上globalData里的参数\r\n    globalData: function() {\r\n        return {\r\n            version: getApp().version\r\n        }\r\n    },\r\n    // [可选] session本地缓存时间(单位为ms)，可不配置，默认不设置本地缓存时间\r\n    sessionExpireTime: 24 * 60 * 60 * 1000,\r\n    // [可选] session本地缓存时间存在Storage中的名字，可不配置，默认为 sessionExpireKey\r\n    sessionExpireKey: \"sessionExpireKey\"\r\n})\r\n\r\nexport default weRequest;使用时候直接拿到 weRequest 既可使用weRequest.request({\r\n    url: 'order/detail',\r\n    data: {\r\n      id: '107B7615E04AE64CFC10'\r\n    }，\r\n    method: 'GET'\r\n}).then((data)=>{\r\n    // 省略...\r\n})代码浅析简单的介绍一下 weRequest 库的实现机制, 在这里代码简化一下,只会说明最主要调用的三个函数。requestHandler.request 管理请求，即每一次请求都要执行该函数sessionManager.main 管理 session 状态。session 的设置与删除，同时也在第一次确认拥有 session 时设置标识符，即只会在第一次缺失登陆态或者错误时候才会执行。responseHandler.response 管理返回数据，对返回数据进行解析，如果没有登陆态，删除 session，重新请求，结合第二个 sessionManager.main 来做。// requestHandler.request 方法\r\nfunction request(obj: IRequestOption): any {\r\n  return new Promise((resolve, reject) => {\r\n    \r\n    // 传入 api 请求对象进行处理\r\n    obj = preDo(obj);\r\n\r\n    // 读取 session, 如果 session 没有问题。成功的话，进行业务请求\r\n    sessionManager.main().then(() => {\r\n        // 进行业务请求\r\n        return doRequest(obj)\r\n    }).then((res) => {\r\n\r\n      // 对 返回的数据进行解析 responseHandler.response 方法\r\n      let response = responseHandler(res as wx.RequestSuccessCallbackResult, obj, 'request');\r\n\r\n      if (response != null) {\r\n        // 返回请求结果\r\n        return resolve(response);\r\n      }\r\n    }).catch((e) => {\r\n        // 异常处理机制\r\n        catchHandler(e, obj, reject)\r\n    })\r\n  })\r\n}\r\n\r\n// sessionManager.main 方法\r\nfunction main() {\r\n    return new Promise((resolve, reject) => {\r\n       \r\n       // 检查登陆态并返回， 如果登陆态过期，直接登陆，登陆成功后返回成功\r\n        return checkLogin().then(() => {\r\n\r\n           // 如果登陆态 ok， 把 config.doNotCheckSession 设置为 true。避免下次再次执行检查\r\n            return config.doNotCheckSession ? Promise.resolve() : checkSession()\r\n        }, ({title, content}) => {\r\n            errorHandler.doError(title, content);\r\n            return reject({title, content});\r\n        }).then(() => {\r\n           // 对checkSession 进行检查操作\r\n            return resolve();\r\n        }, ({title, content})=> {\r\n            errorHandler.doError(title, content);\r\n            return reject({title, content});\r\n        })\r\n    })\r\n}\r\n\r\n// responseHandler.response 方法\r\nfunction response ( res: wx.RequestSuccessCallbackResult,\r\n    obj: IRequestOption,\r\n    method: \"request\") {\r\n\r\n      if (res.statusCode === 200) {\r\n        // ... 省略代码\r\n        \r\n        // 登录态失效，且重试次数不超过配置\r\n        if (config.loginTrigger!(res.data) && \r\n        obj.reLoginCount !== undefined && \r\n        obj.reLoginCount < config.reLoginLimit!) {\r\n     \r\n            // 删除session\r\n            sessionManager.delSession();\r\n\r\n            if (method === \"request\") {\r\n              // 重新请求\r\n                return requestHandler.request(obj as IRequestOption);\r\n            }\r\n        }\r\n      }\r\n\r\n}我们可以利用结合官方网站的图示进行代码分析如果用户从来没有登陆过时，或者 checkSession 过期：request 直接请求需要的 apisessionManager.main 检查登陆态，即 checkSession 是否过期isSessionExpireOrEmpty 如果 session 过期或者为空(当前为空)wx.login -> code2Session 登陆两个服务器成功后，设置标识符 doNotCheckSession 继续 request 请求用户登陆态未过期，再次打开小程序:request 直接请求需要的 apisessionManager.main 检查登陆态，看到 doNotCheckSession继续第一步 request 请求如果是请求成功后的第二次请求，直接会取得内存中的 session,而并非 getStorage，所以不必担心用户某次登陆后端，后端登陆态过期:request 直接请求需要的 apisessionManager.main 检查登陆态，即 checkSession 是否过期isSessionExpireOrEmpty 如果 session 过期或者为空(当前为不为空)成功后，设置标识符 doNotCheckSession 继续 第一步 request 请求后台返回错误码，通过 responseHandler.response 解析。发现错误，删除session,重复请求。提个点，一定要设定 reLoginCount 至少1次，否则该业务无法完成。new Promise 内部封装异步操作之前在写关于异步代码操作时候，通常是基于 axios 直接返回 api 请求响应数据，对其进行正常和错误处理。当时多次异步操作从而返回正确与错误的流程却很少进行梳理。如果在一次请求内有多个异步操作：代码就会变得难以维护。事实上我们可以把 Promise 看成状态机。只有在某些情况下才会返回正确。// 异步操作封装\r\nfunction asyncCompnent(opt: any) {\r\n  return new Promise((resolve, reject) => {\r\n\r\n\r\n    // 传入的 opt 异步操作\r\n\r\n\r\n    // 多个 异步操作， 在最后一个异步操作成功后执行\r\n    reslove(result)\r\n\r\n\r\n    // 多个 异步操作中的 catch， 在每个错误中执行\r\n    reject(error)\r\n  })  \r\n}\r\n\r\n\r\nasyncComponent(data).then(result => {\r\n  // 正常流程\r\n}).catch(error => {\r\n  // 错误流程\r\n})写出如上的代码，就可以在很多业务项内进行操作，诸如某些操作有前置权限请求，或者某些错误代码需要重新请求或者埋点等操作。可能会有人认为，在http 请求框架中都会有 interceptor 拦截器, 完全用不到 new Promise 来判断与操作。但是往往来说，拦截器对于代码是全局的，如果是单单对于某些模块，在拦截器中写大量 if 判断以及业务处理，这绝不是一件好事。因为场景上，业务的易变性使得全局代码被大量修改不利于项目的维护，但是如果该方案使用不当，则又会造成业务代码的可控性降低。当然以上代码也可以使用 async 与 await 来处理，建议多研究一下 async 错误处理，这里推荐两篇关于 async 错误处理的博客(因为个人一直不喜欢 async 函数需要配合回调函数或者 Promise.reject 来处理错误，所以一般来说，我更多用 async 来处理非 api 请求的异步操作，这样的话基本上不太需要处理错误)。如何在Javascript中优雅的使用Async和Await进行错误的处理?从不用 try-catch 实现的 async/await 语法说错误处理之前在阅读 《MobX Quick Start Guide》 时候，我看到一个公式VirtualDOM = fn (props, state)只要输入等同的 属性和状态，得到的一定是 相同的 VirtualDOM 数据。但是我想说的是对于一个业务而言，如果不考虑界面美观性，以及必要的中间状态，我认为符合以下公式:前端业务封装 = 管理 (交互状态， 数据状态， 配置项)其中，结合交互状态和数据状态面向的是最终用户，用户看到怎样的界面取决于前两个。而后一个配置项是面向于开发者，你的代码能究竟支持多少种场景。能够通过配置来减少多少的代码量。难道只要输入等同的交互以及数据就能的到同样的业务吗？当然并非如此，因为对于前端而言，始终有不知道的数据状态。我们只能通过防御式编程与错误处理来搞定不清楚的数据状态(通过增加各种交互状态来解决数据数据状态未知情况)。对于 weRequest 这个库而言，整个 微信的登陆态是保存在 storage 中，整个库都在维护微信的登陆状态(和后台的交互状态并没有保存，只要出现没有权限状态时，就会删除微信登陆状态，重新login)。那么除去代码，整个的交互状态就是被存到内存以及 Storage 中的 session，doNotCheckSession 。数据状态是我们需要请求的api配置以及我们未知的后端状态。session， doNotCheckSession // 可变的交互状态\r\n\r\nweRequest.init({\r\n  // 固定的交互状态(配置项)\r\n  // ...\r\n})     \r\n\r\n{\r\n  url: '../'\r\n} // 数据状态这里也推荐了一篇关于前端 axios 重新请求的方案参考，相比于 weRequest 更加清晰:axios请求超时,设置重新请求的完美解决方法同样对于我们的业务代码而言(组件内部实现)，往往有些数据也是配置项目。如果你对于这三者清楚的了解并且管理的很好，那么写出来的业务代码一定不会差。\"无状态\"的优势在 request 代码中很容易发现，代码能够维护和后端的状态并不是因为持有了后端的 session，而是一种试错机制，只要上一次请求和下一次请求之间的数据没有变过，那么在错误处理中重复请求就没有问题。同时呢，虽然是有 session，doNotCheckSession 这个数据在，但是被移除到非业务中，只作为交互使用。所以我在这里想说的是，思考如何减少中间状态，也就是销毁，新建的模型更简单。在刚开始处理业务代码时候，我总是较多处理 state，总是使用组件的显隐来控制 Dialog，有时候填写 form 表单很麻烦，因为当时组件的一些机制不够完善，在处理完一个form后，reset并不能清除 上一次数据的验证错误，需要多写一部分代码来搞定开发，后来开始转变了，对于大部分场景而言，不如直接销毁，新建，无需管理中间态。其实前端业务中，其实很多这样的例子，处理子组件与父组件的关系，甚至来说架构端，把单页面应用改成基于业务的多页面应用，也是一种销毁，新建的模式。利用浏览器本身的机制去除大部分的中间态。当我们费劲心思去维护一个中间状态的时候，利用各种工具提升性能，不妨多思考以下，去除是否是一种更简单的方案。之所以会有这样的感慨: 是因为在我刚毕业时曾经做过一个需求，里面有 5，6 个复杂的功能点，现在还要增加一个功能点。但是当时完全无法通过增加代码来解决问题，必须把代码拆分重组才可以搞定。遇到这种事情，有小伙伴可能会想，是不是当时的代码写的不好。其实并不是该代码写的不好，而是之前的代码写的相当好，契合的非常好，完全不知道怎么搞定，初出茅庐的我完全无法控制(需要对所有功能点通盘考虑，复杂度很高)，因此，我在这个需求上完全失控了。所以，能契合复杂的代码，考虑到各种可能是能力。能解析复杂的的代码，做一定的牺牲决策，化繁为简，也是一种能力。前者的能力是个人能力的强大，是不可复制和替代的。后者则是让团队实现更加简单，快速的实现各种功能。对于一个成熟的程序员而言，两者的提升都是很重要的。如果对于前端来说，无状态的优势是简单的话，web 后端的无状态的利好就更多了，可以通过外部扩展实现水平扩容，其实质也是把交互状态(用户数据)移除到其他介质上来实现请求可以打到不同的服务器上，而不是单服务器。同时实现了每次请求都是独一无二的，完全不需要考虑中间状态的迁移，有利于开发速度与正确性。weRequest 源码结构解析weRequest 是一个非常小而美的库，代码非常简单干练,我个人非常喜欢他的源码结构，所以列出来:apigetConfig.ts 获取配置信息，把代码中配置的数据导出getSession.ts 获取 sessioninit.ts 初始化设置配置 同时读取 storage 中的 session 与 session 过期时间 放入呢次login.ts 直接调用 sessionManager.main()request.ts 直接调用 requestHandler.request(obj)setSession.ts 直接 setSession(内部接管了，不建议调用，可能是一个用户两个小程序之间的特殊需求)uploadFile.ts 上传文件modulecacheManager.ts api 基于 api 与参数 进行缓存管理，目前没有过期时间，只适合不变化的数据catchHandler.ts 异常处理durationReporter.ts 耗时上报errorHandler.ts 错误处理mockManager.ts mock 假数据接口requestHandler.ts 请求处理，格式化，上传文件等responseHandle.ts 响应处理，从请求等sessinManager.ts session 管理，对于登陆态进行控制，设置与删除storeconfig.ts 默认配置，在 init 时候会使用 Object.assign 来进行默认配置覆盖status.ts session， 在 init 时候会从 storage 中设置typings 小程序的接口 .d.tsutilloading.ts 请求中显示 loading 配置url.ts 根据传入的对象来构造 get 请求urlindex.ts 所有 api 的导出interface.ts weRequest 接口version.ts 版本信息题外话很难有人能一次搞定业务需求,只有在它出现后，才知道什么他是它最需要的。业务代码也一样。同时 weRequest 不是万能的，它符合大众的需求，但不一定符合每个业务的需求。你也可以根据代码改造甚至改进。鼓励一下如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。 博客地址参考weRequest如何在Javascript中优雅的使用Async和Await进行错误的处理?从不用 try-catch 实现的 async/await 语法说错误处理axios请求超时,设置重新请求的完美解决方法"}
{"title": "小程序模块曝光埋点方法 ", "author": "Rolan", "pub_time": "2019-10-30 00:22", "content": "我们在处理模块曝光埋点时，需要根据页面滚动的位置判断模块是否可见（被曝光）。Web 上传统方法是增加页面 scroll 监听事件，根据滚动位置与模块位置进行对比判断，小程序上也可以使用这种方法，但现在有更便捷优雅的替代方案 —— IntersectionObserver 对象。IntersectionObserver 对象IntersectionObserver 对象，用于推断某些节点是否可以被用户看见，下面将介绍相关的 API：(1) 创建通过\tthis.createIntersectionObserver  创建，该方法可传入的参数有三个：thresholds ：数值数组，代表相交比例的阈值（可有多个，取值范围\t[0,1] ），当相交到达该阈值时会触发一次监听回调，在曝光埋点场景下设置为中间位置 \t[0.5] 即可；initialRatio ：初始相交比例，如果方法调用时检测到的相交比例与这个值不相等且达到阈值，则会触发一次监听器的回调函数，在曝光埋点的场景下设置为默认值0即可；observeAll ：是否同时观测多个目标节点；(2) 设置参考区域设置参考区域的方法有两个：\tio.relativeToViewport() 和\tio.relativeTo('selector', { ...margins }) ，如果判断相交参考区域是窗口，则使用前者，曝光埋点的场景下就使用这个；后者可用选择器设置其他节点作为相交的参考区域。(3) 监听开始监听方法：\tio.observe(selector, callback) ，selector代表目标模块的选择器，当它和参考区域相交达到阈值比例时，会触发 callback 回调函数，回调函数接受如下几个参数（在该场景中暂时都不会用到）：intersectionRatio ： 两者相交比例；time ：相交检测时的时间戳；各种边界：intersectionRect ：相交区域的边界；boundingClientRect ：目标边界；relativeRect ：参照区域的边界； (4) 取消监听当页面退出时记得要取消监听：io.disconnect()。监听相交区域类我们可以设计一个类，用来处理监听相交区域的逻辑。构造函数首先来看构造函数，代码如下：class IntersectionObserver {\r\n  constructor(options) {\r\n    this.$options = {\r\n      context: null,\r\n      threshold: 0.5,\r\n      initialRatio: 0,\r\n      observeAll: false,\r\n      selector: null,\r\n      relativeTo: null,\r\n      onEach: res => res.dataset,\r\n      onFinal: () => null,\r\n      delay: 200,    \r\n      ...options,\r\n    }\r\n    this.$observer = null\r\n  }\r\n}复制代码显然，构造函数传入了一些重要的参数，包括\tcreateIntersectionObserver  所需要的三个参数：\tthresholds, initialRatio, observeAll 和上下文\tcontext ；设置参考区域所需的\trelativeTo ；监听方法所需的目标模块选择器\tselector 。最后还有 IntersectionObserver 类监听调用时需要的三个参数：onEach：每一次触发监听调用时，也会调用\tonEach 方法；onFinal：在触发监听调用一段时间\tdelay 后，会调用一次\tonFinal 方法。在模块曝光埋点场景下，如果页面在快速滚动时，每次的监听触发都上报埋点，一时间请求会堆积很多，所以需要\tonFinal 方法，在一段时间后统一上报曝光埋点；delay：调用\tonFinal 方法的间隔时间；监听要想开始监听相交区域，需要先创建监听器，设置完相交区域后再开始监听，关键代码如下：_createObserver() {\r\n  const opt = this.$options\r\n  const observerOptions = {\r\n    thresholds: [opt.threshold],\r\n    observeAll: opt.observeAll,\r\n    initialRatio: opt.initialRatio,\r\n  }\r\n\r\n  // 创建监听器\r\n  const ob = opt.context\r\n    ? opt.context.createIntersectionObserver(observerOptions)\r\n    : wx.createIntersectionObserver(null, observerOptions)\r\n\r\n  // 相交区域设置\r\n  if (opt.relativeTo) ob.relativeTo(opt.relativeTo)\r\n  else ob.relativeToViewport()\r\n\r\n  // 开始监听\r\n  let finalData = []\r\n  let isCollecting = false   \r\n  ob.observe(opt.selector, res => {\r\n    const { intersectionRatio } = res\r\n    const visible = intersectionRatio >= opt.threshold\r\n    if (!visible) return\r\n\r\n    const data = opt.onEach(res)\r\n    finalData.push(data)\r\n\r\n    if (isCollecting) return    // 正在收集监听结果，不会调用 onFinal\r\n    isCollecting = true    \r\n\r\n    // 设置延迟调用 onFinal\r\n    setTimeout(() => {\r\n      opt.onFinal.call(null, finalData)\r\n      finalData = []\r\n      isCollecting = false\r\n    }, opt.delay)\r\n  })\r\n  return ob\r\n}\r\n复制代码对外暴露的公用方法封装对外的\t_createObserver 方法：connect() {\r\n  if (this.$observer) return this\r\n  this.$observer = this._createObserver()\r\n  return this\r\n}\r\n复制代码封装停止监听的方法：disconnect() {\r\n  if (!this.$observer) return\r\n  const ob = this.$observer\r\n  if (ob.$timer) clearTimeout(ob.$timer)\r\n  ob.disconnect()\r\n  this.$observer = null\r\n}\r\n复制代码使用方法import IntersectionObserver from './intersection-observer.js';\r\n\r\nconst ob = new IntersectionObserver({...})\r\nob.connect()复制代码详见代码片段：\tdevelopers.weixin.qq.com/s/lqUakfmM7…总结当然，曝光埋点也可以使用传统 Web 的监听 scroll 事件的方式。不过，既然小程序提供了 IntersectionObserver API 并且几乎所有客户端都已支持，那自然就用这种更方便的方式。另外，在百度小程序和支付宝小程序上也有支持相关的API，跨端开发也不用考虑其他小程序不支持。关于兼容性支付包小程序兼容性有待考证，百度可以使用\tIntersectionObserver ，不过需要注意\tthis.createIntersectionObserver 非组件是没有的，只能使用\tswan.createIntersectionObserver(this)；第二点，\tcreateIntersectionObserver 的参数\tobserveAll 需要改成\tselectAll （百度小程序代码片段：\tswanide://fragment/142c0f60156b1e850dc239553ecffe7b1571810456384 ）。参考文档官方文档 ；谈谈IntersectionObserver懒加载 （Web API 表现形式详解，和小程序上相同）；"}
{"title": "借助云开发实现互动打卡｜实战 ", "author": "Rolan", "pub_time": "2019-10-30 00:32", "content": "个人介绍大家好，我是Zero，一名大四的前端开发爱好者，目前主要研究微信小程序和iOS开发。这是第二次参加微信小程序应用开发赛，2018年我们设计了一款通过二维码寻找丢失物品的小程序《蝴蝶寻物》，获得了华北赛区三等奖。今年，在小程序云开发功能的大力推广下，我决定采用云开发的方式，实现一个双人互动打卡互动的小程序《Mango Daily》(中文名称《芒果日常》)。(由于是个人开发者账号，所以暂时还未上架)得力于云开发提供的API，本项目在较短的时间内就实现了比较理想的效果。接下来，我想从本项目入手，讲讲我是如何依靠 小程序+云开发平台 将想法快速实现的。1. 技术准备在去年的项目中，我们采用ThinkPHP开发了一套API系统，其中需要实现小程序的授权登录，设置鉴权来保证数据安全等操作。整个过程只有我一名开发人员，所以大致就是“先搞定后端，其次搞定界面，最后进行联调”的一个过程。后来在云+社区看到一篇文章： 《1个开发如何撑起一个过亿用户的小程序》 ，觉得可以尝试一下新的开发方式。通读小程序云开发文档之后，发现并不需要学习新的技术就可以快速上手。2. 开发Mango Daily 使用的是小程序原生开发+云开发结合的方式进行开发的。2.1 界面开发界面没有使用第三方UI框架，而是自己将常用的模块封装成了组件。图中比较核心的模块包括 TabBar、Toast、Modal、Nav等。2.2 云开发云开发包括云数据库，云函数和云存储。本项目中三个功能均使用到。2.2.1 云数据库云数据库是一个非关系型数据库，在实际开发中基本符合本项目的需求。部分表关联查询则是通过分步查询的方式代替。云数据库已经实现了自动鉴权，可以保证数据的安全性。目前云数据库只支持以下几种权限：所有用户可读，仅创建者可读写仅创建者可读写所有用户可读所有用户不可读写默认情况下是 仅创建者可读写 ，所以在首次开发时，手动插入的测试数据并不一定可以在前端顺利读取，需要修改集合的权限。云数据库的调用在前端代码中即可完成。但是从上面几种读写权限来看，并没有办法实现对另一个用户创建的数据进行修改或者删除的操作(当然这也是非常不可取的)，于是云函数就派上用场了。2.2.2 云函数我理解的云函数，则是跑在云端的一个函数脚本文件。在接触云开发之前，如果我们想要去调用微信公众平台提供的API(例如发起退款、发送模板消息等)，则需要在后端代码去实现，然后只需要给前端返回一个JSON表示请求状态即可。或者想要去实现上述描述中，修改一条由他人创建的数据的功能时，都是有后端工程师去完成的。在本次开发中，我深刻体会到了云函数的强大，以及微信公众平台工程师设计产品的严谨性。Mango Daily用到了微信公众平台的模板消息功能，所以需要在合适的时机请求微信官方提供的API。因为取消了后端的开发，所以一开始打算直接在小程序端去请求官方API。但是失败了。因为此请求涉及APPKEY等重要信息，禁止在小程序端代码中直接请求官方API。这样就可以通过云函数去代替先前的后端开发，最后将状态返回给小程序端即可。例如想给新用户发送一条短信，以往的做法是客户端请求后端API，然后由后端完成发送短信操作。这里云函数就代替了后端开发。如果仅仅依靠小程序JS代码去发送短信，是非常不可取的。另外，云函数对云数据库有更高的操作权限，所以想要修改、删除他人生成的数据时，云函数可以直接进行操作。云函数还提供定时触发功能，不过在本项目中暂未涉及。2.2.3 云存储本次开发省去了使用其他服务商的存储服务，全部得力于云存储功能。云存储允许上传多种文件类型，像图片、音频等文件还可以直接在小程序端调用。这里我们使用云存储实现了文章插图的功能。2.3 优化2.3.1 数据层封装Mango Daily 数据操作进行了两次封装，一层是对云数据库API进行封装，第二层是每一个数据集合都对应一个Manager管理层。以用户集合 User，Article 为例，项目中的结构如下：util|- db.jsmanager|- Article.js|- User.jsdb.js 是对云数据库API的封装，实现了增删查改等操作，以更新数据为例。/**\r\n * 更新数据\r\n */\r\nconst update = (collection, _id, data) => {\r\n    return new Promise((resolve, reject) => {\r\n        if (!exist(collection)) {\r\n            reject(401, resCode[401]);\r\n        }\r\n    \r\n        db.collection(collection).doc(_id).update({\r\n            data: data\r\n        }).then(res => {\r\n            resolve(res);\r\n        }).catch((code, msg) => {\r\n            reject(code, msg);\r\n        });\r\n    });\r\n}Article.js是文章集合的管理类，同样实现了增删查改等操作，不过其是基于 db.js 进行扩展的。以更新文章操作为例：/**\r\n * 更新\r\n */\r\nconst update = (_id, data) => {\r\n    return new Promise((resolve, reject) => {\r\n        db.update(collection, _id, data).then(res => {\r\n            resolve(res);\r\n        }).catch((code, msg) => {\r\n            reject(db.errMsg);\r\n        });\r\n    });\r\n}之所以封装两层，是想尽量减少Page对象中对云数据库的直接调用。这样在页面js文件中只需要调用某一个Manager提供的函数即可。2.3.3 后台上传策略Mango Daily还实现了发送模板消息的功能，这就涉及到了FromID的收集。目前FromID的收集大部分采用埋点的方式。如果每次采集到新的FromID都直接上传到数据库存储，可能会造成网络资源的浪费，所以需要选择合适的时机上传数据。在本项目中，每次采集到FromID，首先存到 globalData 中，当小程序进入后台状态时，再进行数据的上传。app.js中的实现：/**\r\n* 后台监听\r\n*/\r\nonHide: function() {\r\n    this.uploadFormID();\r\n},\r\n\r\n/**\r\n* 上传token\r\n*/\r\nuploadFormID: function() {\r\n    let ids = this.globalData.formIds;\r\n        \r\n    if (ids.length == 0) {\r\n      return ;\r\n    }\r\n    \r\n    let formId = ids.pop();\r\n    \r\n    this.push.upload(formId).then(_ => {\r\n      console.log(\"上传formID:\" , formId);\r\n      this.uploadFormID();\r\n    }).catch(err => {\r\n      console.log(err);\r\n    });\r\n},3. 维护很遗憾，这一部分可能没有太多需要写的。在18年的项目中，需要考虑数据库的维护问题。但是使用了云开发之后，Serverless的优点就表现出来了。我无须将太多的精力放在后端的维护上。4. 总结在本次项目开发中，我深刻体会到了云开发的便捷性。无须自己实现鉴权，对接第三方存储。数据方面，增删查改功能非常方便。云开发提供的种种便利，让我在有新创意的时候，优先选择小程序+云开发的方式去实现。你好，你的小程序涉及用户自行生成内容的发布/分享/交流，属社交范畴，为个人主体小程序未开放类目，建议申请企业主体小程序另外，Mango Daily中的随笔功能属于用户自行生成内容功能，所以在上架的时候，个人开发者账号是不被允许的，所以在考虑上架产品的时候，请按照实际情况酌情考虑选择账号主体类型。源码地址https://github.com/TencentCloudBase/Good-practice-tutorial-recommended如果你想要了解更多关于云开发CloudBase相关的技术故事/技术实战经验，请扫码关注【腾讯云云开发】公众号～"}
{"title": "小小的支付完成页上，腾讯阿里打起来了 ", "author": "Rolan", "pub_time": "2019-10-31 00:02", "content": "表面看，支付宝似乎在这个页面上和微信越来越趋同，这实属意料之中，商家们津津乐道的一句流传语可以很好地说明问题：“付款的结束，是复购的开始”。作者： Miss豆教授来源：公众号：晓程序观察（ID：yinghoo-tech）支付完成页面，一夜之间成为香饽饽。近日，支付宝开放了「支付后推荐」能力，商家可在用户支付后的成功页添加收藏小程序/关注生活号的组件，并通过小程序收藏有礼/生活号关注有礼引导用户点击。收藏小程序有礼关注生活号有礼用大白话说，就是商家可在用户支付成功页面，通过优惠券，鼓励用户收藏小程序，或者关注生活号。由此一来，支付结果页就成为下一次交易的开始，最终形成“从支付到支付”的正向循环。是不是乍一听，着实有些似曾相识？因为微信很早之前就推出了类似功能，今年4月份微信支付合作伙伴大会上，「支付有礼」能力亮相，商家可以在“支付结果页发券”，最终在用户端的操作场景是，在某商家用微信支付完成支付后，支付结果页面会推荐该商家的优惠券，刺激用户复购。「店外附近发券」能力同时上线，而更早之前，微信支付在完成页上上线了关注服务号、获取立减金能力等。表面看，支付宝似乎在这个页面上和微信越来越趋同，这实属意料之中，商家们津津乐道的一句流传语可以很好地说明问题：“付款的结束，是复购的开始”。但两家平台属性不同，能力开放的程度也不相同，玩法自然也有不同处，所以决定做一次对比PK，帮助大家更好地选择。环节一：入驻门槛（线下、线下、线下！）对于开发者而言，入驻门槛永远是关注的第一要素。毕竟，即便功能被吹得天花乱坠，开发者想入驻却难如登天，久而久之也不会有太多人耐心地不厌其烦一遍又一遍地尝试接入。从微信的「支付有礼」和支付宝的「支付后推荐」能力门槛，也能看出两家想主攻的方向。1. 微信：微信支付商户的专享虽然没有明确规定线下商户才能接入，但从能力的选项可以看出 微信的「支付有礼」主要还是针对线下场景 。来看一段微信的官方介绍：支付有礼是面向符合条件的微信支付商户开放的营销能力，用户在商家使用微信支付后可以领取微信支付代金券，下次回店消费只要符合用券条件即可自动抵扣优惠，能有效帮助商户拉动顾客二次购买或完成线下门店－线上商城的连接。这段话里透露了两个信息：首先，适合有门店的线下商户，其次，想使用该能力就必须成为微信支付的商户。据我们了解， 该能力目前主要是餐饮和零售两个类目使用 。2. 支付宝：门槛太“鸡贼”支付宝对于「支付后推荐」的门槛规定则更为细化：必须是开通当面付功能的商户；7天内交易平均交易笔数大于300笔。这样的门槛透漏了三个信号：首先，由于当面付是针对于支付宝商户的能力，因此只有成为支付宝商户才能使用「支付后推荐」功能，而非小商贩都可以；其次，当面付是针对线下商户的场景能力，因此「支付后推荐」和微信一样，锁定的是线下场景。此外，300笔的周平均交易笔数并不算少，并且当面付很难刷量，有开发者对我们表示：“这是支付宝的鸡贼心理，想用它的能力，就必须得先推荐用户使用支付宝付款，帮它推广，这是支付宝在与相对佛系的微信支付竞争时的一个小伎俩”。截止发稿前，支付宝似乎将门槛下调，周日均300笔的限制要求下降至周均1笔（当面付or小程序支付笔数）。目前，该能力还没有看到类目限制。总的来说，两家的门槛限制都不算太高，都是必须成为两家的商户。另一个值得注意的门槛是，目前这些能力都是免费使用，并且代金券、立减金，都无需商户提前充值，支持免充值使用，商家使用多少代金券充多少即可，这对于商家而言，无疑是大大利好。环节二：留存、复购，哪家强？在支付页面的玩法上，微信起步早于支付宝。早在微信支付诞生不久，就上线了支付完成后一键关注商家服务号的能力。总的来看，在微信的支付完成页面上，目前共有这些工具可以为商家使用：关注服务号、立减金等，再加上今年推出了「支付有礼」、「附近发券」能力。而在支付宝的支付完成页面上，主要工具是生活号、小程序。从工具数量上看，微信支付明显多于支付宝。但工具数量不等于一切，用组合出对用户而言有意思，对商户而言有价值的玩法，才是王道。玩法上两家有什么迥异？1. 线下拉来的新客放到哪里沉淀？无论是微信还是支付宝，由于该能力基本对应线下，因此该页面的拉新基本都来源于线下场景，但将新客放到哪里去沉淀？微信和支付宝的打法有一些差异。微信支付页目前只能将用户留存到服务号上，引导用户一键关注服务号；支付宝则是生活号和小程序都可以沉淀，可以引导用户关注生活号、收藏小程序。值得注意的是， 虽然看上去支付宝给商户提供的服务更多，但关注生活号和收藏小程序，商户只能二选一，即要么使用「收藏有礼」、要么使用「关注有 礼」 。值得注意的是，对于商户而言，这两个“有礼”都要做。有些商家认为，反正在用户端只会显示一个“有礼”，那么在「支付后推荐」上就配置一个功能即可。但事实上，「支付后推荐」能力虽然只在用户侧显示其中一个功能，但是它会判断该用户是否已经关注过生活号或已收藏小程序。假如该用户已经收藏小程序，那么系统则会展示“关注有礼”，反之也一样。只有当用户两项“有礼”都已经领取后，才不会显示“支付后推荐”。2. 线上+线下的复购玩法在复购毫无疑问，对于商家而言，留存的目的就是复购。通过微信的支付完成页，复购有两个办法：线下二次复购： 在支付完成页直接向用户推送优惠券，领券落地页立即使用跳转至扫一扫／付款码，用户在门店核销；线上二次复购： 引导用户关注服务号，用服务号向用户推送优惠券，领券落地页跳转至小程序，用户可一键跳转至小程序核销代金券。值得注意的是，采用这种模式，小程序appid需要跟活动商户号进行绑定。具体使用哪种，由商户自行选择配置。支付宝的办法则更为直接，无论是关注生活号有礼，还是收藏小程序有礼，都是一个路数，用户点击关注或收藏后，弹出代金券。代金券分为两种，线上小程序使用或线下门店使用，具体到底是线上还是线下，由商户自己配置。在领券核销环节，微信是领券即可使用，支付宝则是收藏领券即可使用，对小程序而言，微信比较站在用户侧，支付宝比较在商家侧。对关注公号/生活号而言，微信只是单纯关注，优惠券得等到下一次推文，支付宝则是关注就有券，马上可以用。对比来看，线下复购，微信更为直接，只需一步操作，最大化激活用户立刻复购的可能，而支付宝则更为强调收藏小程序、关注公众号；线上复购，微信的流程多一环，用户关注服务号后，需要商户通过服务号再次触达用户发送优惠券，而支付宝是关注即送，少了后续触达的一步。三、线下微信胜，支付宝“竞争大”？通过以上，可以看到， 支付宝的「支付后推荐」目标鲜明，就是吸引客户进入生活号、小程序，以支付作为切入，为生态内其他工具引流，从而实现留存、复购的价值 。而微信能实现的场景更多，通过服务号+优惠券，可以实现线上留存、复购，而线下发券可以实现线下的立刻复购。在不少人看来， 相比于支付宝，微信还多了即时回馈消费者，聚焦二次消费的属性 。对于开发者和商户而言，巨头生态都至关重要，很少有人会二选一，多数还是会选择双线布局。在他们看来，两家的优点和缺点都很鲜明。微信方面，支付完成页的线下复购刺激非常直接有效。事实上，这种玩法此前就有很多小程序再玩了，多位小程序服务商对我们表示，过去，送给用户的优惠券会直接发送微信卡包，用户到店可以打开卡包进行核销。如若用户是在小程序上完成支付，那么就将优惠券发送到小程序账户里，之后通过模板消息提醒用户消费。现在通过微信支付完成页来刺激，步骤极少，对于复购刺激效率很高。但线上则显得薄弱很多，“如果能从优惠券一键进入小程序，那就非常棒了，不然服务号推送优惠券这个流程，可能会流失不少用户。”不少开发者对我们表示。支付宝的玩法对线上留存异常友好，但也存在一个问题，在支付宝的支付完成页上，福利过多，杂乱使用户体验并不太好：经常在商家的「支付后推荐」优惠券上方，还有口碑券、饿了么券、保险基金、优酷7天会员等阿里系其他App的福利。对于用户而言，选择了这些阿里“官方”福利后，就无法再选择商户的优惠券。“这就是商户和阿里系官方福利竞争，不像微信，页面干干净净的，商户优惠券非常显眼。”有开发者表示。据我们了解，由天猫支付宝联合推出，专为品牌商打造的「品牌轻店」，也将在双十一前接入「支付后推荐」能力，介入后，用户在品牌商的线下门店支付后，可一键收藏「品牌轻店」”程序，进而跳转至天猫品牌旗舰店，将线下流量导到线上，这对同时有线下门店和天猫店铺的品牌商而言，尤为重要。作者： Miss豆教授，公众号：晓程序观察（ID：yinghoo-tech）来源：https://mp.weixin.qq.com/s/SBuyJmVsGqce_ZklH6yrIA本文由 @晓程序观察 授权发布于人人都是产品经理，未经作者许可，禁止转载题图来自Unsplash，基于CC0协议"}
{"title": "介绍一个小程序预处理器 ", "author": "Rolan", "pub_time": "2019-10-31 00:12", "content": "前言\r\n用过原生，用过  wepy，用过 mp-vue，但是都不是非常满意，原生的痛点是文件太多，wepy 和 mp-vue 的问题见 mpvue和wepy问题总结，最后不得不和同事一起做了一个超轻量的小程序单文件解析器 mp-parser，在贴合原生语法的同时解决掉文件太多的痛点。并配套研发了脚手架 mp-parser-cli ，提供了很多通用能力比如字体压缩、代码压缩、通用组件、http & cookie 封装等。\r\n单文件形式\r\nmp-parser 的核心就是单文件解析以及热更新，下面为一个语法示例（demo.vue），标签内的所有语法皆为原生语法。\r\n<!-- config 标签下的内容会被解析到 .json 文件中 -->\r\n<config>\r\n  {\r\n    usingComponents: {}\r\n  }\r\n</config>\r\n\r\n<!-- template 标签下的内容会被解析到 .wxml 文件中 -->\r\n<template>\r\n  <navigation title=\"自定义导航栏\"></navigation>\r\n</template>\r\n\r\n<!-- script 标签下的内容会被解析到 .js 文件中 -->\r\n<script>\r\nPage({})\r\n</script>\r\n\r\n<!-- style 标签下的内容会被解析到 .wxss 文件中，支持 sass 语法 -->\r\n<style lang=\"scss\">\r\n</style>\r\n复制代码通用能力\r\nmp-parser 脚手架提供了非常多的通用能力，详细文档见 github地址。\r\nhttp 请求\r\n将 http 请求 promise 化，简化了请求语法，且会自动携带 cookie\r\nPage({\r\n  onLoad() {\r\n    // get\r\n    this.$http.get('url', {params: ''}).then((res) => {}).catch((err) => {});\r\n\r\n    // post\r\n    this.$http.post('url', {params: ''}).then((res) => {}).catch((err) => {});\r\n  }\r\n})\r\n复制代码通用组件\r\n我们提供了非常多的通用组件，比如常用有\r\n\r\n自定义导航栏 navigation\r\n拖拽卡片 drag-card\r\n倒计时 count-down\r\n省略文本 ellipsis-text\r\n吸底输入框 fixed-inputter\r\n图片裁剪器 image-cropper\r\n范围选择器 range-slider\r\n全屏录像 video-recorder\r\n左滑删除 sideslipping\r\n\r\n通用弹窗\r\nPage({\r\n  onLoad() {\r\n    // { title, needHideLoading }\r\n    this.$showSuccess('操作成功', false);\r\n\r\n    // { title, content, needHideLoading}\r\n    this.$showError('操作失败', '操作失败，请稍后重试', false);\r\n\r\n    this.$showLoading('数据加载中...');\r\n    this.$hideLoading();\r\n  }\r\n})\r\n复制代码字体压缩\r\n字体配置完后执行以下命令，具体配置教程见 字体压缩配置教程\r\nnpm run fontCompression\r\n复制代码安装使用\r\n# 安装脚手架\r\nnpm install -g mp-parser-cli\r\n\r\n# 新建项目\r\nmp-parser-cli-init <project_name>\r\n\r\n# 安装依赖\r\ncd <project_name>\r\nnpm install\r\n\r\n# 运行\r\nnpm run dev\r\n\r\n# 打开开发者工具，选择dist目录，查看效果"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "pub_time": "2016-10-12 22:39", "content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:46", "content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "小程序登录的最优流程 ", "author": "Rolan", "pub_time": "2020-1-13 00:16", "content": "18年中旬做过一个小程序，当时是通过转跳到一个登录页，然后点击调用 wx.getUserInfo ，然后发现这个api被禁用了(虽然依然可以用)，然后用<!-- 需要使用 button 来授权登录 -->\r\n<button wx:if=\"{{canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">授权登录</button>\r\n<view wx:else>请升级微信版本</view>\r\n复制代码因为当时刚好需要用户信息，然后这个api有一个 encryptedData 属性可以获取信息。这样的流程本就可以了，但是意外出现了。思维的禁锢当第二次(2020年)需要开发一个新的小程序，于是也用了老代码， 但是出现了个奇怪的问题。 有兴趣的可以看下面的[奇怪的问题]奇怪的问题：因为微信限制无法转跳到登录页，所以想是否应该在首页设置一个弹窗，点击的时候授权。但是因为考虑到可能会被微信拒绝，故在小程序开发者论坛开了一篇文章app无法转跳到登录页面 and 小程序登录的哲学思考随后发现，登录其实并不需要授权弹窗or页面。（如果服务器不需要保存用户信息)流程下面这个图是小程序官方图 点我转跳代码app.js（小程序的入口文件）的完整代码const loginDataKey = 'loginData'\r\n\r\n//app.js\r\nApp({\r\n  onLaunch: function () {\r\n\r\n    const loginData = wx.getStorageSync(loginDataKey)\r\n    console.log('--loginData--')\r\n    console.log(loginData)\r\n    let toLogin = () => {\r\n      console.log('未登录，去登录..')\r\n      wx.showLoading({title: '登录中', icon: 'loading', mask: true})\r\n      wx.login({\r\n        success(res){\r\n          console.log('wx.login res')\r\n          console.log(res)\r\n          let success = () => {\r\n            console.log('登录成功')\r\n            let loginResponse = {\"openid\":\"ooZAbwpdDdaZV_xiamianshi_mashaike\"}\r\n            wx.setStorageSync(loginDataKey, loginResponse)\r\n            wx.hideLoading()\r\n          }\r\n          let fail = () => {\r\n            wx.hideLoading()\r\n            wx.showToast({\r\n              title: '登录失败，请重新打开小程序试试',\r\n              icon: 'none',\r\n              duration: 1e8\r\n            })\r\n          }\r\n          // TODO 发起网络请求\r\n          // 延时模拟请求登录成功\r\n          setTimeout(success, 500)\r\n        },\r\n        fail(err){\r\n          console.log(err)\r\n          wx.hideLoading()\r\n          wx.showToast({\r\n            title: '登录失败，请重新打开小程序试试',\r\n            icon: 'none',\r\n            duration: 1e8\r\n          })\r\n        }\r\n      })\r\n    }\r\n    // 未登录，去登录\r\n    if(!loginData){\r\n      toLogin()\r\n    // 已登录，但是微信session_key过期\r\n    }else{\r\n      wx.checkSession({\r\n        success () {\r\n          //session_key 未过期，并且在本生命周期一直有效\r\n          console.log('session_key 未过期')\r\n        },\r\n        fail () {\r\n          // session_key 已经失效，需要重新执行登录流程\r\n          console.log('session_key 已经失效，需要重新执行登录流程, 重新登录中')\r\n          toLogin()\r\n        }\r\n      })\r\n    }\r\n\r\n  },\r\n  globalData: {\r\n    userInfo: null\r\n  }\r\n})\r\n复制代码流程如下根据本地储存判断是否登录已登录判断是否失效失效或者未登录去登录登录展示toast拿到信息存储 关闭toast核心wx.login拿到code然后把code通过 auth.code2Session 获取openid和unionid等。这是我通过 auth.code2Session 拿到openid的截图（因为这个是测试号，所以没有unionid）【unionid】是拿来和其他平台打通账号的关键，如果只有一个小程序，都可以不需要这个。效果\r\n\r\n其他\r\n纯展示用户头像昵称等\r\n<open-data type=\"userAvatarUrl\"></open-data>\r\n<open-data type=\"userNickName\"></open-data>\r\n复制代码查看open-data文档\r\n--完--"}
{"title": "微信小程序 动态加载swiper时不显示的问题（爬坑） ", "author": "Rolan", "pub_time": "2020-1-13 00:24", "content": "问题一报错信息TypeError: Cannot read property '$$' of undefined\r\n    at HTMLElement._attached.wx.getPlatform._touchstartHandlerForDevtools解决方法：因为小程序会保留上一次滑动swiper时候的current，所以会出现上次滑动到的current在这次的数据中不存在问题，所以，每次动态加载swiper-item前，需要设置swiper的current属性为0问题二swiper 的current每次设置了0，但是还是不显示 swiper，检查元素是存在的，并且current = -1<swiper current='-1'><swiper>解决方法，动态设置swiper-item的数据时，还需设置current = 0，并且current和swiperList不能在一个this.setData中设置，要先setData swiperList 然后在setData current我是这样写的：this.setData({\r\n  swiperItem: list\r\n},()=>{\r\n  this.setData({\r\n    current: 0\r\n  })\r\n})\r\n//在每次给swiper赋值之后在它的回调中在赋值current之后没有问题成功解决，希望对你有所帮助。"}
{"title": "京东购物小程序cookie方案实践 ", "author": "Rolan", "pub_time": "2020-1-13 00:32", "content": "早期为了解决“会话保持”的需求，社区中出现了「cookie方案」并最终成为W3C标准：当某个网站登录成功后，客户端（浏览器）收到一个cookie标识（文本）并保存下来，在后续请求中会自动带上这个字段，由此Web后台可以判断是否同一个用户，从而使“会话”得以延续。微信小程序没有像浏览器一样内置实现了cookie方案，需要开发者自行模拟，而原先京东购物小程序及京喜小程序（现微信一级购物入口）是从微信及手Q购物H5中迁移迭代出来的，也就是说我们不仅要在小程序中模拟一套cookie方案，并且要保持和原业务对cookie处理逻辑的一致，为此我们将实现方向确定为“基于小程序开放能力，和浏览器保持一致”。微信小程序开放了 数据缓存 Storage 和 网络 Network 这两种能力，通过这两套API，我们可以自行DIY一个cookie方案。PS：本文所有代码及使用示例都可以 在这里 找到，阅读本文时配合实践，效果更佳。二、浏览器中的cookie为了保持后端对cookie的处理逻辑和原来的H5一致，小程序的实现需要往浏览器看齐。所以模拟小程序的cookie前，先看看浏览器的cookie机制，主要有以下几个部分：本地存储：浏览器会在本地分配一块空间，存储cookie请求携带：每次发起请求，都会从本地取出cookie并追加在请求头上响应设置：当响应头有Set-Cookie字段时，需要解析并更新过期时间：每个cookie字段有单独的过期时间，并且到期会自动清除读写操作：暴露API给前端JS调用，可进行增删改查操作作用域：路径path、域名domin编码：cookie值，在网络传输需要encode，建议存储也一样其它：HttpOnly、Secure、SameSite在浏览器的 DevTools 中，可以看到当前站点下的Cookie明细：三、小程序中的cookie实现方案设计在小程序中模拟Cookie，主要涉及五个部分：其中我们会重点关注 「Cookie基础库」 的实现，另外也会给出「Request基础库」的封装示例。本地存储小程序提供了 「数据缓存 Storage API」（可以理解为Web规范中的 LocalStorage ），支持存储“原生类型、Date、及能够通过JSON.stringify序列化的对象”。我们可以利用这些API，在Storage中新开一个 cookies 字段进行存储：// 存：\r\nwx.setStorageSync('cookies', cookies)\r\n// 取：\r\nwx.getStorageSync('cookies')\r\n复制代码其中 cookies 的「存储结构」如下：// cookies = \r\n{\r\n    cookie1: { // “最小cookie单元” ==> cookieItem\r\n        name: 'cookie1', // cookie名\r\n        value: 'xxx',    // cookie值\r\n        expires: 'Fri, 17 Jan 2020 08:49:41 GMT' // 过期时间，使用GMT（格林威治标准时间）格式\r\n    }\r\n},\r\n复制代码上面的 cookie1 便是一个“最小cookie单元 cookieItem ”，包含了3个字段（name、value、expires），是本文中定义的「标准cookie格式」，也是cookie操作的基本单元。打开【微信开发工具】的 Storage 选项卡，可以查看本地存储的情况：读写操作这部分主要作为“公共基础库“的角色，为外部业务提供增删改查cookie的API。1. 获取cookie———— getCookie()步骤：从Storage中取出完整cookies ==> 取出指定name的cookie项 ==> 校验有效期 ==> 返回值value实现如下：function getCookie(name = '') {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let { value, expires } = cookies[name] || {}\r\n\r\n    return (name && expires && !isExpired(expires)) ? decodeURIComponent(cookieItem.value) : ''\r\n}\r\n复制代码2. 设置cookie———— setCookie()步骤：从Storage中取出完整cookies ==> 解析入参 ==> 覆盖更新 ==> 同步到本地Storage首先看下本API设计需求：设置单个/多个cookie直接传值/传cookieItem（Object）时间格式maxAge/expires调用示例如下：setCookie({\r\n    cookie1: 12345,\r\n    cookie2: '12345'\r\n})\r\n\r\nsetCookie({\r\n    cookie1: {\r\n        value: 12345,\r\n        maxAge: 3600 * 24  // 自定义有效期（这里示例是24小时）\r\n    },\r\n    cookie2: {\r\n        value: '12345',\r\n        expires: 'Wed, 21 Oct 2015 07:28:00 GMT' // 标准GMT格式\r\n    }\r\n})\r\n复制代码这里可对入参遍历，而cookie子项无论直接传值value还是传了详细object，都尽量的获取 name/value/expires/maxAge ，传给格式化函数转为标准的 cookieItem ：function setCookie(cookiesParam) {\r\n    let oldCookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let newCookies = {} // 由 cookiesParam 转化为标准格式后的cookies\r\n\r\n    for (let name in cookiesParam) {\r\n        if (isObject(cookiesParam[name])) { // 传入是Object格式\r\n            let { value, expires, maxAge } = cookiesParam[name]\r\n            // 转换为标准cookie格式（cookieItem）\r\n            newCookies[name] = getStandardCookieItem({ name, value, expires, maxAge })\r\n        } else {\r\n            newCookies[name] = getStandardCookieItem({ name, value: cookiesParam[name] })\r\n        }\r\n    }\r\n\r\n    // 同步到本地Storage\r\n    saveCookiesToStorage(Object.assign({}, oldCookies, newCookies))\r\n}\r\n复制代码3. 删除cookie———— removeCookie()步骤：从Storage中取出完整cookies ==> 删除指定的cookie项 ==> 同步到本地Storagefunction removeCookie(cookieName) {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n\r\n    delete cookies[cookieName]\r\n\r\n    saveCookiesToStorage(Object.assign({}, cookies))\r\n}\r\n复制代码四、Cookie 在网络中的传递本节主要简单实现设计图中的【Request基础库】部分如上图所示，Cookie在网络中的传输主要有四个过程：Set-Cookie\r\nCookie\r\nCookie\r\n以下是对一个请求的抓包示例：在小程序中，请求发起有两种方式： HTTP 和 WebSocket ，这里以HTTP为例，先对请求api进行「封装」：function requestPro({ url, data, header, method = 'GET' }) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url,\r\n            data,\r\n            header: Object.assign({}, { 'Cookie': CookieLib.getCookiesStr() }, header), // 请求头————带上Cookie\r\n            success (res) {\r\n              let { data : resData, header, statusCode } = res\r\n              let setCookieStr = header['Set-Cookie'] || header['set-cookie'] || ''\r\n\r\n              CookieLib.setCookieFromHeader(setCookieStr) // 响应头————解析Set-Cookie\r\n              resolve(resData)\r\n            },\r\n            fail (err) {\r\n                reject(err)\r\n            }\r\n          })\r\n    })\r\n}\r\n复制代码如上代码所示，Cookie在前端侧请求模块中的处理主要有3点：1. 请求携带步骤：（每次发请求前）从Storage中取出完整cookies ==> 转化为HTTP规范的请求头Cookie格式 ==> 设置到 Request Header 中上面代码中的 getCookiesStr() 直接取cookies拼接即可，返回示例： cookie1=xxx;cookie2=yyy 。2. 响应设置步骤：（每次收到响应后）解析 Response Header 的 Set-Cookie 字段 ==> 转为标准Cookie格式 ==> setCookie()这里处理 Set-Cookie 内容时，有几个点需要留意： - 最基本的格式： Set-Cookie: <cookie-name>=<cookie-value> - 可能同时包含多个cookie字段，以,分割（但需要排除时间值里的,） - 时间格式：Max-Age/Expires （不区分大小写）具体实现可在文末Demo中找到。3. 编码问题「Cookie值编码方式」是容易产生困惑的地方，目前看到的广泛做法都是使用「URL编码」。但笔者翻阅 RFC6265 发现，原始规范中并没有对编码进行指定，比如在第四章 Server Requirements （服务端）中是这样描述：To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].\r\n“为了最好的兼容效果，服务端应该对cookie值进行编码，例如使用Base64。”而在第五章 User Agent Requirements （客户端，也就是浏览器），则是“建议以第四章服务端的实现为准”。总之规范并没有指定使用「URL编码」，但基于该编码方案已经深入人心，也就顺其自然成了“默认选择”。那这里也不做例外，浏览器怎么做，咋们小程序也保持一致。在浏览器中，推荐cookie值经过 encode 编码后保存下来，所以直接取到的也是 encode 后的值，所以追加在请求头 Cookie 字段，就不需要 decode 解码了，直接拼接即可（但基础库API的get操作最终需要进行 decode 解码）。而对于响应头 Set-Cookie 的值，我们认为后端已经做了 encode 编码，所以前端不需要处理，直接存进 Storage 即可。五、性能优化（高频读写）前面实现中每次读写cookie都会调用小程序Storage API（而且是同步的），小程序框架会读写到本地Storage。 对于高频场景，可以将cookie在内存中维护一份，读写都直接走「内存层」，有更新才同步到「Storage层」。1. 初始化首先需要在内存中声明一个 _COOKIES （命名自行diy），建议在cookie基础库中声明，便于统一维护。2. 读前面初始化时已经从Storage读取一次cookies，后续getCookie就直接读内存的 _COOKIES 即可。3. 写写操作直接更新内存，间接更新Storage。 如果有高频写场景，可以考虑做个任务队列进行节流。六、单元测试微信官方在2019年5月推出了「小程序自动化 SDK」 miniprogram-automator ，经过半年多的迭代，目前已基本稳定下来。在购物小程序场景试用了一下，cookie相关的用例很快就完成了，简直是开发者的福音：真香！！！实际项目中，对cookie的单元测试可以分为两类：小程序全局范围的cookie验证（比如初始化小程序后，有没有种下版本号、访问行为等关键cookie）cookie基础库API验证（比如get/set/remove等各个API是否正常工作）以验证 setCookie() API为例：it('API验证：setCookie()', async () => {\r\n    await miniProgram.evaluate(() => {\r\n        wx.CookieLib.setCookie({ // 调用API\r\n            cookie1: 12345,\r\n        })\r\n    })\r\n\r\n    let { cookies } = await miniProgram.callWxMethod('getStorageSync', 'cookies')\r\n    expect(cookies['cookie1'].value).toBe(12345) // 期望成功设置cookie1为12345\r\n})\r\n复制代码这里为了方便测试用例调用基础库API，在小程序启动前，把Cookie基础库（CookieLib）挂到了 wx 对象上，实现方式是使用node读写文件的API去【植入代码】：fs.appendFileSync('./your_project/app.js', ''\\n wx.CookieUtil = require(\\'./lib/cookie.js\\');\\n'')\r\n复制代码七、Cookie安全Cookie安全是一个比较大的话题，这里只简单列出和小程序相关的几个点。path、domin、HttpOnly、Secure、SameSite小程序中已经做了一些安全措施，比如只能走HTTPS、合法域名需要管理员到微信后台进行配置、Storage只能由写入它的小程序中访问，等等。 因此 path、domin、HttpOnly、Secure、SameSite 这些字段在小程序环境下的价值没有浏览器环境大，本例中没有使用（懒..），而实际业务场景可以按自身情况决定是否要使用。白名单机制前端维护（大小/数量） 通常浏览器保持的Cookie数据不超过4k，部分浏览器限制同一站点最多cookie数为20个。 如果业务庞大的话，建议在Cookie基础库做一套「白名单」机制，在白名单内才可以写入，以此防止“非法写入”或“内容超大导致信息丢失”的问题。后台维护（网关白名单） 同样的，建议从网关层面，建立一个“可信cookie”白名单，自动过滤请求中的“非法cookie”字段。前端防篡改小程序前端更多是防“误改”————即在操作Cookie过程中，发生了意料之外的修改。通常发生在JS“引用拷贝”特性上，比如前面提到的内存维护一个 _Cookies ，如果有一个API getAllCookies() 直接将这份内存版cookies暴露出去，对象引用容易被连带修改。所以cookie基础库需要控制暴露API的能力范围，并对取值进行“深拷贝”。SessionSession机制将用户状态放在了服务端维护，具备更好的安全性，而且目前各种后端对于session的存储和同步都有很成熟的技术方案，有条件的业务应以Session为主做会话保持。指纹上报用户访问时生成设备指纹并上报（通常是登录/结算等环节），业务后台配合风控系统，遇到异常请求时下发验证环节。八、完整小程序实现Demo代码片段： developers.weixin.qq.com/s/x4sFASmh7…九、小结本文先解析了浏览器的 Cookie机制 运作原理，然后使用「数据缓存」和「网络」能力，以 公共基础库 的形式，在小程序中实现了一套 Cookie方案。希望对大家有所帮助。"}
{"title": "迷你PS小程序-集成的开放式画报、油墨电子签名、图片拖拽可单独食用 ... ", "author": "Rolan", "pub_time": "2020-1-13 00:58", "content": "米娜桑，哦哈哟~个人制作，该文章主要讲解最近基于 uni-app 框架编写的集图文拖拽等多方位编辑、油墨电子签名、开放式海报于一体的小程序的制作思路和实现代码。目录1、完整源码链接2、实现思路3、核心代码3-1、图文多方位编辑3-2、油墨电子签名3-3、开放式海报3-4、小结4.效果展示和体验1、完整源码链接：完整代码：https://github.com/TensionMax/mini-ps其中演示的文字编辑、图片编辑、油墨电子签名、开放式海报可单独食用，含文档说明。2、实现思路该工具主要由五个不同组件模块：文字编辑、图片编辑，油墨电子签名、控制、开放式海报1、文字编辑模块设置好的文字参数对象插入到文字队列中。2、图片编辑模块设置好的图片参数对象插入到图片队列中。3、油墨电子签名模块完成绘制后转为利用 canvasToTempFilePath 转成临时图片，获取参数后插入图片队列中，也可以直接导出。4、利用控制模块调整/文字队列和图片队列的参数。5、开放式海报模块，利用控制台的参数将PS画板上的效果绘制到canvas上来实现的效果，接着再利用 canvasToTempFilePath 转成图片导出。3、核心代码3-1、文字/图片编辑模块文字/图片编辑模块主要是实现移动/缩放功能，其他附带的属于甜品，由于两个模块功能类似，该篇仅讲解图片编辑模块。HTML<img\r\n style=\"position: absolute\"\r\n :style=\"{\r\n     left: item.x+'px', \r\n     top: item.y+'px',\r\n     width: item.w+'px',\r\n     height: item.h+'px',\r\n     }\"\r\n  @touchstart='touchStart($event,item,index)' \r\n  @longpress='longPress($event,item,index)'\r\n  @touchmove.stop='touchMove($event,item,index)' \r\n  @touchcancel=\"touchEnd($event,item,index)\" \r\n  @touchend='touchEnd($event,item,index)'\r\n  v-for=\"(item,index) of imagelist\"\r\n  :key=\"index\" \r\n  :src=\"item.src\"\r\n  />在 imageList 的数组标签中，每个绑定的事件中用 $event 来调用事件本身的参数，其中 $event 的 touches 或 changedTouches 包含我们需要的位置参数，示例如下：touches:[{\r\n        clientX: 14 //与显示区域(不含顶部栏)左上角的水平距离\r\n        clientY: 16 //与显示区域(不含顶部栏)左上角的垂直距离\r\n        pageX: 14 //与整个页面(不含顶部栏)左上角的水平距离\r\n        pageY: 16 //与整个页面(不含顶部栏)左上角的垂直距离\r\n        },\r\n        {\r\n        clientX: 14\r\n        clientY: 16\r\n        pageX: 14\r\n        pageY: 16\r\n        }]touches 长度为2代表双指触碰，通过判定双指触摸点的变化方向可实现双指缩放效果。因为每个标签都设置为 style=\"position: absolute\" 所以只需要根据位置参数来更新 x、y、w、h 即可题外话-性能问题一次移动多次操作DOM影响性能—— 虚拟DOM了解一下为何不用事件委派—— 不必要，Vue已经帮我们做了优化，在非常影响性能时再考虑图片编辑Demo3-2、油墨电子签名板由于 touchmove 事件在小程序真机的触发频率和精确度很迷，不太好根据速度来判定绘制的线宽，我只好用其他方式去实现，虽然效果不完美。其实现思路是通过多次的循环绘制以达到油墨效果，每次循环绘制的长度和宽度都不相同。HTML<canvas \r\ncanvas-id=\"canvas\" \r\n@touchstart.stop=\"touchStart\" \r\n@touchmove.stop=\"touchMove\"\r\n@touchend.stop=\"touchEnd\"\r\n>\r\n</canvas>JAVASCRIPTexport default {\r\ndata() {\r\n    return {\r\n        lineWidth0: 5, //初始线宽 建议1~5\r\n        ctx: null,\r\n        x0: 0, //初始横坐标或上一段touchmove事件中触摸点的横坐标\r\n        y0: 0, //初始纵坐标或上一段touchmove事件中触摸点的纵坐标\r\n        t0: 0, //初始时间或上一段touchmove事件发生时间\r\n        v0: 0, //初始速率或touchmove事件间发生速率\r\n        lineWidth: 0, //动态线宽\r\n        keenness: 5, //油墨程度 建议0~5\r\n        k: 0.3, //油墨因子，即每次绘制线条时线宽的变化程度\r\n    }\r\n},\r\nonReady() {\r\n    this.ctx = uni.createCanvasContext('canvas', this);\r\n    this.ctx.setLineCap('round')\r\n},\r\nmethods: {\r\n    //设置初始值\r\n    touchStart(e) {\r\n        this.lineWidth = this.lineWidth0\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = 0\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n    },\r\n\r\n    touchMove(e) {\r\n        let dx = e.touches[0].clientX - this.x0,\r\n            dy = e.touches[0].clientY - this.y0,\r\n            ds = Math.pow(dx * dx + dy * dy, 0.5),\r\n            dt = (new Date().getTime()) - this.t0,\r\n            v1 = ds / dt; //同 this.v0 初始速率或touchmove事件间发生速率\r\n        if (this.keenness === 0) { //油墨为0时\r\n            this.ctx.moveTo(this.x0, this.y0)\r\n            this.ctx.lineTo(this.x0 + dx, this.y0 + dy)\r\n            this.ctx.setLineWidth(this.lineWidth)\r\n            this.ctx.stroke()\r\n            this.ctx.draw(true)\r\n        } else {\r\n            //由于touchMove的触发频率问题，这里采用for循环绘制，原理如图所示\r\n            //这里的k因为\r\n            let a = this.keenness\r\n            if (this.keenness > 5) {\r\n                a = 5\r\n            }\r\n            for (let i = 0; i < a; i++) {\r\n                this.ctx.moveTo(this.x0 + dx * i / a, this.y0 + dy * i / a)\r\n                this.ctx.lineTo(this.x0 + dx * (i + 1) / a, this.y0 + dy * (i + 1) / a)\r\n                //此时touchmove事件间发生与上一个事件的发生的速率比较\r\n                if (v1 < this.v0) {\r\n                    this.lineWidth -= this.k\r\n                    if (this.lineWidth < this.lineWidth * 0.25) this.lineWidth = this.lineWidth * 0.25\r\n                } else {\r\n                    this.lineWidth += this.k\r\n                    if (this.lineWidth > this.lineWidth * 1.5) this.lineWidth = this.lineWidth * 1.5\r\n                }\r\n                this.ctx.setLineWidth(this.lineWidth)\r\n                this.ctx.stroke()\r\n                this.ctx.draw(true)\r\n            }\r\n        }\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = v1\r\n    },\r\n    touchEnd(e) {\r\n        this.x0 = 0\r\n        this.y0 = 0\r\n        this.t0 = 0\r\n        this.v0 = 0\r\n    }\r\n}\r\n}使用的大部分是canvas的基础api，注意绘制单位都为px。油墨电子签名Demo3-3、开放式海报模块如果说微信小程序是银色金滩，那么截至2020年1月6日或者未来，小程序的canvas就是金滩上充斥着未知数个的玻璃块的那一片 ——鲁迅说起小程序canvas，那bug不是一般的多，部分不常见bug我会在代码注释里说明。HTML<canvas canvas-id=\"generate\" :style=\"{ width: canvasW + 'rpx', height: canvasH + 'rpx'}\"></canvas>相关介绍spread 语法async 函数如果图片是网络路径，记得获取临时路径。//别忘了在函数前加 async\r\nlet src = 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg'\r\nsrc = (await uni.getImageInfo({src}))[1].path;JAVASCRIPT输出字段部分//为方便设置，以下除角度外，单位均以rpx为主\r\ndata() {\r\n    return {\r\n        canvasW:720,\r\n        canvasH:1000,\r\n        img:[{\r\n            src: 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg',\r\n            x: 0,\r\n            y: 0,\r\n            w: 100,\r\n            h: 100,\r\n            r: 50,//圆角度\r\n            degrees: 30,//旋转度\r\n            mirror: true//是否镜像\r\n            }],\r\n        text:[{\r\n                content: 'TensionMax',\r\n                x: 50,\r\n                y: 50,\r\n                w: 100,\r\n                lineHeight: 35,//行间距\r\n                color: '#000000',\r\n                size: 28,\r\n                weight: 'normal',//字体粗细\r\n                lineThrough: true,//是否贯穿\r\n            }],\r\n        ctx: null,\r\n        k: null //单位转换因子\r\n    };\r\n}JAVASCRIPTrpx 或 upx与 px 的单位统一转换方法px2rpx() {\r\n    //当转换的参数只有一个时直接返回数值如\r\n    //当不为一个时返回数组，然后用spread语法将其展开为几个参数\r\n    //Math.floor()是为了防止在安卓机上造成的数据紊乱，开发者工具无此bug\r\n    if (arguments.length === 1) return Math.floor(arguments[0] / this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i / this.k))\r\n    }\r\n    return params\r\n},\r\nrpx2px() {\r\n    if (arguments.length === 1) return Math.floor(arguments[0] * this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i * this.k))\r\n    }\r\n    return params\r\n},JAVASCRIPT绘制图片的函数async drawImg() {\r\nthis.ctx.setFillStyle('#FFFFFF')\r\nthis.ctx.fillRect(0, 0, ...this.rpx2px(this.canvasW, this.canvasH)) //绘制背景\r\nfor (let i of this.img) { //for循环绘制图片\r\n    i.src = (await uni.getImageInfo({src: i.src}))[1].path;//获取图片临时路径\r\n    this.ctx.save() //保存当前绘制内容\r\n    if (i.mirror) { //如果设置镜像\r\n        //因为canvas的translate属性是基于原点（初始原点为右上角）变化\r\n        //所以需要先将原点移动至图片中心，变化后再还原\r\n        //旋转变化同理\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.scale(-1, 1)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    if (i.degrees) { //如果设置旋转\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.rotate(i.degrees * Math.PI / 180)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    this.radiusRect(...this.rpx2px(i.x, i.y, i.w, i.h, i.r)) //圆角或矩形路径绘制\r\n    this.ctx.clip() //裁剪\r\n    this.ctx.drawImage(i.src, ...this.rpx2px(i.x, i.y, i.w, i.h))\r\n    this.ctx.restore() //恢复非裁剪区域\r\n}\r\nthis.ctx.draw(true) \r\n}\r\n\r\nradiusRect(x, y, w, h, r) {\r\n    if (r > w / 2 || r > h / 2) {\r\n        r = Math.min(w, h) / 2\r\n    }\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(x, y); // 将操作点移至左上角\r\n    this.ctx.arcTo(x + w, y, x + w, y + r, r); // 画右上角的弧\r\n    this.ctx.lineTo(x + w, y) //可省略，但由于安卓真机的小程序bug，留之，下同。\r\n    this.ctx.arcTo(x + w, y + h, x + w - r, y + h, r); // 画右下角的弧\r\n    this.ctx.lineTo(x + w, y + h) //可省略\r\n    this.ctx.arcTo(x, y + h, x, y + h - r, r); // 画左下角的弧\r\n    this.ctx.lineTo(x, y + h) //可省略\r\n    this.ctx.arcTo(x, y, x + r, y, r); // 画左上角的弧\r\n    this.ctx.lineTo(x, y) //可省略\r\n},绘制自定义文字文字绘制稍微麻烦些，主要是canvas不会自动帮我们换行排版，网上类似的实现方法太多，该篇就不讲，直接放在Demo里面。开放式海报Demo3-4、小结既然我们知道了这几个组件自定义调整参数的方式，那么最后只需要一个父组件作为控制台来调整他们的参数即可，可以通过 props 、 sync 修饰符 等来实现父子通信，当然如果想做更复杂的可以考虑用 Vuex 传参。接下来就可以根据这思路来实现繁琐的业务逻辑了。4、效果展示效果图如下，如果由什么疑问欢迎到下方评论区讨论。"}
{"title": "这些小程序技巧，你敢说你一个用不到？ ", "author": "Rolan", "pub_time": "2019-9-4 14:12", "content": "自己从一手看官方文档到撸过6个小程序，自己填了不少坑，也在微信社区见证了小程序一次次改版\r\n\r\n分享一些之前记录的常用小技巧\r\n个人能力有限，解决小问题，欢迎讨论指正\r\n\r\n\r\n都是小技巧，废话不多说，上代码！\r\n改变小程序原生组件大小\r\n微信官方提供了一些基本组件，但是有的组件没有提供类似size的属性，我们只需要一个css就可以解决,以radio为例：\r\n小程序picker组件的range-key不生效\r\n小程序picker使用过程中发现按官方文档写完，提示列表渲染为[Object Object]，先看文档：\r\n使用场景为如果传入组件是对象数组，你需要设置range-key来设置显示该数组中的哪个value为列表显示内容\r\n\r\n按照官方文档，问题出在range-key的类型，因为在{{}}中使用的都是相应数据，也就导致传入组件的不是一个string值，正确的使用方法为：\r\n为range-key使用一个单引号包起来，或者直接使用nickname，不使用{{}}\r\n小程序修改单页面的背景颜色\r\n设置小程序的页面背景颜色，一开始设置了一个全局的背景颜色，在app.json的widows对象中进行设置\r\n后来在页面中第一反应也是使用单独的json文件设置，\r\n果断发现，没有卵用啊，页面背景还是灰色:\r\n\r\n解决方法，在对应的wxss文件中设置一个page类：\r\n\r\n小程序路由传参，传递对象参数\r\n小程序的传参方式都是通过拼接在url后面进行传参，通常只需要绑定传参id，将id绑定为{{item.id}}，在点击事件里面使用event.currentTarget的方式接受\r\n但当你确实像要传递的参数为对象时，尤其是父子对象， 传输之前可以将对象转为json字符串\r\n但是因为url的长度有限，对象太长，结果发现拼接在URL之后不完整，导致之后解析不出来，\r\n所以路由传参对象时要注意，传参的对象不能太长。\r\n接收方式：\r\n小程序单独设置data中对象的具体属性值\r\n这是一个新手和老手可能都会遇到的问题，因为小程序所有数据要响应，必须使用this.setData()方法，\r\n那现在假设我有这样一个数据：\r\n\r\n我执行只想为addressData的address属性赋一个值该怎么做？\r\n也许你会这样：\r\n\r\nNo，No，你不需要这样，你只需要：\r\n\r\n就这么简单，如果你没用过你一定很兴奋，不要着急我们把问题升级！假设我现在的数据变成了这样：\r\n\r\n我们现在只想把discountList数组中选中对象的click值变为1，怎么办？\r\nNo，No，你会发现这样是不行的，我教你一个简单方法：\r\n但是！每次都要定义变量看起来就躁！所以还要再简单！再简单！\r\n\r\n小程序接口加密时去除昵称数据含有的reshuffle表情（例如emoji）\r\n你有没有遇见过，你要对每个用户的微信昵称就行接口发送给后台，但是他随机的报错了……\r\n我的天，因为每次接口都要经过MD5加密，需要将获取的用户昵称一起加密发送到后台，开始毫无知觉拿过来直接扔进去加密，直到用后台人员的微信测试，中文验签失败，几周前已经调整过中文验签的签名算法，后来发现……\r\n他的微信昵称里有3个“屁”……\r\n具体是什么屁……\r\n你打开你的输入法的emoji你会发现，里面有各种表情，其中就有一个屁……\r\n于是想到的方法，将特殊符号先去除，替换成指定符号，再扔进去加密，上代码：\r\n\r\n至于为什么不是去除特殊表情，一开始第一反应是去除就好了，后来想到万一还有人只用特殊表情做昵称……那存进去的就是空字符串，到时候拿出来显示为空的，视觉不好看。\r\n小程序class中使用三元表达式\r\n代码简单至极，和vue通用\r\n\r\n去除小程序swiper组件的滚动条\r\n小程序自带swiper组件在滚动到时候会用滚动条出现，有时候为了页面的干净，所以……干掉它！\r\n\r\n小程序跳转写绝对路径\r\n忘记为啥用到了，反正最后弄明白了，路径拼接以‘/’开始，你总会用到\r\n\r\n小程序多行文本溢出显示省略号\r\n这个问题，其实问题不大，但是解决了一会，主要原因有2个：\r\n\r\n一开始考虑使用单行超出省略号的方式来做：\r\n\r\n\r\n这是单行文本的方式，一开始想着加固定高度，后来发现设备像素问题，出现有的设备会遮住半行，突然觉得不对，应该不是这样做。\r\n\r\n被设备像素问题误导，去查找是不是不同设备里行高变化了\r\n后来查询到的多行注释文本里，使用伪类太麻烦，于是查到一种样式：\r\n\r\n\r\n这种css只适用于webkit和移动端，于是完美使用在小程序上，但是记得不能设置固定高度！！\r\n小程序页面设置页面高度100%\r\n放代码：\r\n\r\n关键代码是父元素设置position: fixed;height: 100%;width: 100%;\r\n注意了里面的子元素不要再使用fixed，使用absolute基于父元素定位\r\n\r\n小程序点击事件阻止冒泡处理\r\n\r\n这个时候会出现一种情况，当我点击view时，他会跳转到指定页面，当我点击view里面的image时，他会跳转2遍指定页面，第一反应就是当年做的第一个前端项目出现的新的认知，事件冒泡。\r\n解决方法：\r\n\r\n在小程序中事件分为冒泡事件和非冒泡事件：\r\n冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。\r\n非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。\r\n其中有一行字单独说明了：\r\n\r\nbind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。\r\n\r\n小程序map组件不显示坐标，且出现了bing地图的标识\r\nmap地图组件使用:\r\n\r\n使用map的过程中出现一个问题，在onload方法中调用接口，对data中的lng和lat进行赋值，然后发现，map实际显示地图为空，没有坐标，而且下方出现了bing地图的标志，顿时懵逼，难道map组件使用的不是腾讯地图的坐标？是bing地图的坐标？不会这么丧良心吧……\r\n后来研究发现，map组件的组件渲染是优先于接口setData的异步赋值的，导致map的渲染过程中实际上longitude和latitude值都为空，且map只渲染一次。\r\n最后拯救的方法是使用wx:if\r\n\r\n初始化mapOn为false，接口赋值lng和lat之后将mapOn赋值true，渲染map！\r\n小程序按钮点击css效果\r\n小程序自带的button组件是有点击效果的，但是一旦自定义了class你发现 他就是一个方块，点了也是那样静静的呆在那里，没有视觉点击感……往往大多数情况下，我们都要自己定义按钮样式\r\n于是自己写了一套通用的小程序点击按钮效果\r\n\r\n\r\n\r\n终于不再那么死板……\r\n最后\r\n\r\n欢迎讨论指正，欢迎点赞呀~\r\n刚完成的博客：http://118.126.111.172/ ，基于Vue+Egg.js+MySql，欢迎访问~~\r\nGithub源码：github.com/pangxiaolon… ，欢迎给星星~~"}
{"title": "小程序根据referer跳转不同的后台环境 ", "author": "Rolan", "pub_time": "2019-9-12 00:52", "content": "一、问题：开发小程序的时候有4个版本（开发、体验、审核、正式）。所以不同的环境要请求不同的后台。特别是审核版本，因为还要微信审核，如果请求错误，会被审核失败。因为生产环境是对应旧的后台版本，所以审核版本既不能调到后台生产环境，也不能跳到开发环境。我们为了方便生产、审核2个版本小程序都去请求/prod。这里就要区别真实的请求到底是从生产、审核哪里来的。二、解决思路。微信给我们服务器发送请求wx.request的会带上一个referer的header参数。格式如下：https://servicewechat.com/<appId>/<version>/page-frame.html\r\n其中<appId>是发送请求的小程序appId，<version>是小程序的版本。开发、体验、审核 版本中version值是0，开发工具中version值是devtools。正式版的version值是大于0的正整数，表示这个小程序发布到正式版多少次。 例子如下：开发版：\r\nhttps://servicewechat.com/小程序appId/0/page-frame.html\r\n体验版：\r\nhttps://servicewechat.com/小程序appId/0/page-frame.html\r\ndevtools：\r\nhttps://servicewechat.com/小程序appId/devtools/page-frame.html\r\n正式版：\r\nhttps://servicewechat.com/小程序appId/6/page-frame.html\r\n三、解决方式。通过nginx做服务器选择。1、定义一个变量 foo， 配置一个map，把http_referer映射到foo。map $http_referer $foo {\r\n\tdefault   \"prod\";\r\n\t~^https://servicewechat.com/[^/]+/0/(.*)$ \"dev\";\r\n\t~^https://servicewechat.com/[^/]+/devtools/(.*)$ \"dev\";\r\n}\r\n2、配置服务器。upstream dev {\r\n     server localhost:7777;\r\n}\r\nupstream prod {\r\n    server localhost:9999;\r\n}\r\n\r\n3、location 中使用 foo变量， 导航到正确的地址。这里我用add_header把foo变量输出一下，作为测试。        location / {\r\n            #set $foo \"$http_referer\";\r\n            add_header wkfoo 'foo: $foo \"$http_referer\"';\r\n            proxy_pass   http://$foo;\r\n        }\r\n4、测试一下。curl -H 'Cache-Control: no-cache' -I \"https://xxx.xxx.com/prod/xxx?参数1=xxx&参数2=xxx\" --referer \"https://servicewechat.com/xxx/devtools/page-frame.html\"\r\ncurl -H 'Cache-Control: no-cache' -I \"https://xxx.xxx.com/prod/xxx?参数1=xxx&参数2=xxx\" --referer \"https://servicewechat.com/xxx/0/page-frame.html\"\r\n其他。实际上这里小程序请求后台的时候，应该加上一个api的版本号。参考文章：https://developers.weixin.qq.com/community/develop/article/doc/0004e2dffb0f98852cf7183285b013"}
{"title": "在微信小程序里面不使用checkbox怎么实现view的多选 ", "author": "Rolan", "pub_time": "2019-9-24 00:27", "content": "wxml文件<block wx:for=\"{{itemList}}\" wx:key=\"id\">  <view class='item_container' bindtap='itemSelected' data-index='{{index}}'>     <image class='select_icon' src=\"{{item.isSelected?'/image/selected.png':'/image/unselected.png'}}\"></image>     <text class='text'>{{item.name}}</text>  </view></block>wxss文件.item_container {  display: flex;  flex-direction: row;  align-items: center;  padding: 20rpx;} .select_icon {  width: 40rpx;  height: 40rpx;} .text {  margin-left: 30rpx;}js文件data: {    itemList: [      { id: 1, name: 'C语言', isSelected: false, },      { id: 2, name: 'Java', isSelected: false, },      { id: 3, name: 'C++', isSelected: false, },    ]  }, itemSelected: function (e) {    var index = e.currentTarget.dataset.index;    var item = this.data.itemList[index];    item.isSelected = !item.isSelected;    this.setData({      itemList: this.data.itemList,    });  }效果如图"}
{"title": "uni-app开发一个小视频应用(二) ", "author": "Rolan", "pub_time": "2019-10-9 00:32", "content": "一、前情回顾uni-app开发一个小视频应用(一)上篇文章，我们已经实现了首页的头部导航栏组件、底部的tabBar导航栏组件、中间的视频列表组件以及视频列表组件中的视频播放组件，传入视频列表渲染后已经可以上下滑动进行视频切换和播放，接下来我们将完成首页的剩余部分，左侧信息栏组件、右侧图标栏组件，以及完善视频切换动画、播放控制等功能。二、创建左侧信息栏组件左侧的信息栏组件，主要分三块: 作者名、视频标题名、音乐名。这个左侧信息栏信息是和当前播放视频相关联的，所以应该在循环视频列表的时候，将左侧信息栏组件一起渲染出来，所以左侧信息栏组件应该加到<swiper-item>中。// components/list-left.vue<template>\r\n    <view class=\"list-left\">\r\n        <view class=\"author\">\r\n            @祝晓晗\r\n        </view>\r\n        <view class=\"title\">\r\n            妈呀，遇到老同学了，缘分呐! @老丈人说车 @抖音小助手\r\n        </view>\r\n        <view class=\"music-box\"> <!--该music-box主要是为了在music内容滚动的时候在超出music-box范围后能够隐藏超出部分-->\r\n            <view class=\"music\">\r\n                @祝晓晗创作的原声 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  @祝晓晗创作的原声\r\n            </view>\r\n        </view>\r\n    </view>\r\n</template>\r\n<style scoped>\r\n    .list-left{\r\n        width: 70%;\r\n        height: 120px;\r\n        color: white;\r\n    }\r\n    .author {\r\n        height: 35px;\r\n        line-height: 35px;\r\n        font-size: 17px;\r\n    }\r\n    .title {\r\n        width: 100%;\r\n        line-height: 25px;\r\n        font-size: 12px;\r\n        word-wrap: break-word;\r\n        color: #FFFAF0;\r\n    }\r\n    .music-box {\r\n        overflow: hidden; <!--滚动的时候超出部分隐藏-->\r\n        width: 70%;\r\n    }\r\n    .music {\r\n        width: 200%;\r\n        height: 35px;\r\n        line-height: 35px;\r\n        font-size: 12px;\r\n        animation: scroll-x 5s linear 0.2s infinite; <!--应用动画-->\r\n    }\r\n    @keyframes scroll-x{ <!--添加文字水平滚动动画-->\r\n        0% {\r\n            transform: translate3d(80%, 0, 0); <!--80%位置出现，然后向左边滚动-->\r\n        }\r\n        100% {\r\n            transform: translate3d(-80%, 0, 0); <!--动画结束后到达-80%位置-->\r\n        }\r\n    }\r\n</style>\r\n// components/video-list.vue<template>\r\n    <view class=\"video-list\">\r\n        <view class=\"swiper-box\">\r\n            <swiper class=\"swiper\" :vertical=\"true\">\r\n                <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n                    <view class=\"swiper-item\">\r\n                        <video-player                         \r\n                             :video=\"item\"                        \r\n                            :index=\"index\">\r\n                        </video-player>\r\n                    </view>\r\n                    <view class=\"left-box\"> <!--将左侧信息栏组件放到<swiper-item>中同视频一起渲染出来-->\r\n                        <list-left></list-left>\r\n                    </view>\r\n                </swiper-item>\r\n            </swiper>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style>\r\n.left-box { <!--给左侧列表组件添加绝对定位 并设置z-index以显示到视频上方-->\r\n        position: absolute;\r\n        bottom: 50px;\r\n        left: 10px;\r\n        z-index: 20; \r\n}\r\n</style>三、创建右侧图标栏组件右侧图标栏组件，主要分为: 头像图标(头像设置border-radius)、收藏图标(iconfont图标)、评论图标(iconfont图标)、分享图标(iconfont图标)、音乐图标(图片设置border-radius)，右侧图标栏组件设置一个固定宽度，然后让各种图标依次排列即可，如:// components/list-right.vue<template>\r\n    <view class=\"list-right\">\r\n        <view class=\"author-img\">\r\n            <img class=\"img\" src=\"../static/zxh.jpg\"/>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-xin\"></view>\r\n            <view class=\"count\">72.2w</view>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-pinglun1\"></view>\r\n            <view class=\"count\">1.8w</view>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-arrow-\"></view>\r\n            <view class=\"count\">6645</view>\r\n        </view>\r\n        <view class=\"music-img\">\r\n            <img class=\"img\" src=\"../static/music.jpg\"/>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style scoped>\r\n    .list-right {\r\n        width: 60px;\r\n    }\r\n    .author-img {\r\n        width: 60px;\r\n        text-align: center;\r\n    }\r\n    .img {\r\n        width: 50px;\r\n        height: 50px;\r\n        border-radius: 50%;\r\n    }\r\n    .author-img img{\r\n        border: 2px solid #FFFFFF;\r\n    }\r\n    .right-box {\r\n        margin: 20px auto;\r\n        color: white;\r\n        text-align: center;\r\n        font-size: 12px;\r\n    }\r\n    .icon {\r\n        font-size: 40px;\r\n    }\r\n    .music-img {\r\n        width: 60px;\r\n        height: 51px;\r\n        text-align: center;\r\n        margin-top: 20px;\r\n        animation: around 1.5s linear 0.2s infinite; <!--使用动画-->\r\n    }\r\n    @keyframes around { <!--添加360环绕旋转动画-->\r\n        0% {\r\n            transform: rotate(0deg);\r\n        }\r\n        100% {\r\n            transform: rotate(360deg);\r\n        }\r\n    }\r\n</style>四、给右侧图标组件添加上相应的事件当点击头像下部的加号图标，可以对该用户进行关注，即隐藏加号图标，还有就是收藏爱心图标颜色切换，当点击收藏爱心图标，爱心图标变成红色，再次点击收藏爱心图标，爱心图标变回白色，这里先只处理颜色的变化，具体后台交互暂不处理。// 在头像图标下方通过绝对定位添加一个加号图标，并定位到头像底部<view class=\"author-img\">\r\n    <img class=\"img\" src=\"../static/zxh.jpg\"/>\r\n    <view class=\"follow iconfont icon-jiahao\" v-show=\"showFollow\" @click=\"hideFollow\"><!--添加一个加号图标，以及监听hideFollow事件-->\r\n    </view>\r\n</view>\r\n\r\n<view class=\"right-box\">\r\n    <view class=\"icon iconfont icon-xin\" :class=\"{fav: isFav}\" @click=\"changeColor\"></view><!--监听切换收藏爱心图标颜色-->\r\n    <view class=\"count\">72.2w</view>\r\n</view>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                showFollow: true,\r\n                isFav: false\r\n            }\r\n        },\r\n        methods: {\r\n            hideFollow() { // 隐藏关注加号图标\r\n                this.showFollow = false;\r\n            },\r\n            changeColor() {\r\n                this.isFav = !this.isFav; // 切换收藏爱心颜色\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style scoped>\r\n.follow {\r\n        color: white;\r\n        position: absolute;\r\n        width: 18px;\r\n        height: 18px;\r\n        line-height: 18px;\r\n        background: red;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        left: 23px;\r\n        bottom: -5px;\r\n        font-weight: bold;\r\n}\r\n.fav {\r\n        color:red;\r\n}\r\n</style>五、实现滑动播放功能所谓滑动播放，即向上滑动的时候，暂停当前播放视频并且播放下一个视频，向下滑动的时候，暂停当前播放视频，播放上一个视频，而这最关键的就是如何判断是向上滑动还是向下滑动。<swiper>组件给我们提供了一个change事件，我们可以监听这个change事件，拿到滑动完成后滑动到了第几页，即<swiper-item>的序号(从0开始)，然后与滑动前的当前page相比较，就可以知道是向上滑还是向下滑了。判断好了是上滑还是下滑后，我们还需要对上滑和下滑作出正确的处理，我们需要能够拿到每个视频播放组件，然后调用视频播放组件上的相关方法对播放进行控制，这就是涉及到了父组件如何调用子组件上方法，父组件要想调用子组件上的方法，关键是父组件要能够拿到子组件对象，我们可以通过ref实现，因为每一个视频播放组件是video-list视频列表组件的一个子组件，所以我们可以在video-list视频列表组件中给每一个video-player视频播放组件添加上一个ref=\"player\"，即可拿到对应的视频播放组件了。// components/video-list.vue<swiper class=\"swiper\" :vertical=\"true\" @change=\"slider\"> <!--监听change事件-->\r\n    <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n        <view class=\"swiper-item\">\r\n            <video-player\r\n                ref=\"players\" <!--给每一个视频播放组件添加一个ref标识-->\r\n                :video=\"item\"                        \r\n                :index=\"index\">\r\n            </video-player>\r\n        </view>\r\n    </swiper>\r\n</swiper>\r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n            currentPage: 0 // 保存当前page的编号\r\n        }\r\n    },\r\n    methods: {\r\n        slider(e) {\r\n            const targetPage = e.detail.current;\r\n            if (targetPage === this.currentPage + 1) {\r\n                console.log(\"向上滑动\");\r\n                this.$refs.players[this.currentPage + 1].playFromHead(); // 下一个开始播放并且从头开始播放\r\n                this.$refs.players[this.currentPage].pause(); // 当前视频暂停播放\r\n            } else if(targetPage === this.currentPage - 1) {\r\n                console.log(\"向下滑动\");\r\n                this.$refs.players[this.currentPage - 1].playFromHead(); // 上一个开始播放并且从头开始播放\r\n                this.$refs.players[this.currentPage].pause(); // 当前视频暂停播放\r\n            }\r\n                this.currentPage = targetPage;\r\n        }\r\n    }\r\n}\r\n</script>需要注意的是，this.$refs.players返回的是一个数组，即所有播放组件的实例，我们通过不同的索引即可取得对应的视频播放组件，然后进行相应的播放控制了，接下来就是要给每一个视频播放组件添加上播放控制的方法，我们需要给<video>组件添加上一个id，然后通过这个id可以创建出video上下文，即可调用play()、pause()、seek()等相关方法对播放进行控制。// components/video-player.vue<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\"\r\n               id=\"myVideo\" <!--给video组件添加一个id，以便获取到video上下文对象-->\r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\">\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\nexport default {\r\n    onReady() {\r\n            this.videoContext = uni.createVideoContext(\"myVideo\", this); // 获取video上下文对象\r\n    },\r\n    methods: {\r\n        play() {\r\n            this.videoContext.play();\r\n        },\r\n        pause() {\r\n            this.videoContext.pause();\r\n        },\r\n        playFromHead() { // 跳转到开始位置并播放\r\n            this.videoContext.seek(0);\r\n            this.play();\r\n        }\r\n    }\r\n}\r\n</script>六、实现单击播放暂停切换以及双击关注用户功能要想实现单击视频播放组件，视频可以进行播放和暂停切换，那么我们需要给视频播放组件添加一个isPlay属性表示视频是否处于播放中，如果是播放中，那么点击就暂停，如果不是播放中，那么点击就播放，同时，由于uni-app不支持vue的dblclick事件的，所以我们还需要对单击和双击操作进行判断，我们需要定义一个变量用于记录用户点击次数，如果300ms内用户点击次数大于等于2，那么就是双击，否则就是单击，如:<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\"\r\n               id=\"myVideo\"\r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\"\r\n               @click=\"doClick\"><!--添加click事件进行视频播放和暂停的切换-->\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    let timer = null; // 定义一个定时器\r\n    export default {\r\n        data() {\r\n            return {\r\n                isPlay: false, // 当前视频是否在播放中，默认为false\r\n                clickCount: 0 // 记录当前用户点击次数，默认为0\r\n            }\r\n        },\r\n        methods: {\r\n            play() {\r\n                this.videoContext.play();\r\n                this.isPlay = true; // 进入视频播放状态设置isPlay为true\r\n            },\r\n            pause() {\r\n                this.videoContext.pause();\r\n                this.isPlay = false; // 进入视频暂停状态设置isPlay为false\r\n            },\r\n            playFromHead() {\r\n                this.videoContext.seek(0);\r\n                this.play();\r\n            },\r\n            doClick() { // 进行视频播放和暂停的切换\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                }\r\n                this.clickCount++; // 每次单击视频播放组件，点击次数加1\r\n                timer = setTimeout(() => {\r\n                    if (this.clickCount >=2 ) { // 如果300ms内点击次数大于等于2就表示是双击了\r\n                        console.log(\"双击\");\r\n                        this.$emit(\"follow\"); // 双击的话向video-list父组件(视频列表组件)发送一个follow事件\r\n                    } else {\r\n                        console.log(\"单击\");\r\n                        if (this.isPlay) {\r\n                            this.pause();\r\n                        } else {\r\n                            this.play();\r\n                        }\r\n                    }\r\n                    this.clickCount = 0; // 重置点击次数为0\r\n                }, 300);\r\n            }\r\n        }\r\n    }\r\n</script>双击的时候会向video-list父组件(视频列表组件)发送一个follow事件，video-list组件监听到follow事件后再通知<list-right>组件调用其方法让其爱心图标变红即可，如:<template>\r\n    <video-player\r\n        @follow=\"follow\">\r\n    </video-player>\r\n    <view class=\"right-box\">\r\n        <list-right ref=\"listRight\"></list-right> <!--给list-right组件添加ref标识-->\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        follow() {\r\n            this.$refs.listRight[0].follow();\r\n        }\r\n    }\r\n</script>七、实现首个视频自动播放功能之前我们的视频播放组件接收了一个index属性，即当前视频对应的索引号，我们可以通过这个索引号判断当前视频是否是第一个，然后将其video组件的autoPlay设置为true即可自动播放。<template>\r\n    <view class=\"video-player\">\r\n        <vide :autoplay=\"auto> <!--绑定autoplay属性控制是否自动播放-->\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                auto: false // 是否自动播放\r\n            }\r\n        },\r\n        methods: {\r\n            autoPlay() {\r\n                if (this.index === 0) {\r\n                    this.auto = true;\r\n                }\r\n            }\r\n        },\r\n        created() {\r\n            this.autoPlay();\r\n        }\r\n    }\r\n</script>至此，首页已经完成，效果图如下:"}
{"title": "使用 async await 封装微信小程序HTTP请求 ", "author": "Rolan", "pub_time": "2019-10-9 00:55", "content": "1. 编写将普通回调函数形式的方法转换为promise方法的promisic方法 1 // util.js\r\n 2 const promisic = function (func) {\r\n 3     return function (params = {}) {\r\n 4         return new Promise((resolve, reject) => {\r\n 5             const args = Object.assign(params, {\r\n 6                 success: (res) => {\r\n 7                     resolve(res)\r\n 8                 },\r\n 9                 fail: (error) => {\r\n10                     reject(error)\r\n11                 }\r\n12             })\r\n13             func(args)\r\n14         })\r\n15     }\r\n16 }\r\n17 \r\n18 export {\r\n19     promisic\r\n20 } 2. 编写Http类封装HTTP请求 1 // http.js\r\n 2 import { promisic } from \"./util\"\r\n 3 import { config } from \"../config/config\"\r\n 4 \r\n 5 /**\r\n 6  * 使用 async await 封装HTTP请求\r\n 7  */\r\n 8 class Http {\r\n 9 \r\n10     static async request({ url, method='GET', data }) {\r\n11         // 将wx.request方法转换成promise方法\r\n12         const res = await promisic(wx.request)({\r\n13             url: `${config.apiBaseUrl}${url}`,\r\n14             method,\r\n15             data,\r\n16             header: {\r\n17                 appkey: config.appkey\r\n18             }\r\n19         })\r\n20         return res.data\r\n21     }\r\n22 \r\n23 }\r\n24 \r\n25 export {\r\n26     Http\r\n27 } 3. 编写Theme业务类调用封装好的Http请求// theme.js\r\nimport { Http } from \"../utils/http\"\r\n\r\n/**\r\n * 编写主题请求业务类\r\n */\r\nclass Theme {\r\n\r\n    /**\r\n     * 获取首页主题A\r\n     */\r\n    static async getHomeLocationA() {\r\n        return await Http.request({\r\n            url: 'xx/xx/xxx',\r\n            data: {\r\n                names: 't-1'\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n\r\nexport {\r\n    Theme\r\n} 4. 在page中调用Theme业务类获取首页主题A方法 1 // home.js\r\n 2 import { Theme } from '../../model/theme'\r\n 3 \r\n 4 Page({\r\n 5 \r\n 6   data: {\r\n 7     topTheme: {}\r\n 8   },\r\n 9 \r\n10   async onLoad (options) {\r\n11     // 获取首页主题A\r\n12     const data = await Theme.getHomeLocationA()\r\n13     this.setData({\r\n14         topTheme: data[0]\r\n15     })\r\n16   }\r\n17 \r\n18 }) 附上目录结构  这样就可以愉快地使用async await形式的Http请求了，彻底摆脱各种callback方法！"}
{"title": "网易云歌单重合率2.0 ", "author": "Rolan", "pub_time": "2019-10-11 00:31", "content": "前言 \r\n之前写过一个小工具输入网易云音乐上的昵称，即可查看两人喜欢的音乐中，有哪些是相同的，重合率有多少。\r\n感兴趣的可以看这里：\r\n网易云歌单重合率1.0\r\n但是之前的版本存在几个问题：\r\n\r\n速度慢，这个其实是最难受的，平均 20 s以上，因为当时水平有限，使用的selenium相当于模拟了人工搜索，找用户，找歌单，筛选歌曲的过程，会获取很多不必要的信息。速度自然比接口慢很多很多。\r\n体验差，样式也很丑，作为一个小工具，一个链接想再用的时候基本找不到了。\r\n服务经常性不可用。\r\n\r\n但是在我 github 搜网易云的时候发现了一个大佬用 Node.js 写的项目 https://github.com/Binaryify/NeteaseCloudMusicApi  提供了一系列网易云相关的接口，这就很巧了，朋友们，我缺的就是接口啊。（ps:感兴趣的读者可以去 github 上围观这个项目，我只是用了很少的几个接口做成了该工具，事实上，你甚至可以利用其做一个个人风格版的网易云音乐。）\r\n其次前段时间正好买了两本微信小程序的书，而小程序的应用场景之一就是小工具，用完即走。加起来可以完美解决上面三个问题。于是就有了这次的网易云歌单重合率2.0。当然我这个小程序只是练手用，我也没想到如此简陋竟然能通过审核。\r\n使用 \r\n感兴趣可以先直接用微信扫描下方的小程序码体验。\r\n\r\n它用起来大概是这样：\r\n\r\n思路 \r\n代码其实很简单，就不贴了，只说思路。\r\n其实与1.0很相似了，只是以前用PhantomJS和selenium改成用接口获取。\r\n\r\n通过搜索接口传入昵称获取到用户id，\r\n用用户id，拿到喜欢的歌单id，\r\n上传歌单id，获取到歌单详情，即所有的歌曲id。\r\n歌曲id进行比对，重合的歌曲id上传到歌曲详情接口，获取到所有重合歌曲的名字歌手所属专辑等等。\r\n\r\n遇到的问题 \r\n\r\nhttp 转 https \r\n微信的后台只支持 https ,而一般默认https都是用 443 接口，然后 80 端口转到 443 端口，实现 http 转 https 。但是这个项目在服务器用另外一个端口，比如是 5000 ，那么我就必须要申请另外一个端口给这个 5000 用SSL。很麻烦，最简单的方法就是另外用一个二级域名，比如之前是 api.xxx.com 则 这个服务就用node.xxx.com ,然后给 node.xxx.com 申请SSL证书。然后添加反向代理，把 node.xxx.com 转到api.xxx.com:3000 。这样就实现了访问 https://node.xxx.com ,但是实际调用到 http://api.xxx.com:3000 服务。可能有些绕口。\r\n需要注意的是现在免费的话基本只能申请单域名，比如 api.xxx.com ，不能免费申请 *.xxx.com 这种泛域名的证书。至于申请证书后的操作，可自行百度，很多教程，我服务器是腾讯的，通过腾讯云申请后，在宝塔面板添加到SSL>其他证书里的，比较简单快捷。\r\n小程序文本透明度渐显动画\r\n把动画赋值给anim数组元素，然后view绑定这个元素动画。目前是这么实现的，可能存在不合理的地方，欢迎探讨。\r\n//detail.js//获取应用实例const app = getApp()Page({ data: {   anim:[{}], },textShow:function(index){   var animation = wx.createAnimation({     duration: 2000,   });   var key = 'anim[' + index + ']';   animation.opacity(1).step({})   this.setData({     [key] : animation.export(),   }) }, //使用的时候 page.textShow(0); page.textShow(1);})<!--pages/detail/detail.wxml--><view animation=\"{{anim[0]}}\" style=\"opacity:0\" class=\"textViewTitle\">你的昵称:</view><view animation=\"{{anim[1]}}\" style=\"opacity:0\" class=\"textViewTitle\">对方昵称:</view>复制代码\r\n转发功能\r\n一开始上线后，惊人的发现不让转发，一番搜索后才发现，转发分享需要自己实现，并且可以带参。\r\n我实现的效果是在主界面转发只会转发该小程序，不会携带昵称。在结果界面转发会携带昵称，对方点击后直接看结果。\r\n只要重写onShareAppMessage方法即可，path可以携带参数，代码大致如下：\r\n//首页jsonShareAppMessage: function (res) {   if (res.from === 'button') {     // 来自页面内转发按钮     console.log(res.target)   }   return {     title: '网易云歌单重合率',     path: 'pages/index/index',     success: function (res) {       // 转发成功       wx.showToast({         title: '转发成功',         icon: 'none'       })     },     fail: function (res) {       // 转发失败       wx.showToast({         title: '转发失败',         icon: 'none'       })     }   } } //结果js onShareAppMessage: function (res) {   if (res.from === 'button') {     // 来自页面内转发按钮     console.log(res.target)   }   return {     title: '网易云歌单重合率',     path: '/pages/detail/detail?myUserName=' + this.data.myUserName + '&otherName=' + this.data.otherName,     success: function (res) {       // 转发成功       wx.showToast({         title: '转发成功',         icon: 'none'       })     },     fail: function (res) {       // 转发失败       wx.showToast({         title: '转发失败',         icon: 'none'       })     }   } }复制代码\r\n\r\n总结 \r\n总的来说，小程序开发是非常容易上手的，如果有什么想法的话，不一定非要在Android ,IOS上做一个成品app的，我觉得完全可以借鉴现有的平台试水，比如小程序就是一个不错的平台，开发上手很快，审核也很快。完全可以先用小程序看看方案和思路是否可行，之后再决定是否要做成品app。"}
{"title": "iOS程序员上手微信小程序指南：含demo及工具下载 ", "author": "天下雪", "pub_time": "2016-10-14 11:25", "content": "什么是微信小程序工具破解开始教程DEMO展示iOS开发如何应对微信小程序热潮本文主要摘录微信小程序工具破解和第一个Hello World DMEO，其他内容可以从 “阅读原文” 中获取什么是微信小程序及其学习价值微信小程序是一种全新的连接用户与服务的方式，可以在微信内被便捷地获取和传播，同时具有出色的使用体验。在微信的发现Tab中增加一个“小程序”入口，点开之后，会出现自己开启的小程序。来看下小程序提供哪些开发能力？视图容器：视图(View)、滚动视图、Swiper，图标、文本、进度条，按钮、表单等等操作反馈，导航媒体组件：音频、图片、视频，地图位置服务画布，文件操作能力网络：上传下载能力、WebSocket数据：数据缓存能力位置：获取位置、查看位置设备：网络状态、系统信息、重力感应、罗盘界面：设置导航条、导航、动画、绘图等等开放接口：登录，包括签名加密，用户信息、微信支付、模板消息一句话，App能做的事，它都能做，微信是通过weixin jssdk兑现这个承诺的。。小程序的体验和原生 app 几乎没有差异。。。（惊）工具破解开发工具 v0.7百度: https://pan.baidu.com/s/1pLxqFzH （密码: bwt9）360: https://yunpan.cn/ckvTYFHWzYYFV （提取码：e09b）开发工具 v0.9百度: https://pan.baidu.com/s/1pLTKIqJ （密码: iswg）360: https://yunpan.cn/ckvXjEbnFYMSC （提取码：f9ca）Demo源代码百度: https://pan.baidu.com/s/1o8hJFuU （密码: bsky）360: https://yunpan.cn/ckvXAacJjvsgR （提取码：3327）微信小程序开发文档：http://notedown.cn/weixin/api/ Mac测试可用，Windows测试可用下载开发工具，并安装（注意：一定要安装0.9版本）打开『微信Web开发者工具』的程序目录Windows：使用资源管理器查看Mac：右键点击图标，选择『显示包内容』进入程序目录后，替换以下文件（只需要替换0.9版本里的，0.7版本用来登陆）：替换文件下载请戳原文链接enjoy开始运行『微信Web开发者工具』通过微信扫描二维码创建项目AppID：随便填项目名称：随便填本地开发目录：选择一个目录点击「添加项目」此时如果出错，先退出再重进此时，能够看到项目列表了打开项目开始开发enjoyDEMO创建项目打开项目所在目录下载「Demo源代码」并解压覆盖打开项目Good luck"}
{"title": "梁兴臣:微信小程序开发三宗罪和解决方案 ", "author": "天下雪", "pub_time": "2016-10-15 22:33", "content": "在微信公布小程序的文档和开发工具后，脉冲软件在第一时间进行了学习和体验，我们发现微信小程序的技术架构和开发体验让我们非常失望。由于微信小程序的运行环境并不是一个标准的浏览器环境，而且微信的封装工作并不完善，所以我们以往开发中的很多经验并不适用。这并非简单的开发习惯不适应，更重要的是我们的开发流程、规范将不适用。微信小程序开发第一宗罪: 无法调用NPM包虽然微信小程序开发工具打包时实现了require函数加载依赖，但并不是完整的CommonJS依赖管理。因为require函数仅仅能够加载项目中的JS文件，而且必须严格定义JS文件路径，路径不支持CommonJS的路径风格。例如如下加载方式都将出错：require('lodash');require('lodash/map');require('./foo');在微信小程序开发工具中，我们必须对应写为如下格式：require('node_modules/lodash/lodash.js');require('node_modules/lodash/map.js');require('./foo.js');虽然我们可以像上面代码一样加载node_modules目录中的库，但是实际运行时却发生了：在调试工具的Network选项卡中，我们看到运行时加载了1000多个文件，总数据量1.8MB，而我们仅仅是在代码中加载了一个lodash库而已！这是因为微信小程序开发工具会将所有项目下的js文件视为项目文件，并进行打包。而实际开发中，我们需要安装很多的NPM扩展库，而这些扩展库中有大量的不需要打包的文件，例如lodash中有上千文件，而我们只需要用到其中的非常少的一部分。另外，在开发中，我们往往需要安装babal、eslient、webpack、grunt等待开发工具，微信小程序开发工具会一视同仁将这些工具的源码也进行打包......实测开发者工具将崩溃！开发者将崩溃！我崩溃！所以不支持NPM包的原因，是微信开发者工具不支持CommonJS标准，不支持CommonJS标准的原因，是微信开发者工具想当然地认为项目目录下的js文件一定是项目文件，所以只实现了简单的require函数，想当然的原因是。。。微信小程序开发第二宗罪: 无法使用Babel转码无法使用Babel转码的原因其实仍然归结于无法加载NPM库。但是后果将十分严重。因为你将不能再安全使用ES6/7特性，你将无法使用async/await函数，你将和无尽的callback做斗争，你该怎样描述自己？回调地狱中的苦逼程序员？如果你看到这里不明白Babel为何物，那么祝贺你，因为不曾见过天堂就不知何为地狱，你无须为不支持ES6/7而烦恼。但一旦你的大脑支持了ES6/7，用过了Babel，你就回不去了，像我一样，无Babel不编码。微信小程序开发第三宗罪: 无法重用组件其实微信小程序开发是并非完全不能重用组件，比如WXML语法中支持import和 include。但是那仅仅是视图模板可重用，并非组件可重用，因为我们认为组件在应当包含视图和逻辑。WXML其实是基于可重用的组件，但是不允许我们自定义组件。如果你有React经验，你就会明白我的意思。例如，你的小程序是个电商APP，项目中有两个页面中同时包含了商品列表组件，比如某分类下商品列表和搜索结果列表，我们知道这两个列表其实仅仅是参数不同而已。但是在小程序开发中，你只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。我们的实践只吐槽、管杀不管埋是不道德的，既然发现了微信小程序开发中的各种弊端，我们脉冲软件在开发之中总结出了一套流程和工具，专为解决上述三个问题，并免费发布到了开源社区，这就是Labrador。接下来我们一起来尝试一下我们脉冲软件的开发体验。安装Labrador通过命令 npm install -g labrador-cli 全局安装Labrador控制行工具。初始化项目通过如下命令新建一个Labrador项目：mkdir democd demonpm initlabrador init项目初始化完成后，该目录是这个样子的：图中的src是我们的源码目录，node_modules是NPM包目录，dist是目标输出目录。请在开发者工具中新建一个项目，并设置路径到dist目录，请勿设置为demo目录！使用WebStorm或Sublime打开demo目录，开发过程中，我们使用WebStorm或Sublime修改src目录下的源码，请勿直接修改dist目录中的文件，因为dist目录是通过labrador命令生成的。在demo目录中运行 labrador build 命令编译项目，该命令会将src目录下的文件一一处理并生成dist目录下对应的文件。我们也可以运行 labrador watch 命令监控src目录下的文件变化，这样就不用每次修改后手动运行编译命令。加载NPM包我们以lodash包为例，在src/app.js中键入代码 const _ = require('lodash'); 编译后，我们看到dist目录下的文件是这样的：我们看到dist目录下有一个npm/lodash目录，该目录下只有一个lodash.js文件，那么在微信web开发者工具中打包预览，lodash的库将只有这个文件被加载。这一切是怎么发生的？我们看一下dist/app.js的源码，发现源码中const _ = require('lodash'); 被编译为 var _ = require('./npm/lodash/lodash.js'); 然后labrador命令将node_modules/lodash/lodash.js 文件复制到了dist/npm/lodash/lodash.js 。这就是通过labrador可以调用NPM包的原理。重要的是，只有真正用到的js文件才被labrador命令加入到项目目录中。这样一个小小的改进象征着我们的小程序可以便捷调用NPM仓库中海量的扩展库！Babel转码在初始化的示例代码src/app.js中的内容是这样的：图中timer和getUserInfo属性都为async函数，函数体内使用await调用异步操作。labrador 库对微信API进行了封装，使用 const wx = require('labrador'); 覆盖默认的全局变量wx; 封装后的wx对象提供的异步方法返回的都是Promise异步对象，结合async/await函数彻底终结callback，将异步代码同步写，轻松逃离回调地狱！但目前async/await函数是不被浏览器支持的，我们需要使用babel对其转码，labrador编译命令已经内置了babel转码，转码后的代码可以查看dist/app.js，内容过长，不再张贴。重用组件重用组件最需要解决的问题是组件的逻辑代码怎样重用。在实例代码中有一个src/components目录，用来存放项目内的可重用组件，其结构是这样的：子目录src/components/list中存放着一个可重用的组件。list.js / list.less / list.xml 分别对应微信小程序的 js / wxss / wxml 文件。JS为控件的逻辑层，其代码如下：文件导出一个List类，这个组件类拥有像Page一样的生命周期函数onLoad, onReady, onShow, onHide, onUnload 以及setData函数。LESS文件对应微信的WXSS文件，因为微信小程序实现的限制，LESS中无法使用连级选择语法，但是可以定义变量，方便开发。XML文件对应微信的WXML文件，是组件视图描述文件，list.xml内容为：文件中导出一个名为list的template。组件不但可以存放在src/components目录内，还可以单独做成NPM包，这样就可以轻松做到跨项目间的组件共享。组件定义完成后，接下来是在页面中调用，在 src/pages/index/index.js 中有如下代码：代码中首先引入了labrador库替换全局的默认wx对象，并使用labrador.createPage方法代替全局的Page函数声明页面。然后加载List组件类，在页面声明配置中，增加了components属性，并将List组件类实例化传入。labrador.createPage方法是对Page方法的一层封装，目的是在页面初始化时和组件对象进行关联。在 src/pages/index/index.less 中加入代码 @import 'list' 即可调用list组件的样式，如果在src/components/list中找不到list.less，那么编译命令将在NPM包中寻找 node_modules/list/index.less 。在 src/pages/index/index.xml 中加入代码 <component key=\"list\"/> 即可调用list组件的模板文件，component 是Labrador自定义的组件，编译后对应生成 import 和 template。如果在src/components/list中找不到list.xml，那么编译命令将在NPM包中寻找 node_modules/list/index.xml"}
{"title": "微信小程序学习点滴《四》：网络请求 ", "author": "天下雪", "pub_time": "2016-10-17 13:19", "content": "微信小程序开发中网络请求必不可少,今天说说最简单的请求.后续会尝试上传下载,Socket这些.1.一个微信小程序，同时只能有5个网络请求连接。这个规定应该是微信为了保证用户体验制定的,毕竟是小程序.2.wx.request(OBJECT)  参数说明:微信小程序支持GET,POST等请求.用method可以设置.以下是GET请求的代码://rate.js  //获取应用实例  var app = getApp()  Page( {    data: {      code: 'USD',      currencyF_Name: '',      currencyT_Name: '',      currencyF: '',      currencyT: '',      currencyFD: 1,      exchange: 0,      result: 0,      updateTime: '',    },    onLoad: function( options ) {      var that = this;        //获取汇率        wx.request( {          url: \"http://op.juhe.cn/onebox/exchange/currency?key=我的appkey&from=CNY&to=\"+code,          success: function( res ) {            that.setData( {              currencyF_Name: res.data.result[0].currencyF_Name,              currencyT_Name: res.data.result[0].currencyT_Name,              currencyF: res.data.result[0].currencyF,              currencyT: res.data.result[0].currencyT,              currencyFD: res.data.result[0].currencyFD,              exchange: res.data.result[0].exchange,              result: res.data.result[0].result,              updateTime: res.data.result[0].updateTime,            })          }        })    }  })上面代码中只需要给出URL即可,onLoad函数在页面初始化时启动,wx.request({})中success的res.data是从后台获取的数据,这一点需要注意.以下是获取的json数据的格式.json的解析都不需要自己做了.我做Android的时候还得用gson或者是fastjson来解析json.微信为我们解决了很多麻烦.微信小程序开发网络请求文档"}
{"title": "怎么在小程序里添加想要的QQ音乐 ", "author": "天下雪", "pub_time": "2016-10-18 16:28", "content": "在玩Audio组件的时候，想放一首赵雷的《南方姑娘》，可是发现搜到的音乐链接都不是真正的外部链接，而是web播放器的链接，在小程序里根本播放不了。\r\n怎么办呢？他奶奶的。\r\n好在搜了一下怎么获得音乐的外部链接，有位大神给出了结果，而且相当于免费用绿钻了。\r\n好了，话不多说，步入正题。\r\n获取qq音乐外链方法：\r\nMP3接口 ,"}
{"title": "微信小程序开发常见问题分析 ", "author": "天下雪", "pub_time": "2016-10-19 14:43", "content": "距离微信小程序内测版发布已经有十几天的时间了，网上对微信小程序的讨论也异常火爆，从发布到现在微信小程序一直占领着各种技术论坛的头条，当然各种平台也对微信小程序有新闻报道，毕竟腾讯在国内影响力还是很大的。我们都知道微信小程序第一天发布内测版，并没有公开官方开发文档和开发工具，但是这阻止不了技术人的好奇心。因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以立马做了一下小demo，水平有限，所以做的过程也就是一个学习的过程，一个提高的过程。这篇文章主要写我在写demo的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰。一：项目结构微信小程序项目结构主要有四个文件类型,如下WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，js 逻辑处理，网络请求json 小程序设置，如页面注册，页面标题及tabBar。注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。在根目录下用app来命名的这四中类型的文件，就是程序入口文件。app.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。app.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。app.wxss全局配置的样式文件，项目非必须。知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。二：常见问题rpx（responsive pixel）微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。40013错误在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。4058错误微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。Page注册错误这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.Page route错误字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用组件，一种是调 wx.navigateTo。如下代码：wxml文件：搜索js文件事件处理函数：bindtap:function(event){wx.navigateTo({url: “search/search”})}如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码<navigator url=\"search/search\">\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\n</navigator>\r\n这种也是不允许的，也就是说组件内部不能再嵌套组件。它只能是单层存在的。Do not have * handler in current page.大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。bindtap:function(event){\r\n  wx.navigateTo({\r\n    url: \"search/search\"\r\n  })\r\n},\r\ntabBar设置不显示对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种注册页面即将页面写到app.json的pages字段中，如\"pages\":[\r\n   \"pages/message/message\",\r\n   \"pages/contact/contact\",\r\n   \"pages/dynamic/dynamic\",\r\n    \"pages/dynamic/music/music\",\r\n   \"pages/index/index\",\r\n   \"pages/logs/logs\"\r\n ]\r\ntabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。tabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册tabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是”pages”中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。tabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。navigationBarTitle显示问题通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。若你不了解生命周期，可以点击查看Page({data:{// text:”这是一个页面”},onLoad:function(options){// 页面初始化 options为页面跳转所带来的参数  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏\r\nwx.setNavigationBarTitle({\r\n  title: '音乐'\r\n})\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})\r\n通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。{“navigationBarTitleText”: “音乐”}wx.navigateTo无法打开页面一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo本地资源无法通过 css 获取background-image：可以使用网络图片，或者 base64，或者使用标签页面间数据传递微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在”?”后面，多个参数直接用”&”符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。<navigator url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">\r\n         <view class=\"item\" >\r\n            <view class=\"item-left\">\r\n                 <image src=\"{{item.url}}\" class=\"image\"/>\r\n            </view>\r\n            <view class=\"item-middle\">\r\n                 <view>\r\n                      <text class=\"title\">{{item.title}}</text>\r\n                 </view>\r\n                 <view>\r\n                     <text class=\"message\">{{item.message}}</text>\r\n                 </view>\r\n           </view>\r\n           <view class=\"item_right\">\r\n               <view><text class=\"time\">{{item.time}}</text></view>\r\n               <view class=\"mark\" wx:if=\"{{item.count>0}}\"><text class=\"text\">{{item.count}}</text></view>\r\n           </view>\r\n        </view>\r\n        <view  class=\"line\"></view>\r\n      </navigator>\r\n而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下/**  作者：dushao\r\n *   新浪微博：http://weibo.com/dushaoxiaoxiao\r\n *   博客  :    http://www.takozhang.cn\r\n * */\r\n * \r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    isHiddenToast:true\r\n  }\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(options.title)\r\n     console.log(options.message)\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"/pages/message/search/search\"\r\n})\r\n  },\r\n})\r\n这样就实现了页面间数据传递功能。"}
{"title": "秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ... ", "author": "天下雪", "pub_time": "2016-10-21 14:46", "content": "1.下载ThinkPHP 5.0.1：http://www.thinkphp.cn/down/855.html2.安装 解压到站点根目录http://localhost/thinkphp_5.0.1_core/public/访问，可以看到:) ThinkPHP V5 十年磨一剑 - 为API开发设计的高性能框架 [ V5.0 版本由 七牛云 独家赞助发布 ] 新手快速入门完全开发手册说明安装成功。以上url等同于http://localhost/thinkphp_5.0.1_core/public/index.php/index/index/index第一个index是模块名，第二个index是控制器名，第三个index是方法名出处参见config.php Line 60-673.用户登录控制器目标是我们需要一个如下的接口，供我们提交用户信息http://localhost/thinkphp_5.0.1_core/public/index.php/index/user/login参数：openid创建Controller稍加改造输出json格式header(\"Content-type: application/json\");无效！查看文档，需要改配置修改第36行4.用户登录模型5. 配置数据库信息进入database.php6. 建表7. 获取用户输入使用PostMan 测试输出\"灵犀网络\"字样8. 查询是否用户是否已经存在通过openid查询数据库，判断用户是否已经注册如有，返回用户的id,accessToken,username9. 插入新用户创建并返回用户信息10. json输入用户信息，供小程序本地缓存，主要是accessToken配置文件config.php指定了返回类型是json的话，不必通过$user->toArray()，即为纯净的array。而不是如下的对象格式。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "author": "admin", "pub_time": "2016-10-12 22:49", "content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架 ", "author": "admin", "pub_time": "2016-10-12 23:08", "content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置 ", "author": "admin", "pub_time": "2016-10-12 23:22", "content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发 ", "author": "admin", "pub_time": "2016-10-12 23:26", "content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
{"title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "author": "admin", "pub_time": "2016-10-12 23:31", "content": "整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange 事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id 都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id 都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap 点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = e.currentTarget.id //获取到前面唯一的id；If(key){ //用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove 记录到触摸结束的点，如果 X 轴滑动大于 Y 轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X 轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 copy 首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 checked 设置 Boole 开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"}
{"title": "微信小程序试用报告：前端源码逻辑和工作流 ", "author": "天下雪", "pub_time": "2016-10-13 16:49", "content": "文件基本结构：  　  先看入口app.js，app(obj)注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})  　  我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性  　  onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。  　  var logs = wx.getStorageSync('logs') || []获取本地缓存中的logs属性，如果值为空，那么设置logs=[] 与HTML5中的localStorage作用相似logs.unshift(Date.now()) 当前登录时间添加到数组中  　  wx.setStorageSync('logs', logs) 将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据  　  getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数    var that = this    if(this.globalData.userInfo){//用户信息不为空      typeof cb == \"function\" && cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；    }else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {　　　　　　　　 console.log(res)              that.globalData.userInfo = res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口              typeof cb == \"function\" && cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息            }          })        }      })    }  }   　  globalData对象用来存储全局数据，在其他地方调用  　  然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等、  　  最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。 {  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  }}  　  然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。  　  先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。  　  index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。　　<!--index.wxml--><view class=\"container\">//视图容器  <view  bindtap=\"bindViewTap\" class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js page()设置添加    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>  　  index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // 获取入口文件app的应用实例Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //自定义事件处理函数，点击.userinfo的容易触发此函数  bindViewTap: function() {    wx.navigateTo({//全局对象wx的跳转页面方法      url: '../logs/logs'    })  },  onLoad: function () {//发生页面加载时，自动触发该生命周期函数    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据，页面自动渲染      that.setData({        userInfo:userInfo      })    })  }})  　  index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。  　  再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。  　  logs.wxml文件<!--logs.wxml--><view class=\"container log-list\">  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>    <text class=\"log-item\">{{index + 1}}. {{log}}</text>  </block></view>  　　logs.js 文件//logs.jsvar util = require('../../utils/util.js') //util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({  data: {    logs: []  },  onLoad: function () {    this.setData({      logs: (wx.getStorageSync('logs') || []).map(function (log) {//通过wx.getStorageSync获取本地缓存的logs日志数据        return util.formatTime(new Date(log))//日期格式化      })    })  }})　　logs.json文件{    \"navigationBarTitleText\": \"查看启动日志\"   //当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}　　基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"}
{"title": "微信小程序教程：app配置指南 ", "author": "天下雪", "pub_time": "2016-10-13 17:20", "content": "//app.json页面 {//页面注册，有几个页面都要在pages里面注册\"pages\":[\"pages/index/index\",\"pages/logs/logs\",\"pages/main/main\",\"pages/main1/main1\",\"pages/main2/main2\",\"pages/main3/main3\",],//上导航配置及app背景颜色设置\"window\":{//是否开启下拉刷新\"enablePullDownRefresh\":true,//窗口背景颜色，在上拉刷新，下拉刷新，navigate切换页面时可以看见\"backgroundColor\":\"#eee\",//下拉背景字体、loading 图的样式，仅支持 dark/light,（string形式）\"backgroundTextStyle\":\"light\",//上导航条背景颜色\"navigationBarBackgroundColor\": \"orange\",//上导航标题文字\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" //上导航标题字体颜色，仅支持white和black },//底部导航配置\"tabBar\": {\"color\": \"#a9b7b7\",//导航字体默认颜色\"selectedColor\": \"#eb4f38\",//导航字体选中时颜色\"borderStyle\": \"black\", //上border颜色，仅支持 black/white（string形式）\"backgroundColor\": \"rgba(0,0,0,0.4)\",//底部导航背景色\"list\": [ //导航列表2-5个{\"pagePath\": \"pages/index1/index1\", //每个导航的网页对应的路径\"text\": \"首页\", //标题\"iconPath\": \"images/wechat.png\", //默认小图标路径\"selectedIconPath\": \"images/wechatHL.png\" //选中时的小图标路径},{\"pagePath\": \"pages/index2/index2\",\"text\": \"日记\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},{\"pagePath\": \"pages/index3/index3\",\"text\": \"指南\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},]},//网络请求超时时间\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},//是否开启debug模式\"debug\": true}//说明：根据官方文档，上述color和bg-color类型为HexColor即16进制类型，（指定仅支持 black/white，string形式的除外），但实测rbg,rgba和red这些类型目前也支持，但是建议大家还是按文档要求来设置为16进制类型即: #ffffff 类型；////使用时仅需将文件复制下来，根据需求改动即可；////app.json为标准的json文件，所以不能存在有注释，使用的时候需把注释去掉；   //app.js页面App({//当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onLaunch: function () {//onLaunch时调用API从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},//获取用户登录信息getUserInfo:function(cb){var that = thisif(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfotypeof cb == \"function\" && cb(that.globalData.userInfo)}})}})}},//获取后台数据onshow:function(){wx.request({url: 'test.php',data: {x: 'xxx',y: 'yyy'},header: {'Content-Type': 'application/json'},success: function(res) {console.log(res.data)}})},//设置全局数据//本页面通过this.globalData即可取得数据 globalData:{userInfo:null}//其他页面可以通过getApp()获取到小程序实例 //其他页面可以通过getApp().globalData.xxx获取到全局数据})  //app.wxss页面.common {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}//仅支持:类:.commonID:#common标签：common多个标签：common1,common2 伪类::after伪类::before//不支持层级，如.common > view 或者.common view//引入新的单位rpx:rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。及新的rem:rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。//写在app.wxss里面的样式将被设置为公有的，对于其他页面都是可用的"}
{"title": "微信小程序官方文档里看不到的小Tips ", "author": "天下雪", "pub_time": "2016-10-13 17:26", "content": "1. WXML(HTML)　　1.1 小程序的WXML没有HTML的宽容度?那么高，单标签必需是 /> 结尾的。不然会报错。　　1.2 官方推荐使用的基础标签是块标签，给了作为文本标签，但是使用其他标签比如div也是可以使用的，并且都是inline标签。并且wxml的parser会把标签上的不在白名单上的属性都去掉，class, id, data 这些应该都在白名单内，但是href什么的是不会有的，所以如果你用传统的html的标签构建页面理论上也是可行的，不过这些都是inline标签，需要自行设定display。　　1.3 scroll-view 的scroll-top, scroll-left 是可以修改scroll-view的滚动位置的。但是用户自己滚动了之后小程序并不会去改变 scroll-top, scroll-left 的赋值（并不是双向同步的）。如果这时使用setData去修改的话，scroll-top, scroll-left 的赋值和上一次的值相同，小程序是不会运用这个修改的，所以表现就是设置没有生效。这时只能先设置一个其他值，再设置回去（这里还可以体现setData方法是同步的）。scroll-view 获取scroll位置，只能通过bindscroll的回调函数获取，所以需要取scroll位置的请自行预存好。scroll-view 还是有webview的 scroll 的臭毛病，在居顶位置如果第一个动作是向下滚动的，会导致之后手怎么滑都滚不动，设置scroll-top 不为0，设个1就好了。　　1.4 input 目前只支持文字居左，其他都是不行的（模拟器可以）。如果你做表单，建议把input等表单元素都放在form中，from触发submit时会返回内部所有表单元素的name-value。不然只能绑定所有表单元素的 change 事情来获取，甚是麻烦。　　1.5 只有  checkbox-group 有 change 事件，单个的checkbox是没有的，如果你只有一个checkbox， 觉得外面套一个checkbox-group麻烦又不美观的话，可以用 switch type=\"checkbox\" 代替。　　1.6 map 组建目前直接在app第一个页面加载会出现加载失败。需要在onLoad之后再加在。可以先wx:if=\"false\" 然后onLoad的之后改成 true 就行了。　　1.7 map, canvas 像是在webview上面盖一个native组件的感觉。它们是没法被overflow 以及 上面盖元素的，你可以认为z-index写多高都没法在他上面。所以不建议在页面上做弹层和蒙层。canvas 无法放在scroll-view中滚动会定位在初始位置，如果你给canvas设置背景颜色的话，你会发现背景色块跟着滚了，图没滚。2. WXSS(CSS)　　2.1 WXSS 和 CSS很像，基本所有的CSS都支持，小程序还提供了 rpx 这个单位。一屏幕宽是750rpx。推荐使用这个来作为布局。不过有一些细小的差别我下面会列出　　2.2 WXSS不支持 大括号嵌套（{{}} ）。所以key-frames，CSS animation 就不可用了，不过transition 是可用的。　　2.3 目前测试引入字体也是不可用的，前面WXML中提到的内容看SVG也是没法使用的。所以icon目前只能用图的方式做了。　　2.4 WXSS中是不能引入本地资源的, 只能使用线上资源（模拟器是可以，但是别信），可以使用base64。　　2.5 WXSS的 rule 是不支持集联的。所以不能 body .main {background:#000;} 这么写。所以写起来还是比较费劲的。每个class都得很长，不然怕重名。不过支持 li.current {color: red;} 这样的写法，支持after， before伪类，但是不支持 first-child last-child nth-child 这类伪类。　　2.6 app.wxss 和每个 page 的wxss 的覆盖关系是: 如果有同名 rule 的话，page 会覆盖 app 的，不是merge是覆盖。　　3. JS　　3.1 JS 的运行环境和view的运行环境是隔离的。JS只能通过事件获取时机和setData方法修改数据来改变view。　　3.2 JS 目前有个很大的问题是无法获取到页面px级的宽度高度, 所有事件回调的单位都是px级的而不是rpx的，但是又不知道当前rpx，px的转换关系。比如过你用canvas画图。你都不知道边界在哪里，这个很蛋疼。　　3.3 上面有说过 setData方法如果上一个值和下一个值相同时，是不会触发view修改的（见1.3）　　3.4 使用 navigate 跳转的时候可以使用queryString的方式跟在相对地址上，onLoad事件会在入参中传入（会转化成object），但是 navigate back的时候没有一个官方给出的数据通讯机制。可以使用getApp() 获取到全局对象，给上面加点东西，自行实现。navigate 最多5个什么的就不说了。　　3.5 canvas getActions被调用之后，actions是会被清空的。即连续调用两次getActions，第二次是空数组。　　3.6 开发者工具是nw写的，我就看了看裙底的源码，开发者工具中WXML确实是有parser再拼装的过程的。但是并不能说明小工具是native的，从css的支持力度到webview的一些bug相似度来看，我还是觉得像webview，但是组件比如map，canvas什么的用的是原生view，然后盖在webview上的感觉。但是不管怎么说 auto-focus 能自动呼出键盘就已经是个很大的好评了。"}
{"title": "微信小程序开发准备：必修课程推荐 ", "author": "天下雪", "pub_time": "2016-10-13 18:06", "content": "今天，我们都想学前端！！！1、HTML基础入门带你从最最基础的知识开始，认识 HTML，通过 HTML 文件的结构、常用的标签、元素、属性、样式、超文本等内容让大家对 HTML 有一个完整的认识！2、HTML5基础入门HTML5有很多新特性，这个教程就带你入门了解HTML5的一些新特性。我们知道啊：html是结构 （网页一个架子，显示内容）、css是样式（添加背景图片，边框等来修饰）、js是行为（用户操作，华丽的动画）所以呢，光学HTML肯定是不够滴，还需要学习css和js才行啊。3、CSS速成教程这个教程啊，就是带你入门学习CSS知识的，让你对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。4、Javascript基础这个教程呢，是教你学习 JavaScript 的语法及事件、对象、DOM 等基础知识，可以让网页按照你的想法“动”起来。以上呢，是基础，基础打牢了才能动手开发呀，但是，光有理论基础是不够的，还需要在实际开发“小程序”之前，做一些项目，练练手，把所学到的基础知识加以运用！5、HTML5两步实现拼图游戏这个项目就是教你使用HTML5和css3实现的九宫格拼图游戏。做出来是这样的：6、SCSS（SASS）画小黄人这个项目呢，教你通过 SCSS（SASS）画一个会眨眼睛的小黄人，主要学习 CSS3。画出来是这样的：7、JavaScript实现玫瑰花这个项目呢，主要是教你用JavaScript语言实现一朵漂亮的玫瑰花。实现出来是这样的："}
{"title": "微信小程序用户信息解密 C# ", "author": "qq515373375", "pub_time": "2016-10-13 18:24", "content": "背景有幸参加微信小程序的内测，由于公司之前已经有自己的服务大号，积累转化了大量的会员所以在做小程序时，要实现会员的互通，想到的是 unionid 开发文档wx.login(OBJECT)调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=1474887500719wx.getUserInfo(OBJECT)获取用户信息，需要先调用 wx.login 接口其中需要的unionid在调用成功返回的参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html?t=1474887500618是个加密数据，解密算法参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html 实现code 换取 session_key前端先调 wx.login 得到code后端换取session_key和openid， openid返回前端，session_key保存（缓存）解密用注意：一个code只能换取一次；再次调用 wx.login， 会导致上一次的 session_key 失效，解密出来的都是乱码　　2. 解密前端先调 wx.getUserInfo 得到encryptData用login返回的openid，encryptData 调后端解密刚开始按开发文档，用C# 系统自带AES解密失败报“填充无效，无法被移除”异常在网上扒拉了一圈，也没找到有用的信息，最终在github上，找带了参考代码，自己再改改，才解密成功结语代码本身没啥牛逼的，希望贴出来能对后面的开发伙伴有所帮助 :)"}
{"title": "anjular2和微信小程序的对比 ", "author": "qq515373375", "pub_time": "2016-10-13 18:30", "content": "1条件渲染：小程序：用 wx:if=\"{{condition}}\" 来判断是否需要渲染该代码块。<view wx:if=\"{{condition}}\">　　　　True</view>ng2:  用 *ngIf=\"condition\"来判断是否需要渲染该代码块。<p  *ngIf=\"condition\">　　　　condition is true and ngIf is true.</p>对于ng2, 当=号里面的值为真时才渲染标签内的元素，为假时将元素移除。注意：这里是将元素从DOM树里面完全移除，而不是隐藏。 对于需要频繁切换可见性的元素来说，改变元素的display无疑要比频繁的移除和重新渲染高效的多。 不过，angulra2开发者认为，在大多数 UI中，当我们“关闭”一个组件时，在相当长时间内都不大可能想再见到它——可能永远也不见。 而且，当我们隐藏掉一个元素时，组件的行为还在继续——它仍然附加在它所属的 DOM 元素上， 它也仍在监听事件。 Angular 会继续检查哪些能影响数据绑定的变更。 组件原本要做的那些事情仍在继续。 虽然不可见，组件及其各级子组件仍然占用着资源。  虽然每种方法都有各自的优点和缺点，但使用 ngIf 来移除不需要的组件通常都会比隐藏它们更好一些。微信小程序文档较少，不过根据文档中这段话：一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好可以推测wx:if和*ngIf实质是一样的，虽然在写法上有些区别，wx是将条件包裹在{{ condition }}里面。 2 循环列表渲染小程序：列表渲染：默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item<view wx:for=\"{{items}}\">　　{{index}}: {{item}}</view>如某个数组为[a,b,c,d]，则对应的下标index为0,1,2,3，对应的变量名item为a,b,c,d使用wx:for-item可以指定数组当前元素的变量名；使用wx:for-index可以指定数组当前下标的变量名；如： <view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">　　　　  {{idx}}: {{itemName.message}}      </view>则此时下标idx为0,1,2,3, 变量名itemName为a,b,c,dng2:<div *ngFor=\"let hero of heroes; let i=index\">　　　　{{i + 1}} - {{hero.fullName}}</div>ng2里指定变量名用的是let hero of heroes，即设置变量名为hero，对应微信的 wx:for-item=\"itemName；指定下标let  i=index，对应微信的wx:for-index=\"idx\";上面这种写法实际上已经经过语法糖包装后的写法，原来的写法太啰嗦，形似类似： <template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">　　　　<li>...</li></template> 3数据绑定微信：数据绑定使用 Mustache 语法（双大括号）将变量包起来　　　　<view> {{ message }} </view>并在js文件里面设置对应的变量值Page({　　data: {　　　　message: 'Hello MINA!'　　}})微信小程序没有双向数据绑定，要改变变量值时，需要通过setdata改变，监听事件如eventname: function(e) {　　this.setData({　　　　data: \"im_new\"　　})}注意不能这样this.data=\"im_new\"，否则会出错 ng2:ng2:主要看一下双向数据绑定：<input [(ngModel)]=\"currentHero.firstName\">（123）表示绑定事件，[12345]表示绑定数据通过[( )]即可实现双向数据绑定这是种简写的形式，背后是这样写的<input　　　　[ngModel]=\"currentHero.firstName\"　　　　(ngModelChange)=\"currentHero.firstName=$event\">"}
{"title": "微信小程序的数据访问 ", "author": "qq515373375", "pub_time": "2016-10-13 18:34", "content": "先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js , app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的 数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq to sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const API_URL = 'http://localhost:4424/api/'function getApi(url,params){  return new Promise((res,rej)=>{    wx.request({      url:API_URL+'/'+url,      data:Object.assign({},params),      header:{'Content-Type': 'application/json'},      success:res,      fail:rej    })  })}module.exports = {  GetByParams(url,page=1,pageSize=20,search = ''){    const params = { start: (page - 1) * pageSize, pageSize: pageSize }    return getApi(url, search ? Object.assign(params, { q: search }) : params)      .then(res => res.data)  },  GetById(url,id){    return getApi(url, id)      .then(res => res.data)  }}module.exports = {}是固定写法，里面写一个一个的方法，每个方法用,隔开。我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const req = require('../../utils/util.js')Page({  data: {    imgUrls: [],    indicatorDots: true,    autoplay: true,    interval: 2000,    duration: 2000  },  onLoad(){    req.GetByParams('home/homebanner')//看这里   看这里   看这里    .then(d=>this.setData({imgUrls:d,loading:false}))    .catch(e=>{      this.setData({imgUrls:[],loading:false})    })  }})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了"}
{"title": "微信小程序之预览图片 ", "author": "qq515373375", "pub_time": "2016-10-13 18:36", "content": "选择图片时可设置图片是否是原图，图片来源。这用的也挺常见的，比如个人中心中设置头像，可以与wx.upLoadFile()API使用主要方法：wx.chooseImage(object)wxml<button type=\"primary\" bindtap=\"listenerButtonChooseImage\">点击我选择相册button><image src=\"{{source}}\" mode=\"aspecFill\" style=\"width: 640rpx; height: 640rpx\"/>jsPage({  data:{    // text:\"这是一个页面\"    source: ''  },  /**   * 选择相册或者相机 配合上传图片接口用   */  listenerButtonChooseImage: function() {      var that = this;      wx.chooseImage({          count: 1,          //original原图，compressed压缩图          sizeType: ['original'],          //album来源相册 camera相机           sourceType: ['album', 'camera'],          //成功时会回调          success: function(res) {              //重绘视图              that.setData({                  source: res.tempFilePaths              })          }      })  },wx.previewImage(object)这又是一个奇葩API真实搞不懂怎么用这个。先模仿下官方咋使用但是没有效果，搞懂了在补充下自己的使用wxml<button type=\"primary\" bindtap=\"listenerButtonPreviewImage\">展示图片button>jsvar app = getApp()　　Page({　　　　data: {　　　　　　banner:['../images/big.png', '../images/big.png', '../images/big.png'],　　　　　　modalHidden: true　　　　},　　　　tapMove:function(e){　　　　　　this.setData({ 　　　　　　　　num: e.detail.current+1　　　　　　})　　　　},/**  * 预览图片   */ 　　listenerButtonPreviewImage: function() {   　　　　wx.previewImage({     　　　　　　current: '../images/big.png',        　　　　//这根本就不走       　　　　 success: function(res) {          　　　　console.log(res);       　　　　 },        　　　　//也根本不走       　　　　 fail: function() {          　　　　console.log('fail')       　　　　 },　　　　　　complete:function(){　　　　　　　　console.log('complete')　　　　　　}  　　　　　　 }) 　　　　　　},onLoad: function () { var that = this;that.setData({num:1,count:that.data.banner.length})}})"}
{"title": "微信小程序的快速搭建 ", "author": "qq515373375", "pub_time": "2016-10-13 18:37", "content": "「小程序」这个划时代的产品发布快一周了，互联网技术人都在摩拳擦掌，跃跃欲试。可是小程序目前还在内测，首批只发放了\r\n 200 个内测资格（泪流满面）。本以为没有 AppID \r\n这个月就与小程序无缘了，庆幸的是微信这两天发布了正式版开发者工具，无需内测邀请也可以尝鲜了。\r\n因此也就有了我与「小程序」的初体验，而我的感受只有一个字——爽！\r\n选择哪个「小程序」Demo？\r\n在知名同性交友网站 Github 上，「小程序」的 Demo 不少，但是大多只是简单的 API 演示，有的甚至直接把页面数据写在了 \r\njson 文件里（分明有网络请求 API）。我想体验的是能够将服务端和小程序端无缝连接起来（体验够爽）的项目。最终，我选择了腾讯云官方推出的「小相册」项目。\r\n「小相册」主要实现了以下功能：\r\n\r\n列出对象存储 COS 中的图片列表。\r\n\r\n点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 对象存储 COS 中。\r\n\r\n轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片。\r\n\r\n长按任意图片，可将其保存到本地，或从 对象存储 COS 中删除。\r\n\r\n效果演示图（受开发工具的限制，部分功能尚未实现）\r\n\r\n对象存储服务（Cloud Object Service）是腾讯云推出的面向企业和个人开发者提供的高可用，高稳定，强安全的云端存储服务。可以将任意数量和形式的非结构化数据放入COS，并在其中实现数据的管理和处理。\r\n\r\n之所以选择腾讯云的 Demo，一是因为它是腾讯自家推出的，项目的质量有保障；二是因为它是少有的既讲小程序开发，又介绍云端部署的项目。\r\n稍微有点经验的程序员都知道，架构要动静分离，静态文件最好不要放在自己的服务器上，要放在专门用来存储的对象存储服务器COS上，并且用CDN 加速。「小相册」后端采用的是 Node.js，Nginx作为反向代理。\r\n第一步：搭开发环境\r\n首先，我们需要在本地搭建好微信「小程序」的开发环境。即下载开发者工具。微信官方已经推出了正式版 IDE，大家没有必要再去下载破解版了。打开官网下载页面，根据自己的操作系统选择。我使用的是 Mac 版。\r\n安装好之后打开运行，会要求微信扫码登陆。之后，就可以看到创建项目的页面了。\r\n\r\n选择添加项目，没有 AppID 就选无（如果乱写会报错，到时可能无法进入项目）。如果你选择的项目目录为空，请如图所示勾选在“当前目录中创建quick start项目”。\r\n\r\n点击“添加项目”之后，我们会进入开发工具的调试页面。\r\n第二步：下载「小相册」源码\r\n接下来，我们下载「小相册」的源码。可以选择直接从腾讯云官网提供的链接下载，也可以从腾讯云团队的 Github 仓库拉取。我推荐从 Github 仓库拉取，这样可以及时获取最新的代码。\r\ngit clone https://github.com/CFETeam/weapp-demo-album.git\r\n最终，我们会得到类似这样的文件目录。\r\n\r\n简单解释下目录结构：\r\n\r\napplet（或app）: 「小相册」应用包代码，可直接在微信开发者工具中作为项目打开。\r\n\r\nserver: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI 接口示例，用于拉取图片资源、上传图片、删除图片。\r\n\r\nassets：「小相册」的演示截图。\r\n\r\n源码下载完成之后，我们打开微信 web 开发者工具，新建项目「小相册」，选择目录applet（或app）。\r\n\r\n「小相册」源码分析\r\n在进行部署之前，我们来简单分析一下「小相册」的具体代码。毕竟只看效果不是我们的目的，我们的目的是以「小相册」为例，了解如何开发小程序并与服务端进行交互。「小相册」包含一个描述整体程序的 app 和多个描述各自页面的 page。主程序 app 主要由三个文件组成，分别是 app.js（小程序逻辑）、app.json（小程序公共设置）和 app.wxss（小程序公共样式表），其中前两个为必备文件。config.js 文件中包含了一些部署域名的设置，现在不用管。在 pages 目录下，有两个 page 页面，分别是 index 和 album。页面结构算是比较简单的，其中 index \r\n是小程序启动时默认进入的页面。每个页面下，至少要有 .js（页面逻辑）和 .wxml（页面结构）两个文件，.wxss（页面样式表）和 \r\n.json（页面配置）文件为选填。你可能注意到了，这些文件的文件名与父目录的名称相同。这是微信官方的规定，目的是减少配置项，方便开发者。接下来我们以 index 页面为例做简单的解释。index.wxml 是这个页面的表现层文件，其中的代码非常简单，可以分为上下两大部分。<view>\r\n    <view class=\"page-top\">\r\n        <text class=\"username\">恭喜你</text>\r\n        <text class=\"text-info\">成功地搭建了一个微信小程序</text>\r\n        <view class=\"page-btn-wrap\">\r\n            <button class=\"page-btn\" bindtap=\"gotoAlbum\">进入相册</button>\r\n        </view>\r\n    </view>\r\n    <view class=\"page-bottom\">\r\n        <text class=\"qr-txt\">分享二维码邀请好友结伴一起写小程序！</text>\r\n        <image src=\"../../images/qr.png\" class=\"qr-img\"></image>\r\n        <image src=\"../../images/logo.png\" class=\"page-logo\"></image>\r\n    </view>\r\n</view>\r\n\r\n\r\n\r\n\r\n\r\n页面的演示效果如下：\r\n\r\n我们看到，页面上有一个“进入相册”的按钮。正常理解，点击后该按钮后我们就可以进入相册了（这不废话嘛）。那小程序背后是怎样实现该操作的呢？\r\n在 index.wxml 中，我们发现对应的 button 标签上定义了一个 bindtap 属性，绑定了一个叫做 gotoAlbum 的方法。而这个方法可以在 index.js 文件中找到。事实上，文件中也只定义了这一个方法，执行的具体动作就是跳转到 album 页面。\r\nPage({\r\n    // 前往相册页\r\n    gotoAlbum() {\r\n        wx.navigateTo({ url: '../album/album' });\r\n    },\r\n});\r\nalbum.js 页面中编写了程序的主要逻辑，包括选择或拍摄图片、图片预览、图片下载和图片删除；album.wxml 中三种视图容器 view、scroll-view、swiper均有使用，还提供了消息提示框 toast。具体方法和视图的实现请查看项目源码。所有的这些功能都写在 Page 类中。\r\nlib 目录下提供了小程序会用的一些辅助函数，包括异步访问和对象存储 COS 的 API。\r\n总的来说，和微信官方宣传的一样，在开发者工具下进行小程序的开发，效率确实提高了很多，而且有很多微信提高的组件和 API。所以，在开发速度这点上的体验还是非常爽的。\r\n另外，由于「小相册」需要使用诸多云端能力，如图片的上传和下载，我们还需要进行服务器端的部署和设置。具体请看接下来的步骤。\r\n第三步：云端部署 server 代码\r\n虽然服务端的开发不是本文的重点，但是为了全面地体验「小相册」的整个开发部署流程，我们还是有必要了解服务端的部署，这里我们使用的是腾讯云。\r\n如果你想更爽一点，那么可以选择腾讯云官方提供的小程序云端镜像。「小相册」的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，可以直接使用。可谓是一键部署好云端。\r\n如果你以前没有使用过腾讯云，可以选择免费试用（我已经领取了 8 天的个人版服务器），或者领取礼包以优惠的价格购买所需的服务。\r\n\r\n你也可以选择将「小相册」源码中的server文件夹上传到自己的服务器。\r\n第四步：准备域名和配置证书\r\n如果你已经有腾讯云的服务器和域名，并配置好了 https，那么可以跳过第 4-6 步。\r\n在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求。简单来说，就是你的域名必须走 https 协议。所以你还需要为你的域名申请一个证书。如果没有域名，请先注册一个。由于我们没有收到内测，也就暂时不用登录微信公众平台配置通信域名了。\r\n第五步：Nginx 配置 https\r\n微信小程序云端示例镜像中，已经部署好了 Nginx，但是还需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。\r\n\r\n请将红框部分换成自己的域名和证书，并且将 proxy_pass 设置为 Node.js 监听的端口，我的是 9993。\r\n配置完成后，重新加载配置文件并且重启 Nginx。\r\nsudo service nginx reload\r\nsudo service nginx restart\r\n第六步：域名解析\r\n我们还需要添加域名记录，将域名解析到我们的云服务器上，这样才可以使用域名进行 https 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们的域名就支持 https 访问了。\r\n\r\n\r\n第七步：开通和配置 COS\r\n由于我们希望实现动静分离的架构，所以选择把「小相册」的图片资源是存储在 COS 上的。要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作。\r\n\r\n点击创建 Bucket。会要求选择所属项目，填写相应名称。这里，我们只需要填上自己喜欢的 Bucket 名称即可。\r\n然后在 Bucket 列表中，点击刚刚创建的 Bucket。然后在新页面点击“获取API密钥”。\r\n弹出的页面中包括了我们所需要的三个信息：唯一的 APP ID，一对SecretID和SecretKey（用于调用 COS API）。保管好这些信息，我们在稍后会用到。最后，在新的 Bucket 容器中创建文件夹，命名为photos。这点后面我们也会提到。\r\n第八步：启动「小相册」的服务端\r\n在官方提供的镜像中，小相册示例的 Node 服务代码已部署在目录 /data/release/qcloud-applet-album 下。进入该目录，如果是你自己的服务器，请进入相应的文件夹。\r\ncd /data/release/qcloud-applet-album\r\n在该目录下，有一个名为 config.js 的配置文件（如下所示），按注释修改对应的 COS 配置：\r\nmodule.exports = {\r\n    // Node 监听的端口号\r\n    port: '9993',\r\n    ROUTE_BASE_PATH: '/applet',\r\n\r\n    cosAppId: '填写开通 COS 时分配的 APP ID',\r\n    cosSecretId: '填写密钥 SecretID',\r\n    cosSecretKey: '填写密钥 SecretKey',\r\n    cosFileBucket: '填写创建的公有读私有写的bucket名称',\r\n};\r\n另外，cd ./routes/album/handlers，修改 list.js，将 const listPath 的值修改为你的Bucket 下的图片存储路径。如果是根目录，则修改为 '/'。当前服务端的代码中将该值设置为了 '/photos' ，如果你在第七步中没有创建该目录，则无法调试成功。\r\n小相册示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：\r\npm2 start process.json\r\n第九步：配置「小相册」通信域名\r\n接下来，在微信 web 开发者工具打开「小相册」项目，并把源文件config.js中的通讯域名 host 修改成你自己申请的域名。\r\n\r\n将蓝色框内的内容修改为自己的域名\r\n然后点击调试，即可打开小相册Demo开始体验。\r\n\r\n\r\n最后提示一点，截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。但是由于没有内测资格，我们暂时是没办法体验了。\r\n嗯，就这点不够爽，没有内测邀请。"}
{"title": "微信小程序demo视频：博卡君开发实操指南 ", "author": "天下雪", "pub_time": "2016-10-14 10:16", "content": "经过国庆节的七天假期，相信很多朋友都已经研究出自己的小程序 demo 了吧？我最近也利用休息时间关注了一下网上关于小程序开发的讨论，今天就利用这个番外篇谈谈自己对小程序的一些想法吧，顺便把目前做好的成品 demo 给大家看一看。\r\n　　很多学编程的朋友最关心的问题就是小程序的开发难度。我个人觉得，微信小程序的开发难度不算高，最主要的是要时时刻刻遵守微信给我们划定的一些框架和规范。如果你有前端开发基础，那上手会非常快，相比之下，原生APP开发难度就大了很多。　　在用户体验方面，其实微信小程序开发和原生APP在体验方面在日常应用中可以做到非常接近了。不同点就是，微信小程序开发学习周期比较快，开发周期较短，维护起来也快，而原生APP的开发需要全部重新学习它的语言，学习周期很长，开发周期也很长，同时发布需要很长时间的审核期，在迭代方面速度比较慢。　　对于做前端的朋友，适应小程序最需要完成一个开发理念上的大转变，从操作 DOM 转变为操作数据，项目组件化、模板化，需要使用的组件直接调用。换言之，小程序绝对不是「Html 5 + javascrpt 封装一下」那么简单，为了让用户体验更加接近原生 APP，腾讯专门开放了大量接口和组件，这些都是 Html 本身所不具备的。我在一开始接触到这些东西的时候，也琢磨了很久才渐渐适应小程序的节奏。　　有朋友也问过，博卡君连夜吐血赶工了近两周才基本完成一个小程序，是不是微信小程序的开发工作量比较大，我觉得这要具体看你的项目重不重，轻量型的项目团队开发只需要一两周，但也可能在开发中碰到很多需要攻克的技术难点。此外，如果你的需求一直在变化，或者与不熟练的队友在开发，都是有可能影响进度。博卡君吐血熬夜毕竟是为了第一时间同时完成开发和教程的进度，如果团队协作，应该不需要这么辛苦?。　　最后谈一点，博卡君在这个项目中一直是以个人开发者的角色来做的，对于想跟博卡君一样独立开发的朋友，我个人觉得，如果你有数据支持，而且懂后台开发和Mysql，那完全不妨一试。　　好了，博卡君的全球首个微信小程序教程到这里就完全结束了，谢谢大家一直以来的支持和关注。最近大家都在期待微信官方的动态，毕竟目前既不能提交已经做好的小程序，也不确定微信会不会有小程序商店之类的入口来体验成品，博卡君也利用国庆长假顺带关注了一下 iMessage 插件的开发，看看其它平台有没有适合自己发挥的空间。　　其实关注 iMessage 最主要的原因还是它跟微信小程序有许多相似之处，譬如两者都是聊天工具的内部程序、都切合轻量化的使用场景、对 Html 5 都有很好的支持等。我这两天也尝试做了一款 iMessage APP，等功能完善之后会把成品放出来给大家看看。大家也可以对比一下两者的异同，选择适合自己的开发方向。"}
{"title": "微信小程序开发之吐司toast(消息提示框) ", "author": "天下雪", "pub_time": "2016-10-21 14:50", "content": "做Android的时候对toast是很熟悉的.微信小程序开发中吐司也是重要的消息提示方式.上代码:1.index.wxmltoast是微信提供的组件,duration是延迟时间,单位毫秒.这里设置是1000ms.bindchange是事件.在index.js中触发事件即可。<!--index.wxml-->  <toast hidden=\"{{toastHidden}}\" duration=\"1000\" bindchange=\"onToastChanged\">            {{toastText}}    </toast>  2.index.js先在data中定义参数,toastHidden(吐司是否显示),toastText(吐司文本),函数onToastChanged(),当toastHidden变化为时执行,也就是为false时置为true;不加函数吐司不会消失。//index.js  //获取应用实例  var app = getApp()  Page( {    data: {      toastHidden: true, //吐司      toastText: '',//吐司文本    },    onToastChanged: function() {      this.setData( { toastHidden: !this.data.toastHidden });    },    onLoad: function() {      this.setData( {        toastHidden: false, //吐司        toastText: '我是吐司',//吐司文本      })    }  })  我是直接在页面初始化(onLoad:function)时执行,可根据自己需求赋值给toastHidden和toastText。"}
{"title": "微信小程序把玩《六》：picker组件，radio组件，slider组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:03", "content": "一：picker组件picker选择器分为三种，普通选择器，时间选择器， 日期选择器 用mode属性区分，默认是普通选择器。测试时时间和日期点击无反应不知道是BUG还是啥！没法手机测试现在也不知道咋回事！！主要属性：普通选择器时间选择器日期选择器wxml<view>普通选择器</view><!--mode默认selector range数据源value选择的index bindchange事件监听--><picker mode=\"selector\" range=\"{{array}}\" value=\"{{index}}\" bindchange=\"listenerPickerSelected\">    <text>{{array[index]}}</text></picker><view>时间选择器</view><picker mode=\"time\" value=\"{{time}}\" start=\"06:00\" end=\"24:00\" bindchange=\"listenerTimePickerSelected\">    <text>{{time}}</text></picker><view>日期选择器</view><picker mode=\"date\" value=\"{{date}}\" start=\"2016-09-26\" end=\"2017-10-10\" bindchange=\"listenerDatePickerSelected\">    <text>{{date}}</text></picker>jsPage({  data:{    // text:\"这是一个页面\"    array: ['Android', 'IOS', 'ReactNativ', 'WeChat', 'Web'],    index: 0,    time: '08:30',    date: '2016-09-26'  },  /**   * 监听普通picker选择器   */  listenerPickerSelected: function(e) {      //改变index值，通过setData()方法重绘界面      this.setData({        index: e.detail.value      });  },   /**   * 监听时间picker选择器   */  listenerTimePickerSelected: function(e) {      //调用setData()重新绘制      this.setData({          time: e.detail.value,      });  },  /**   * 监听日期picker选择器   */  listenerDatePickerSelected:function(e) {    this.setDate({      date: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：radio组件赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              新手跳坑指南：小程序开发过程中遇到的各种坑 \n              微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ...\n                                    \n                  • 微信小程序把玩《二》：页面生命周期，模块化，数据绑定，view组件 ... ...\n                                    \n                  • 微信小程序把玩《三》：scroll-view组件，swiper组件，icon组件\n                                    \n                  • 微信小程序把玩《四》：text组件，progress组件，button组件\n                                    \n                  • 微信小程序把玩《五》：checkbox组件，form组件，input组件\n                                    \n                  • 微信小程序把玩《八》：toast组件，loading组件，navigator组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                    \n                  • 小程序 自定义slider组件音频播放实例\n                                    \n                  • 微信小程序radio点选框，再次点击取消\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155842|afff416a7d2cd3747a69946576f9311a|2';"}
{"title": "微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:11", "content": "一：switch组件switch开关组件使用主要属性：wxml<!--switch类型开关--><view>switch类型开关</view><switch type=\"switch\" checked=\"true\" bindchange=\"listenerSwitch\"/><!--checkbox类型开关--><view>checkbox类型开关</view><switch type=\"checkbox\" bindchange=\"listenerCheckboxSwitch\" />jsPage({  data:{    // text:\"这是一个页面\"  },  /**   * switch开关监听   */  listenerSwitch: function(e) {    console.log('switch类型开关当前状态-----', e.detail.value);  },  /**   * checkbox类型开关监听   */  listenerCheckboxSwitch: function(e) {    console.log('checkbox类型开关当前状态-----', e.detail.value)  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：action-sheet组件action-sheet组件是从底部弹出可选菜单项，估计也是借鉴iOS的设计添加的，action-sheet有两个子组件， action-sheet-item为每个选项，action-sheet-cancel取消选项，与action-sheet-item中间会有间隔，并且点击会触发action-sheet监听事件主要属性：wxml<!--触发action-sheet事件--><button type=\"primary\" bindtap=\"listenerButton\">弹出ActionSheet</button><!--默认action-sheet为隐藏，由button触发--><action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"listenerActionSheet\" >    <block wx:for-items=\"{{actionSheetItems}}\" >         <action-sheet-item >{{item}}</action-sheet-item>    </block>    <!--自动隐藏action-sheet-->    <action-sheet-cancel>取消</action-sheet-cancel></action-sheet>jsPage({  data:{    // text:\"这是一个页面\"    actionSheetHidden: true,    actionSheetItems: ['item1', 'item2', 'item3']  },  listenerButton: function() {      this.setData({        //取反          actionSheetHidden: !this.data.actionSheetHidden      });  },  listenerActionSheet:function() {    this.setData({      actionSheetHidden: !this.data.actionSheetHidden    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})三：modal组件modal弹出框常用在提示一些信息比如：退出应用，清楚缓存，修改资料提交时一些提示等等。常用属性：wxml<!--监听button点击事件--><button bindtap=\"listenerButton\" type=\"primary\">弹出modal</button><!--弹出框--><modal     title=\"退出应用\"     hidden=\"{{hiddenModal}}\"     confirm-text=\"再看看\"     cancel-text=\"退出\"     bindconfirm=\"listenerConfirm\"     bindcancel=\"listenerCancel\" >     您是否真的要退出应用     </modal>jsPage({  data:{    // text:\"这是一个页面\"    hiddenModal: true  },  listenerButton:function() {      this.setData({          hiddenModal: !this.data.hiddenModal      })  },  listenerConfirm:function() {      this.setData({          hiddenModal: true      })  },  listenerCancel:function() {      this.setData({          hiddenModal: true      })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})"}
{"title": "精品教程：微信小程序实战之知乎日报 ", "author": "天下雪", "pub_time": "2016-10-21 16:27", "content": "上一次的《微信小程序之小豆瓣图书》制作了一个图书的查询功能，只是简单地应用到了网络请求，其他大多数小程序应有的知识。而本次的示例是知乎日报，功能点比较多，页面也比上次复杂了许多。在我编写这个DEMO之前，网上已经有很多网友弄出了相同的DEMO，也是非常不错的，毕竟这个案例很经典，有比较完整的API，很值得模仿学习。本次个人的DEMO也算是一次小小的练习吧。由于知乎日报是一个资讯类的App，UI的布局主要是以资讯列表页、资讯详情页和评论页为主，当然本次也附带了应用设置页，不过现阶段功能尚未编写，过段时间会更新补充，继续完善。API分析本次应用使用了知乎日报的API，相比上次豆瓣图书的数量比较多了，但是部分仍然有限制，而且自己没有找到评论接口的分页参数，所以评论这块没有做数据的分页。以下是使用到的具体API，更加详细参数和返回结构可参照网上网友分享的 知乎日报-API-分析 ，在此就不做再次分析了。启动界面图片http://news-at.zhihu.com/api/4/start-image/{size}参数说明size图片尺寸，格式：宽*高。例如: 768*1024获取刚进入应用时的显示封面，可以根据传递的尺寸参数来获取适配用户屏幕的封面。获取最新日报http://news-at.zhihu.com/api/4/news/latest返回的数据用于日报的首页列表，首页的结构有上下部分，上部分是图片滑动模块，用于展示热门日报，下部分是首页日报列表，以上接口返回的数据有热门日报和首页日报获取日报详细http://news-at.zhihu.com/api/4/news/{id}参数说明id日报id在点击日报列表也的日报项时，需要跳转到日报详情页展示日报的具体信息，这个接口用来获取日报的展示封面和具体内容。历史日报http://news.at.zhihu.com/api/4/news/before/{date}参数说明date年月日格式时间yyyyMMdd,例如：20150903、20161202这个接口也是用与首页列表的日报展示，但是不同的是此接口需要传一个日期参数，如20150804格式。获取最新日报接口只能获取当天的日报列表，如果需要获取前天或者更久之前的日报，则需要这个接口单独获取。日报额外信息http://news-at.zhihu.com/api/4/story-extra/{id}参数说明id日报id在日报详情页面中，不仅要展示日报的内容，好需要额外获取此日报的评论数目和推荐人数等额外信息。日报长评http://news-at.zhihu.com/api/4/story/{id}/long-comments参数说明id日报id日报的评论页面展示长评用到的接口（没有找到分页参数，分页没有做）日报短评http://news-at.zhihu.com/api/4/story/{id}/short-comments参数说明id日报id日报的评论页面展示段评用到的接口（没有找到分页参数，分页没有做）主题日报栏目列表http://news-at.zhihu.com/api/4/themes主页的侧边栏显示有主题日报的列表，需要通过这个接口获取主题日报栏目列表主题日报具体内容列表http://news-at.zhihu.com/api/4/theme/{themeId}参数说明themeId主题日报栏目id在主页侧栏点击主题日报进入主题日报的内容页，需要展示此主题日报下的日报列表。代码编写启动页作为一个仿制知乎日报的伪APP，高大上的启动封面是必须的，哈哈。启动页面很简单，请求一个应用启动封面接口，获取封面路径和版权信息。当进入页面，在onLoad事件中获取屏幕的宽和高来请求适合尺寸的图片，在onReady中请求加载图片，在请求成果之后，延迟2s进入首页，防止页面一闪而过。onLoad: function( options ) {\r\n    var _this = this;\r\n    wx.getSystemInfo( {\r\n      success: function( res ) {\r\n        _this.setData( {\r\n          screenHeight: res.windowHeight,\r\n          screenWidth: res.windowWidth,\r\n        });\r\n      }\r\n    });\r\n},\r\n\r\nonReady: function() {\r\n    var _this = this;\r\n    var size = this.data.screenWidth + '*' + this.data.screenHeight;\r\n    requests.getSplashCover( size, ( data ) => {\r\n      _this.setData( { splash: data });\r\n    }, null, () => {\r\n      toIndexPage.call(_this);\r\n    });\r\n}\r\n  \r\n/**\r\n * 跳转到首页\r\n */\r\nfunction toIndexPage() {\r\n  setTimeout( function() {\r\n    wx.redirectTo( {\r\n      url: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发之吐司toast(消息提示框) \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程《二》：微信小程序实战之小豆瓣图书\n                                    \n                  • Rebecca Han：微信小程序仿知乎Demo实战教程（适用1028版本）\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 从零开始一个微信小程序版知乎\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n开发小程序折叠面板2020-02-16小程序后端 egg 框架开发记录2020-02-16小程序对文件及后缀名解析2020-02-16写了一个小程序——无聊也是一种生产力2020-02-27小程序-日历签到2020-02-26微信小程序简易SEO优化2020-02-26玩转微信小程序的位置授权2020-02-27这次一定彻底弄懂DOM事件机制2020-02-28控制音频文件播放进度2020-02-28\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n考研政治2000题答题小程序2020-02-28同城小程序代码2020-01-09汽车养护2020-01-07微信答题小程序仿头脑王者源码2020-01-02微信小程序图书共享借阅全套模板2019-12-10行政后勤服务小程序2019-11-28微信小程序--蓝牙控制音乐播放小车2019-11-15微信小程序--颜色选择器2019-11-13求小程序源码2019-11-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155844|722690d4c351d9c17dd94e41b7cc523a|2';"}
{"title": "精品教程《二》：微信小程序实战之小豆瓣图书 ", "author": "天下雪", "pub_time": "2016-10-21 16:35", "content": "最近微信小程序被炒得很火热，本人也抱着试一试的态度下载了微信web开发者工具，开发工具比较简洁，功能相对比较少，个性化设置也没有。了解完开发工具之后，顺便看了一下小程序的官方开发文档，大概了解了小程序的开发流程和一些常用的API。了解了小程序之后，自己就有了想要做一个小demo的冲动，虽然自己对小程序还没有做过很多实践，只是在官方例子上徘徊，但是还是想做出点小东西。既然要做一个demo，自然需要到数据，自己有又不想独自搭建服务端，所以在网上搜索可以用来提供测试数据的免费api，最后我选择了豆瓣图书。豆瓣图书提供的api功能比较少，加上不开放appkey申请，所以无法操作用户数据。只能做点简单的图书查询和图书详细信息展示，这个demo只有两个页面，非常之简单。豆瓣图书APIdemo中用到的豆瓣图书api只有两个，一个是图书搜索，另一个是获取图书详情。搜索图书赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程：微信小程序实战之知乎日报 \n              有渔微信小程序系统进阶《四》小程序组件 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程：微信小程序实战之知乎日报\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 小程序之豆瓣电影源码解读\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n开发小程序折叠面板2020-02-16小程序后端 egg 框架开发记录2020-02-16小程序对文件及后缀名解析2020-02-16写了一个小程序——无聊也是一种生产力2020-02-27小程序-日历签到2020-02-26微信小程序简易SEO优化2020-02-26玩转微信小程序的位置授权2020-02-27这次一定彻底弄懂DOM事件机制2020-02-28控制音频文件播放进度2020-02-28\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n考研政治2000题答题小程序2020-02-28同城小程序代码2020-01-09汽车养护2020-01-07微信答题小程序仿头脑王者源码2020-01-02微信小程序图书共享借阅全套模板2019-12-10行政后勤服务小程序2019-11-28微信小程序--蓝牙控制音乐播放小车2019-11-15微信小程序--颜色选择器2019-11-13求小程序源码2019-11-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155845|07f14f239d5a2925d3e4061e3cbca046|2';"}
{"title": "微信小程序入门系列《四》：触控事件 ", "author": "天下雪", "pub_time": "2016-10-22 13:54", "content": "作者：疯狂的猫原文地址：http://www.cnblogs.com/nosqlcoco/p/5954453.html》》》什么是事件事件是视图层到逻辑层的通讯方式。事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如id, dataset, touches。》》》事件分类touchstart 手指触摸touchmove 手指触摸后移动touchcancel 手指触摸动作被打断，如弹窗和来电提醒touchend 手指触摸动作结束tap 手指触摸后离开longtap 手指触摸后后，超过350ms离开》》》事件绑定事件绑定的写法同组件的属性，以 key、value 的形式。key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstartvalue 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。上面简单介绍了小程序事件基础，是时候彰显\"事件\"的威力：单击(tap)双击(dbtap)长按(longtap)滑动多点触控1.单击单击事件由touchstart、touchend组成,touchend后触发tap事件。<view>  <button type=\"primary\" bindtouchstart=\"mytouchstart\" bindtouchend=\"mytouchend\" bindtap=\"mytap\">点我吧</button></view>mytouchstart: function(e){    console.log(e.timeStamp + '- touch start')},mytouchend: function(e){        console.log(e.timeStamp + '- touch end')},mytap: function(e){        console.log(e.timeStamp + '- tap')}2.双击双击事件由两个单击事件组成，两次间隔时间小于300ms认为是双击；微信官方文档没有双击事件，需要开发者自己定义处理。<view>  <button type=\"primary\" bindtap=\"mytap\">点我吧</button></view> 3.长按长按事件手指触摸后，超过350ms再离开。<view>  <button type=\"primary\" bindtouchstart=\"mytouchstart\" bindlongtap=\"mylongtap\"     bindtouchend=\"mytouchend\" bindtap=\"mytap\">点我吧</button></view>mytouchstart: function(e){        console.log(e.timeStamp + '- touch start')},//长按事件mylongtap: function(e){        console.log(e.timeStamp + '- long tap')},mytouchend: function(e){        console.log(e.timeStamp + '- touch end')},mytap: function(e){        console.log(e.timeStamp + '- tap')}单击、双击、长按属于点触事件，会触发touchstart、touchend、tap事件，touchcancel事件只能在真机模拟，不多说了。事件触发顺序单击touchstart → touchend → tap双击touchstart → touchend → tap → touchstart → touchend → tap长按touchstart → longtap → touchend → tap4.滑动手指触摸屏幕并移动，为了简化起见，下面以水平滑动和垂直滑动为例。 滑动事件由touchstart、touchmove、touchend组成坐标图： 以屏幕左上角为原点建立直角坐标系。第四象限为手机屏幕，Y轴越往下坐标值越大（注意跟数学象限的区别）。假设A点为touchstart事件触摸点，坐标为A(ax,ay)，然后手指向上滑动到点B(bx,by)，就满足条件by < ay;同理，向右滑动到C(cx,cy),满足cx > ax；向下滑动到D(dx,dy),满足dy > ay；向左移动到E(ex，ey)满足ex < ax.计算线段AB在Y轴上投影长度为m,在X轴上的投影长度为n计算r = m/n,如果r > 1,视为向上滑动。同理计算线段AC,AD,AE在Y轴投影长度与X轴的投影长度之比，得出向右向下向左的滑动。以上没考虑r为1的情况。<view>  <button type=\"primary\"  bindtouchstart=\"mytouchstart\" bindtouchmove=\"mytouchmove\">点我吧</button></view>5.多点触控由于模拟器尚不支持多点触控，内测开放后，继续补充。"}
{"title": "微信小程序官方设计指南 ", "author": "天下雪", "pub_time": "2016-10-22 16:24", "content": "概要基于微信小程序轻快的特点，我们拟定了小程序界面设计指南和建议。 设计指南建立在充分尊重用户知情权与操作权的基础之上。旨在微信生态体系内，建立友好、高效、一致的用户体验，同时最大程度适应和支持不同需求，实现用户与小程序服务方的共赢。友好礼貌为了避免用户在微信中使用小程序服务时，注意力被周围复杂环境干扰，小程序在设计时应该注意减少无关的设计元素对用户目标的干扰，礼貌地向用户展示程序提供的服务，友好地引导用户进行操作。重点突出每个页面都应有明确的重点，以便于用户每进入一个新页面的时候都能快速地理解页面内容，在确定了重点的前提下，应尽量避免页面上出现其他干扰项影响用户的决策和操作。反例示意此页面的主题是查询，却添加了诸多与查询不相关的业务入口，与用户的预期不符，易造成用户的迷失。纠正示意去掉任何与用户目标不相关的内容，明确页面主题，在技术和页面控件允许的前提下提供有助于用户目标的帮助内容，比如最近搜索词，常用搜索词等。反例示意操作没有主次，让用户无从选择纠正示意首先要避免并列过多操作让用户选择，在不得不并列多个操作时，需区分操作主次，减轻用户的选择难度。流程明确为了让用户顺畅地使用页面，在用户进行某一个操作流程时，应避免出现用户目标流程之外的内容而打断用户。反例示意用户本打算进行搜索，在进入页面时却被突如其来的抽奖弹窗所打断；对于抽奖没有兴趣的用户是非常不友好的干扰； 而即便有部分用户确实被“诱人”的抽奖活动所吸引，离开主流程去抽奖之后可能就遗忘了原本的目标，进而失去了对产品真正价值的利用和认识。清晰明确一旦用户进入我们的小程序页面，我们就有责任和义务清晰明确地告知用户身在何处、又可以往何处去，确保用户在页面中游刃有余地穿梭而不迷路，这样才能为用户提供安全的愉悦的使用体验。导航明确，来去自如导航是确保用户在网页中浏览跳转时不迷路的最关键因素。导航需要告诉用户，我在哪，我可以去哪，如何回去等问题。首先在微信系统内的所有小程序的全部页面，均会自带微信提供的导航栏，统一解决我在哪，如何回去的问题。在微信层级导航保持体验一致，有助于用户在微信内形成统一的体验和交互认知，无需在各小程序和微信切换中新增学习成本或改变使用习惯。微信导航栏微信导航栏，直接继承于客户端，除导航栏颜色之外，开发者无需亦不可对其中的内容进行自定义。但开发者需要规定小程序各个页面的跳转关系，让导航系统能够以合理的方式工作。微信导航栏分为导航区域、标题区域以及操作区域。其中导航区控制程序页面进程。目前导航栏分深浅两种基本配色。导航区（iOS）导航区通常只有一个操作，即返回上一级界面。导航区（Android）同iOS一样，导航区也只有一个返回上一级页面的操作，而点击安卓手机自带的硬件返回键也起到相同作用。微信导航栏自定义颜色规则（iOS和Android）小程序导航栏支持基本的背景颜色自定义功能，选择的颜色需要在满足可用性前提下，和谐搭配微信提供的两套主导航栏图标。建议参考以下选色效果：选色方案示例页面内导航开发者可根据自身功能设计需要在页面内添加自有导航。并保持不同页面间导航一致。但是受限于手机屏幕尺寸的限制，小程序页面的导航应尽量简单，若仅为一般线性浏览的页面建议仅使用微信导航栏即可。开发者可选择小程序页面添加标签分页（Tab）导航。标签分页栏可固定在页面顶部或者底部，便于用户在不同的分页间做切换。标签数量不得少于2个，最多不得超过5个，为确保点击区域，建议标签数量不超过4项。一个页面也不应出现一组以上的标签分页栏。其中小程序首页可选择微信提供的原生底部标签分页样式，该样式仅供小程序首页使用。开发时可自定义图标样式、标签文案以及文案颜色等，具体设置项可参考开发文档。 顶部标签分页栏颜色可自定义。在自定义颜色选择中，务必注意保持分页栏标签的可用性、可视性和可操作性。 减少等待，反馈及时页面的过长时间的等待会引起用户的不良情绪，使用微信小程序项目提供的技术已能很大程度缩短等待时间。即便如此，当不可避免的出现了加载和等待的时候，需要予以及时的反馈以舒缓用户等待的不良情绪。启动页加载小程序启动页是小程序在微信内容一定程度上展现品牌特征的页面之一。本页面将突出展示小程序品牌特征和加载状态。启动页除品牌标志（Logo）展示外，页面上的其他所有元素如加载进度指示，均由微信统一提供且不能更改，无需开发者开发。页面下拉刷新加载在微信小程序内，微信提供标准的页面下拉刷新加载能力和样式。开发者可自定义需要通过下拉交互完成刷新的页面，此类交互微信将提供标准能力和样式。在样式上，刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标识与刷新图标的和谐统一。当用户在该类页面做出下拉交互时，出现微信小程序页面标准加载动画。开发者无需自行开发样式深浅两套下拉样式微信下拉提示用于给用户明确的小程序归属者，防止造假与作弊。此处标示提供深浅两套方案，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。iOS和Android配色方案相同如下展示。微信下拉标示错误使用案例请避免以下错误使用情况，确保信息的可见性和页面的可用性页面内加载反馈开发者可在小程序里自定义页面内容的加载样式。建议不管是使用在局部还是全体，自定义加载样式都应该尽可能简洁，并使用简单动画告知用户加载过程。 开发者也可以使用微信提供的，统一的页面加载样式，如图中例所示。模态加载模态的加载样式将覆盖整个页面的，由于无法明确告知具体加载的位置或内容将可能引起用户的焦虑感，因此应谨慎使用。除了在某些全局性操作下不要使用模态的菊花。局部加载反馈即只在触发加载的页面局部进行反馈，这样的反馈机制更加有针对性，页面改动小，是微信推荐的反馈方式。例如：加载反馈注意事项若载入时间较长,应提供取消操作,并使用进度条显示载入的进度。载入过程中,应保持动画效果 ; 无动画效果的加载很容易让人产生该界面已经卡死的错觉。不要在同一个页面同时使用超过1个加载动画。结果反馈除了在用户等待的过程中需予以及时反馈外，对操作的结果也需要予以明确反馈。根据实际情况，可选择不同的结果反馈样式。对于页面局部的操作，可在操作区域予以直接反馈，对于页面级操作结果，可使用弹出式提示（Toast）、模态对话框或结果页面展示。页面局部操作结果反馈对于页面局部的操作，可在操作区域予以直接反馈，例如点击多选控件前后如下图。对于常用控件，微信设计中心将提供控件库，其中的控件将提供完整操作反馈。页面全局操作结果——弹出式提示（Toast）弹出式提示（Toast）适用于轻量级的成功提示，1.5秒后自动消失，并不打断流程，对用户影响较小，适用于不需要强调成功状态的操作提醒。特别注意该形式不适用于错误提醒。页面全局操作结果——模态对话框对于需要用户明确知晓的操作结果状态可通过模态对话框来提示，并可附带下一步操作指引。页面全局操作结果—结果页对于操作结果已经是当前流程的终结的情况，可使用操作结果页来反馈。这种方式最为强烈和明确的告知用户操作已经完成，并可根据实际情况给出下一步操作的指引。异常可控，有路可退在设计任何的任务和流程时，异常状态和流程往往容易被忽略，而这些异常场景往往是用户最为沮丧和需要帮助的时候，因此需要格外注意异常状态的设计，在出现异常时予以用户必要的状态提示，并告知解决方案，使其有路可退。要杜绝异常状态下，用户莫名其妙又无处可去，卡在某一个页面的情况。2.2中所提到的弹窗和结果页面都可作为异常状态的提醒方式。除此之外，在表单页面中尤其是表单项较多的页面中，还应明确指出出错项目，以便用户修改。异常状态——表单出错表单报错，在表单顶部告知错误原因，并标识出错误字段提示用户修改便捷优雅从PC时代的物理键盘鼠标到移动端时代手指，虽然输入设备极大精简，但是手指操作的准确性却大大不如键盘鼠标精确。为了适应这个变化，需要开发者在设计过程中充分利用手机特性，让用户便捷优雅的操控界面。减少输入由于手机键盘区域小且密集，输入困难的同时还易引起输入错误，因此在设计小程序页面时因尽量减少用户输入，利用现有接口或其他一些易于操作的选择控件来改善用户输入的体验。减少输入，巧用接口例如下图中，在添加银行卡时，采用摄像头识别接口来帮助用户输入。除此之外微信团队还对外开放例如地理位置接口等多种微信小程序接口 ，充分利用这些接口将大大提高用户输入的效率和准确性，进而优化体验。除了利用接口外，在不得不让用户进行手动输入时，应尽量让用户做选择而不是键盘输入。一方面，回忆易于记忆，让用户在有限的选项中做选择通常来说是容易于完全靠记忆输入；另一方面，仍然是考虑到手机键盘密集的单键输入极易造成输入错误。 例如图中，在用户搜索时提供搜索历史快捷选项将帮助用户快速进行搜索，而减少或避免不必要是键盘输入。避免误操作因为在手机上我们通过手指触摸屏幕来操控界面，手指的点击精确度远不如鼠标，因此在设计页面上需点击的控件时，需要充分考虑到其热区面积，避免由于可点击区域过小或过于密集而造成误操作。当简单的将原本在电脑屏幕上使用的界面不做任何适配直接移植到手机上时，往往就容易出现这样的问题。由于手机屏幕分辨率各不相同，因此最适宜点击像素尺寸也不完全一致，但换算成物理尺寸后大致是在7mm-9mm之间。在微信提供的标准组件库中，各种控件元素均已考虑到了页面点击效果以及不同屏幕的适配，因此再次推荐使用或模仿标准控件尺寸进行设计。利用接口提升性能微信设计中心已推出了一套网页标准控件库，包括sketch设计控件库和Photoshop设计控件库，后续还将完善小程序组件，这些控件都已充分考虑了移动端页面的特点，能够保证其在移动端页面上的可用性和操作性能；同时微信开发团队也在不断完善和扩充微信小程序接口，并提供微信公共库，利用这些资源不但能够为用户提供更加快捷的服务，而且对页面性能的提高有极大作用，无形之中提升了用户体验。统一稳定除了以上所提到的种种原则，建议接入微信的小程序还应该时刻注意不同页面间的统一性和延续性，在不同的页面尽量使用一致的控件和交互方式。统一的页面体验和有延续性的界面元素都将帮助用最少的学习成本达成使用目标，减轻页面跳动所造成的不适感。正因如此，小程序可根据需要使用微信提供的标准控件，以达到统一稳定的目的。视觉规范为方便设计师进行设计，微信提供一套可供Web设计和小程序使用的基础控件库；同时提供方便开发者调用的资源。字体规范微信内字体的使用与所运行的系统字体保持一致，常用字号为20, 18, 17, 16,14 13, 11(pt)，使用场景具体如下：字体颜色主内容 Black 黑色，次要内容 Grey 灰色；时间戳与表单缺省值 Light 灰色；大段的说明内容而且属于主要内容用 Semi 黑；蓝色为链接用色，绿色为完成字样色，红色为出错用色 Press与 Disable状态分别降低透明度为20%与10%；列表视觉规范表单输入视觉规范按钮使用原则列表外按钮上文字标准按钮高度为44px下使用: 颜色 ＃000000 / ＃353535 字号 18pt可点状态下文字调整透明度为60%不可点状态下文字调整透明度为30%列表外按钮上文字标准按钮高度为25px下使用: 颜色 ＃000000 / ＃353535 字号 14pt页面线性按钮上文字标准按钮高度为35px下使用: 颜色 ＃09BB07 / ＃353535 字号 16pt图标使用原则"}
{"title": "微信小程序的原型设计尝鲜 ", "author": "天下雪", "pub_time": "2016-10-23 11:47", "content": "\"小程序”来了，大世界要变了？微信小程序可能是近期业绩最火的话题之一了。这个根植于微信流量巨无霸的应用，将对应用市场、对微商、电商、对企业的开发成本、获客成本将产生深远影响？将制造出绕开Google Play和AppStore的另一大App体系？将实现“知人性”的PM张小龙先生的“用后即走”的轻量App之梦？将秒杀传统的App？虽有海量追捧者趋之若鹜，但也有冷静人士淡定的白眼。但无论如何，腾讯这步棋子既然落在了棋盘上，绝不能悔棋，更不可能半途而废，你我这样神经敏感的PM、UX，不尝鲜是不可能的。说动就动，查找到微信小程序的设计规范后，让我们开始吧。造大梦的事儿还是让大佬们去干吧，咱们干点实在的。干活儿首先得挑个工具，我这里使用了Mockplus，近期国内的一款比较流行的原型设计。比较顺手，线框、交互都能胜任。首先尝试做WeUI的界面元素吧。经过一会儿的折腾，搞成了一套（好在WeUI的界面元素比不是太多）。有了这个，之后就方便了。在提示和上传页面中，我使用了交互，点击“成功提示”按钮，弹出提示。点击“上传”按钮，完成进度条的走动。操作很简单：在Mockplus中选中按钮，直接拖拽到准备弹出的提示框上，设置“显示/隐藏”，并在消失时做了延迟处理。提示框的默认显示状态，设为“不可见”。至于进度条的走动，是设置每个进度轨道的“调整尺寸”的交互（设置宽度变化），多拖拽几次鼠标，设置链接就好了，如图：好了，让我们来看看效果。点这里看我的成果：http://run.mockplus.cn/Tnr9w9TyUKjXeDeR/index.html这个尝试到此暂时结束，页面不多，算是个半成品。但在制作时，我边做边琢磨微信在设计中的一些理念：简约、准确、易用。这个伟大的产品之所以在国内能够深入人心，还是有些道理的。"}
{"title": "微信小程序开发框架MINA分析 ", "author": "天下雪", "pub_time": "2016-10-23 11:58", "content": "MINA是微信开发小程序的框架：MINA的目标是通过尽可能简单，高效的方式让开发者可以在微信中开发具有原生APP体验的服务。运行MINA的项目必须要有微信web开发者工具MINA框架中有四种类型的文件:.js文件 基于JavaScript的逻辑层框架.wxml 视图层文件，是MINA设计的一套标签语言.wxss 样式文件，用于描述WXML的组件样式.json 文件，配置文件，用于单个页面的配置和整个项目的配置目录结构为了减少配置项，小程序中一个页面中的四个文件必须要有相同的路径和文件名,使用微信web开发者工具新建一个项目,可以看到他的目录结构是这样的：其中app.js是程序的入口，app.json是项目的配置文件,app.wxss是全局配置的样式文件,logs和index文件夹是是单个页面的文件，utils用来存放常用的工具类文件夹。app.jsapp.js使用App()函数注册一个小程序，可以指定小程序的生命周期小程序的App()生命周期中三个事件可以监听:onLaunch，onShow，onHide。onLaunch：小程序加载完成之后调用,全局只触发一次onShow： 小程序启动，或者从后台到前台会触发一次onHide：小程序从前台到后台会触发一次例如:App({ \r\n onLaunch: function () { \r\n    console.log('App Launch')\r\n  }, \r\n onShow: function () {\r\n    console.log('App Show')  \r\n},  \r\nonHide: function () {\r\n    console.log('App Hide')  \r\n}, \r\n globalData: {\r\n    hasLogin: false  \r\n}\r\n})其中app.js的globalData可以设置全局的变量,在一个页面中可以通过getApp()函数获取小程序的实例，使用App的getCurrentPage()可以获取到当前页面的实例。app.jsonapp.json是小程序的全局配置包括:页面的路径，窗口表现，设置网络超时,开发模式等...页面配置pages:设置页面的路径  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ]配置的index和logs两个页面的路径,在这里使用相对路径配置页面路径。窗口配置windows：用来配置状态栏的颜色，导航条的样式和颜色，标题，已经窗口的背景色:\"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#ffffff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\":\"black\"\r\n  }使用的Color为十六进制的颜色值,比如\"#ffffff\"注意:其中navigationBarTextStyle，导航栏的颜色仅支持black/white。而backgroundTextStyle，下拉背景的样式仅支持dark/light。tabBar: 设置tab应用，tabBar是一个数组，最少需要配置2个，最多能配置5个tab，tab按照数据的顺序排序：\"tabBar\":{\r\n    \"color\":\"#dddddd\",\r\n    \"selectdColor\":\"#3cc51f\",\r\n    \"borderStyle\":\"black\",\r\n    \"backgroundColor\":\"#ffffff\"\r\n  ,\"list\":[\r\n    {\r\n      \"pagePath\":\"pages/index/index\",\r\n      \"iconPath\":\"image/wechat.png\",\r\n      \"selectedIconPath\":\"image/wechatHL.png\",\r\n      \"text\":\"主页\"\r\n      },{\r\n    \"pagePath\":\"pages/logs/logs\",\r\n    \"iconPath\":\"image/wechat.png\",\r\n    \"selectedIconPath\":\"image/wechatHL.png\",\r\n    \"text\":\"日志\"\r\n  }]\r\n}这里设置了两个tab页:index和log，效果如下:networkTimeout设置网络请求的超时时间,小程序有四种类型的网络请求wx.request普通的http请求，配置为requestwx.connect stock链接,配置为connectSocketwx.uploadFile上传文件,配置为uploadFilewx.downloadFile下载文件,配置为downloadFile配置单位为毫秒,例如：\"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"connectSocket\": 10000,\r\n    \"uploadFile\": 10000,\r\n    \"downloadFile\": 10000\r\n  }debug:开发工具中开启debug模式，在控制台面板上可以看到调试信息,我们也可以使用console.log('onLoad')输入log帮助我们调试程序。\"debug\": trueapp.wxssapp.wxss中定义的的样式为全局样式，作用在每一个页面，在page中定义的.wxss文件为局部样式，只作用在局部，局部样式中的定义会覆盖app.wxss中定义的样式。样式的定义:.container {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 200rpx 0;\r\n  box-sizing: border-box;\r\n}其中200rpx中的rpx是reponslve pixel，可以根据屏幕的宽度进行自适应，在iPhone6上1rpx=0.5px=1物理像素。微信小程序建议设计以iPhone6为准样式的使用：class=\"container\">\r\n\r\npage使用Page()函数来注册一个页面，为其指定页面的初始数据，生命周期函数，事件处理等。data 页面的初始数据，可以使用setData更新定义的数据onLoad 页面加载事件onReady 页面渲染完成onShow 页面显示onHide 页面隐藏onUnload 页面卸载例如:Page({\r\n  data: {\r\n    logs: []\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      logs: (wx.getStorageSync('logs') || []).map(function (log) {\r\n        return util.formatTime(new Date(log))\r\n      })\r\n    })\r\n  }\r\n})page另外使用的文件.wxml是页面文件，使用定义好一套标签语言，.wxss是局部样式文件，.json局部配置文件比如需要在一个单独的页面中设置他的navigationBarTitleText,可以在.json文件中设置:{\r\n    \"navigationBarTitleText\": \"日志文件\"\r\n}源代码地址:https://github.com/jjz/weixin-mina"}
{"title": "有渔微信小程序系统概述《一》认识微信小程序与HelloWorld ", "author": "天下雪", "pub_time": "2016-10-23 12:11", "content": "认识微信小程序一、当前APP的痛点1. 用户的痛自从买了智能手机后，手机上装了一堆APP，每次装一个新应用就必须下载安装一个APP。这手机屏幕成了百货展厅，每次找个APP还得滑动屏幕找白天；而且每次安装一个APP，就占用大量空间，这手机容量也越来越不够用了。一次跟一位做运营的朋友聊天，他说现在只在微信上做推广，因为微信上客户群体多。他说知名度小的APP很难推，一是推广费用高，二是客户一般也不愿下载。 2. 开发者的痛现在做互联网的，开发了PC端的WEB后，再开发Android和Apple版，几乎是标配。我也曾经赶过这趟浑水，当时团队开发完了PC端的WEB，然后自然就想到要开发Android和Apple版。但问题来了：我们团队人少，而且大家都没APP开发经验；哪就找外包呗？于是我们就去找外包公司。后来在聊天中外包公司的老大就向我吐苦水，他说现在1个Android，1个Apple团队，1个项目必须得养2帮人马，开发成本太高了。后来，为了省财力、时间，我就让外包公司开发一个APP的外壳，然后里面打开浏览器访问我们的WAP网站，也就是Hybrid APP解决方案。Hybrid APP解决方案虽然开发便捷，但在用户体验上就比原生的APP差很多。 二、微信小程序方便了用户，更方便了开发者什么是小程序？小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不关心是否安装太多应用的问题。应用将无处不在，随时随地可用，但又无需安装卸载。微信小程序解决了当前APP的痛点，方便了用户，更方便了开发者。从本质上看，微信小程序有点类似Hybrid APP解决方案。以后微信就成为移动端入口，用户不用再无休止地安装APP了；开发者只需要用javaScript一种语言就可以了，开发成本几乎可省下2/3以上；而且微信提供了非常丰富的API，微信小程序的用户体验肯定不会比原生的APP差。微信作为国内最大的交友平台，已经成了一个独立的互联网王国，上面有大量的用户资源，微信小程序推广的性价比就非常高。   可以想象，再过一段时间，大量的APP开发者会转投微信小程序的大营，而且几乎所有的APP都会重新再开发一个微信小程序版本，微信小程序开发人员的需求也会非常大。所以，作为一名互联网从业人员，学习掌握微信小程序开发是非常有必要的。HelloWorld微信小程序看千遍不如做一遍。先让我们来一起做一个最简单的HelloWorld吧。    1.下载安装微信小程序开发者工具，下载路径：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html根据你的操作系统类型，选择windows 64、windows 32或mac。     2.创建项目    ⑴ 添加项目    点击“添加项目”按钮，创建一个项目。⑵ 项目的几个参数说明    没有 AppID 就选无AppID（如果乱写会报错，到时可能无法进入项目）。如果你选择的“项目目录”为空，请如图所示勾选在“当前目录中创建quick start项目”。项目名称就随便写一个吧，比如“测试项目”。点击“添加项目”按钮，一个最简单的微信小程序就完成了。3.项目代码结构说明    点击开发者工具左侧导航的“编辑”，我们可以看到这个项目已经初始化并包含了一些简单的代码。其中包括：app.js，app.json，app.wxss和2个目录：pages，utils。     其中，最重要的是 app.js、app.json、app.wxss 这三个文件。    app.js：这个文件是整个小程序的入口文件。    app.json：这个文件是小程序的全局配置文件，决定页面文件的路径，窗口表现，设置网络超时时间等。app.wxss：是小程序的样式文件，你可以把它想象成html中的CSS。"}
{"title": "有渔微信小程序系统概述《二》了解.js文件及.json文件 ", "author": "天下雪", "pub_time": "2016-10-23 12:17", "content": "了解.js文件1、app.jsapp.js是整个小程序的入口文件，也是控制整个小程序生命周期的文件。App.js用App()来实现对整个程序的注册，同时App()里面还实现了对小程序生命周期的监控函数(onLaunch, onShow, onHide)。APP()内部参数说明：属性类型描述触发时机onLaunchFunction生命周期函数--监听小程序初始化当小程序初始化完成时，会触发onLaunch（全局只触发一次）onShowFunction生命周期函数--监听小程序显示当小程序启动，或从后台进入前台显示，会触发 onShowonHideFunction生命周期函数--监听小程序隐藏当小程序从前台进入后台，会触发 onHide其他Any开发者可以添加任意的函数或数据到Object 参数中，用 this 可以访问     我们来看一个app.js的代码：//app.jsApp({  onLaunch: function () {    ... ...  },  getUserInfo:function(cb){    ... ...  },  globalData:{    userInfo:null  },  onShow: function(){    ... ...  },  onHide: function(){    ... ...  }}) 小程序前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。简单地说，前台就是你在操作小程序时；后台就是你离开了小程序，去玩手机的其他东西去了，这时小程序就隐藏到后面去了。 2、index.js小程序中每一个页面可以放在一个文件夹中，这个文件夹中一般包括4个文件：.js, .json, .wxml, .wxss。官方建议这四个文件的名字最好和文件夹的名字一致，这样便于框架自动查找。每个页面都需要注册，index.js用Page()这个函数来注册一个页面，它接受一个object参数，用这个参数来指定页面的初始数据，生命周期函数，事件处理函数。 Page()内部参数说明：属性类型描述dataObject页面的初始数据onLoadFunction生命周期函数--监听页面加载onReadyFunction赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nhgf\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              有渔微信小程序系统概述《一》认识微信小程序与HelloWorld \n              有渔微信小程序系统概述《三》view层及小程序框架概述 \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n                                    \n                  • 有渔微信小程序系统进阶《四》小程序组件\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155854|684dfba1397a1af117bb0a38b13084b1|2';"}
{"title": "有渔微信小程序系统概述《三》view层及小程序框架概述 ", "author": "天下雪", "pub_time": "2016-10-23 12:25", "content": "小程序的view层MVC模式这里就不讲了，不懂MVC模式的就自己去查阅相关资料。小程序的的view层由WXML与WXSS编写，由组件来进行展示。view层将逻辑层的数据反应成界面显示，同时将界面发生的事件发送给逻辑层。WXML(WeiXin Markup language)用于描述页面的结构，可以想象成Html文件。WXSS(WeiXin Style Sheet)用于描述页面的样式，可以想象成Css文件。组件(Component)是视图的基本组成单元，可以想象成Html中的组件。下面我们用简单的例子来看看 WXML 具有什么能力： 1、测试环境准备⑴ pages目录里建立viewtest目录，专门用来做view层测试。⑵ index里添加触发viewtest的相关代码① index.wxml修改成：② index.js添加下面的代码：  bindUserTap: function() {    wx.navigateTo({      url: '../viewtest/viewtest'    })  },③ app.json把viewtest路径加入pages参数里：  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/viewtest/viewtest\"  ], 2、例子⑴ 数据绑定<!--viewtest.wxml--><view> {{message}} </view>// viewtest.jsPage({  data: {    message: 'Hello MINA!'  }}) ⑵ 列表渲染<!--viewtest.wxml--><view wx:for=\"{{array}}\"> {{item}} </view>// viewtest.jsPage({赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              有渔微信小程序系统概述《二》了解.js文件及.json文件 \n              有渔微信小程序系统概述《六》小程序的API \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n                                    \n                  • 有渔微信小程序系统进阶《四》小程序组件\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155855|3c72ab67ae853931c843c4eaa03d07ad|2';"}
{"title": "有渔微信小程序系统进阶《四》小程序组件 ", "author": "天下雪", "pub_time": "2016-10-23 12:34", "content": "组件(Component)是小程序视图的基本组成单元，可以把它想象成Html中的组件，你可以通过组合这些基础组件快速开发小程序的界面。小程序的组件包括以下内容：大类具体组件说明视图容器view视图scroll-view可滚动视图区域swiper滑块视图区域赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n              微信小程序实战教程：火车票查询，直取12306数据 \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n                                    \n                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n开发小程序折叠面板2020-02-16小程序后端 egg 框架开发记录2020-02-16小程序对文件及后缀名解析2020-02-16写了一个小程序——无聊也是一种生产力2020-02-27小程序-日历签到2020-02-26微信小程序简易SEO优化2020-02-26玩转微信小程序的位置授权2020-02-27这次一定彻底弄懂DOM事件机制2020-02-28控制音频文件播放进度2020-02-28\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n考研政治2000题答题小程序2020-02-28同城小程序代码2020-01-09汽车养护2020-01-07微信答题小程序仿头脑王者源码2020-01-02微信小程序图书共享借阅全套模板2019-12-10行政后勤服务小程序2019-11-28微信小程序--蓝牙控制音乐播放小车2019-11-15微信小程序--颜色选择器2019-11-13求小程序源码2019-11-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155856|5455478bb87183100b4bff05a2cd0e5f|2';"}
{"title": "有渔微信小程序技术分析《五》Mustache语法要点总结 ", "author": "天下雪", "pub_time": "2016-10-23 12:36", "content": "小程序开发的wxml里，用到了Mustache语法。所以，非常有必要把Mustache研究下。什么是Mustache?Mustache是一个logic-less（轻逻辑）模板解析引擎，它是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，通常是标准的HTML文档。比如小程序的wxml中的代码：{{userInfo.nickName}}，这里的{{ }}就是Mustache的语法。1、Mustache的模板语法很简单，就那么几个：{{keyName}}{{{keyName}}}{{#keyName}} {{/keyName}}{{^keyName}} {{/keyName}}{{.}}{{!comments}}{{>partials}} 1、{{keyName}}⑴ 简单的变量替换：{{name}}var data = { \"name\": \"weChat\" };Mustache.render（\"{{name}} is excellent.\"，data）;返回 weChat is excellent.⑵ 变量含有html的代码，如：、等而不想转义，可以在用{{&name}}var data = {    \"name\" : \"<br>weChat<br>\"};var output = Mustache.render(\"{{&name}} is excellent.\", data);console.log(output);返回：<br>weChat<br> is excellent. 去掉\"&\"的返回是转义为：<br>weChat<br> is excellent.另外，你也可以用{{{ }}}代替{{&}}。 ⑶ 若是对象，还能声明其属性var data = {              \"name\" : {              \"first\" : \"Chen\"，              \"last\" : \"Jackson\"              }，              \"age\" : 18         };var output = Mustache.render(           \"name:{{name.first}} {{name.last}}，age:{{age}}\", data);console.log(output);返回：name:Chen Jackson，age:18 2、{{#keyName}} {{/keyName}}以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似if、foreach的功能。var data = {    \"stooges\" : [ {        \"name\" : \"Moe\"    }， {        \"name\" : \"Larry\"    }， {        \"name\" : \"Curly\"    } ]};var output = Mustache.render(\"{{＃stooges}}<b>{{name}}</b>{{/stooges}}\"，                 data);console.log(output);返回：<b>Moe</b><b>Larry</b><b>Curly</b>3、{{^keyName}} {{/keyName}}该语法与{{#keyName}} {{/keyName}}类似，不同在于它是当keyName值为null, undefined, false时才渲染输出该区块内容。比如：var data = {             \"name\" : \"<br>weChat<br>\"         };    var tpl = ‘{{^nothing}}没找到 nothing 键名就会渲染这段{{/nothing}}’;    var output = Mustache.render(tpl, data);返回：没找到 nothing 键名就会渲染这段 4、{{.}}    {{.}}表示枚举，可以循环输出整个数组，例如：var data = {    \"product\": [\"Macbook \",\"iPhone \",\"iPod \",\"iPad \"]}var tpl = '{{#product}} <p>{{.}}</p> {{/product}}';var html = Mustache.render(tpl, data);返回：<p>Macbook </p> <p>iPhone </p> <p>iPod </p> <p>iPad </p> 5、{{!  }}表示注释6、{{>partials}}以>开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。"}
{"title": "微信小程序官方文档个人分析心得 ", "author": "天下雪", "pub_time": "2016-10-19 15:20", "content": "首先从官方文档给的框架说起,微信小程序官方文档给出了app.js, app.json, app.wxss. 先从这三个文件说起.  - app.js 这个文件是整个小程序的入口文件,开发者的逻辑代码在这里面实现,同时在这个文件夹里面可以定义全局变量. - app.json 这个文件可以对小程序进行全局配置,决定页面文件的路径,窗口表现,设置网络超时时间,设置多tab等. - app.wxss 是小程序的公共样式表.(为了适应广大的前端开发者，我们的 WXSS 具有 CSS 大部分特性。 同时为了更适合开发微信小程序，我们对 CSS 进行了扩充以及修改。)接着我们就结合官方给出的代码具体说一下上面提到的三个文件.首先说的是配置文件app.json.下面是官方给出的例子.{\"pages\": [ \"pages/index/index\", \"pages/logs/index\" ],\"window\": { \"navigationBarTitleText\": \"Demo\" },\"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" }] }, \"networkTimeout\": { \"request\": 10000, \"downloadFile\": 10000 },\"debug\": true}官方给出了app.json五个配置项列表.(pages(Array), window(Object), tabBar(Object), networkTimeout(Object), debug(Boolean)),接着我们就详细的分下一下这几个配置项.pages它的作用是配置小程序的页面,这个配置项是必填的,它接受一个数组,里面的每一项都是字符串,从上面给出的代码: \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ] 可以看出,每一项分别对应的都是实现文件的路径以及他的文件名. 注意:这个配置里面的第一行配置是它的初始页面,例如上面代码的初始页面就是indexwindow这个配置项是用来设置小程序的状态栏、导航条、标题、窗口背景色。他给出了六个属性(navigationBarBackgroundColor(HexColor), navigationBarTextStyle(String-(black,white)), navigationBarTitleText(String), backgroundColor(HexColor), backgroundTextStyle(String-(dark,light)), enablePullDownRefresh(Boolean)),开发者可以根据自己的需求来进行配置.我们详细说一下这几个属性分别的功能: navigationBarBackgroundColor 它是用来设置导航栏背景颜色,这个属性要输入的是十六进制颜色值.navigationBarTextStyle 它是用来导航栏标题颜色的,它的输入类型是字符串(String),但是现在官网给出的文档目前仅支持(black和white)这两种颜色. navigationBarTitleText 这个属性是显示导航栏标题内容的,开发者可以根据自己的需要来进行设置. - backgroundColor 这个属性是设置窗口的背景色的,它需要输入的也是十六进制颜色值的. backgroundTextStyle 这个属性我的理解是设置窗口内容的样式的,官方给出的标准说明是下拉背景字体、loading 图的样式,这个属性同navigationBarTextStyle属性一样目前仅支持两种颜色(dark和light). enablePullDownRefresh 这个属性是设置是否开启下拉刷新,默认是开启的,注意: 在这个配置文件(app.json)中如果关闭了下拉刷新,当你在你自己开发的页面中想要设置下拉刷新也是行不通的,也就是说如果你想要在以后页面中使用下拉刷新这个功能,就必须保证这个配置文件中的这一项设置是打开的.上面给出的示例代码:{\"window\":{ \"navigationBarBackgroundColor\": \"#ffffff\",           \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\",\"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\"          }}显示出来的效果是这样的:tabBar这个配置项是用来配置页面底部的tab栏的,开发者可以根据自己的需求来进行配置.注意: tabBar是一个数组,只能配置最少2个,最多5个,而且tab栏的顺序是按照数组的排序来的.tabBar官方给出了一下五个属性(color(HexColor), selectedColor(HexColor), backgroundColor(HexColor), borderStyle(String), list(Array) ).接下来说说我对这五个属性的理解: color 设置tab上的文字默认颜色 selectedColor 设置tab上的文字选中的颜色 backgroundColor 设置tab的背景颜色 borderStyle 设置边框的颜色,现在仅支持(black和white)上面这四个属性就是按照官方给出的API来设置就可以,下面说一下list属性.list属性接受的是一个数组(Array),在list下面配置的每一项都是一个对象,他们都有以下这四个属性(pagePath(String), text(String), iconPath( String), selectedIconPath(String)).pagePath 这个定义的是页面的路径,但是这个属性定义的路径必须是在pages上定义过的.text 设置的是按钮上的文字iconPath 是定义icon图片的路径,这个属性定义的图片大小不超过40kb selectedIconPath 定义的是当选中按钮之后显示的图片,同样图片的大小不能超过40kb.下面是官方给出的效果图:networkTimeout它是用来设置各种网络请求的超时时间的,单位是毫秒,官方给出了四个属性(request, connectSocket, uploadFile, downloadFile)这四个属性分别定义的是wx.request, wx.connectSocket, wx.uploadFile, downloadFile 这四个API的超时时间.debug如果在app.json将debug配置为true,那么在开发者工具的控制台面板中可以输出详细的调试信息.以上就是根据官方给出的文档,我学习之后对app.json配置一些心得,下面我们在看一下app.js 这个文件.可以看到app.js这个文件的后缀是js,没错,微信小程序的开发框架在逻辑层用的语言就是JavaScript.但是微信小程序也在JavaScript的基础上做了一个修改,可以称之为一个新的轮子.这个框架可以使开发者更加方便的调用一些微信的功能,例如扫一扫,微信支付等一些微信特有的功能.我们接着回到app.js这个文件中来,其他的稍后再说.这个文件是整个小程序的入口文件,也可以说是控制整个小程序生命周期的文件,那么我们就不难想象,我们在这个文件中应该实现的几个功能,首先我们肯定需要对整个程序进行注册,正好微信给我们提供了一个app()来实现对整个程序的注册,同时app()里面还实现了对小程序生命周期的监控函数(onLaunch, onShow, onHide), 其中onLaunch是监听小程序初始化,当初始化完成时会触发onLaunch,当然这个函数是全局只触发一次.onShow是监听小程序的显示,在小程序启动时候,或者当你从后台进入到前台的时候就会触发这个函数.而onHide函数是监听小程序的隐藏的,当你从前台切换到后台的时候,会触发onHide.有了这些一个小程序的实例基本上算是完成了,当然为了让开发者加入更多自己的逻辑,微信还提供了让开发者在app()中加入自己的逻辑,开发者可以可以添加任意的函数或数据到 Object 参数中，用 this 可以访问.注意:app()只能定义在app.js中,而且不能注册多个.当在app.js中注册了实例之后,如果你想在自己的逻辑页面调用它,你可以用getApp()这个全局函数,这样你就可以全局调用app()里面的数据.微信给出的官方代码如下:var appInstance = getApp()console.log(appInstance.globalData) // I am global data注意:getApp()获取里实例之后,不要私自调用生命周期函数. 而且不要在app.js中用getApp()函数,用this就可以调用app()里面的东西. 基本上app.js就这些东西,还有一些API里面的内容会在后面一一介绍.下面我们就看一下app.wxss这个文件,一般来说做过网站开发的(我自己是用php来开发的,这是我个人的一点拙见,如有不对请见谅)相信对css写在单独的文件中应该不会陌生,这个app.wxss也是类似的,不过他的的配置是针对全局的,也就是说如果你在后面的page中没有重新配置他,那么他就会调用这个文件中的样式设置,但是如果你有个人需求,需要在每个页面重新写样式,那也没关系,他会自动覆盖宰割文件中的样式. 当你重新创建一个微信小程序他就会出现这几个文件,以上是我结合官方文档对他们的一些理解,接下来就是page的逻辑,视图,配置的一些心得.page这一块就是开发者自己的业务实现文件了. 每一个页面可以放在一个文件夹中,这个文件夹中一般包括.js, .json, .wxml, .wxss 这四个文件,微信官方还建议这四个文件的名字最好和文件夹的名字一致.这个便于框架自动查找,不需要做更多的配置. 当你开始做页面的功能的时候这个时候在.js,也需要注册,微信官方给出Page()这个函数来注册一个页面,他接受一个object参数,用其来指定页面的初始数据,生命周期函数,事件处理函数.需要注意的是当你在注册这个页面的时候要确定在最开始的app.json这个配置文件中已经配置过这个页面,而且当你对程序有所改变的时候也要确保app.json这个文件中的内容也随之相应改动.微信给Page()函数一下几个属性(data(Object), onLoad(function), onReady(Function), onShow(Function), onHide(Function), onUpload(Function), onPullDownRefresh(Function)),而且你也可以添加任意函数或者数据到object参数中,在这个页面用this即可访问.下面就简单的介绍一下这几个官方给出的属性: data - 实现页面的初始化数据 onLoad - 是生命周期函数,用来监听页面加载,一个页面只会调用一次,它的参数可以获取wx.navigateTo和wx.redirectTo及< navigator/>中的query. onReady - 同样是生命周期函数,用来监听页面初次渲染完成,一个页面只会调用一次,代表页面已经准备妥当,可以和视图层进行交互.对页面的设置请在onReady之后设置,如wx.setNavigationBarTitle. onShow - 生命周期函数,用来监听页面显示,每次页面打开都会调用一次. onHide - 生命周期函数,监听页面隐藏'',当wx.navigateTo或者底部tab切换之后调用. onUpload - 生命周期函数,用来监听页面卸载.当wx.navigateTo和 navigateBack的时候调用. onPullDownRefresh - 页面相关事件处理函数,用来监听用户的下拉动作.但是需要在config的window选项中开启enablePullDownRefresh,当数据刷新完成之后,可以用wx.stopPullDownRefresh停止当前页面的下拉刷新. 下面是微信给出的官方代码:Page({     data: {         text: \"This is page data.\"     },     onLoad: function(options) {     // Do some initialize when page load.     },     onReady: function() {       // Do something when page ready.     },     onShow: function() {     // Do something when page show.     },     onHide: function() {         // Do something when page hide.       },     onUnload: function() {         // Do something when page close.     },     onPullDownRefresh: function() {     // Do something when pull down       },     // Event handler.     viewTap: function() {       this.setData({ text: 'Set some data for updating view.'     })   }})上面说了用data属性来设置页面的初始化数据,但是如果我们想改变数据里面的值,怎么办??那么我们就介绍一个微信官方给我们提供的setData()函数,这个函数可以将数据从逻辑层发送到数据层,同时还可以改变this.data的值.setData()接受一个对象参数,让数据以key,value的形式表示将this.data中key对应的值改变成value.下面是微信官方给出的page的生命周期的图片:在小程序中的所有页面路由全部由框架进行管理,对于路由的触发方式以及页面的生命周期函数可以通过调用API来进行..下面我们就简单的介绍一下微信小程序的API.微信小程序框架给我们提供了丰富的微信原生API,可以方便的调用微信提供的能力,如获取用户信息,本地存储,支付功能等.下面是微信关于API提供的说明:wx.on 开头的API是监听某个事件发生的API接口,接受一个CALLBACK函数作为参数,当事件触发时,会调用CALLBACK函数. 如未有特殊约定,其他API接口都接受一个object作为参数. OBJECT 可以指定success,fail,complete来接受接口调用结果.OBJECT参数API的具体调用请看 微信小程序API文档因为现在微信小程序还在内测期间,我也没有内测号,所以具体的调用API代码需要在微信小程序开放之后,根据具体的逻辑进行实现.而且微信API文档已经给的非常清楚,相信调用不会太过困难.上面的这些就是微信小程序page的页面注册以及API功能实现，但是我们知道光有这些是不够的，在互联网发展到现在我们更加注重的是人机交互，让用户有一个更好的体验才算是 一个好的程序，那么接下来我们就讲讲微信小程序是如何对页面进行渲染的。在微信小程序中采用了微信自己原生的渲染方式。微信小程序的页面布局采用的是wxml，然后结合基础组件，事件系统构建出来页面的结构。wxml中有数据绑定，条件渲染，列表渲染， 模版，事件， 引用这几种方式，下面我们就具体说说这几种方式。数据绑定 在上面我们已经说过了在Page()注册页面的时候，里面会有一个data属性来定义初始化数据，现在页面渲染的数据绑定的时候就需要调用data里面的数据了。下面看一下官方给出的例子。<view> {{ message }} </view>Page({ data: { message: 'Hello MINA!' }})从上面的代码可以看出来在视图层接受逻辑层的代码的时候需要用2个大括号把数据的键值包起来就可以得到数据的值。当然在视图层还可以进行运算（三元运算，算术运算），逻辑判断，字符串运算，而且还可以在大括号里面进行组合（数组，对象（虽然可以随意组合，但是如果后面的变量名和前面的变量名相同的话，那么后面的会覆盖前面的））。条件渲染 顾名思义所谓的条件渲染，就是通过条件来判断是否需要渲染该代码块。条件渲染主要是用到wx:if 和 block wx:if 这两个，第一个相信好理解，第二个是在block里面进行条件渲染，这里我们特别说明一下< block/>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。和我们以前的逻辑编程类似，既然有了wx:if ，那么我们也会有wx:elseif和wx.else，这几个组合起来，可以使条件渲染更加灵活。在这里官方文档中提到了一个wx:if和hidden的对比，通过合理的运用这两种方法可以使你的程序更优。下面我们就是说说他们俩的区别：因为wx:if之中也可能包含数据绑定，所以当wx:if的条件值切换时，框架有一个局部渲染的过程，他会确保条件在切换是销毁或者重新渲染。同时wx:if也是有惰性的，如果初始渲染条件为false,框架什么也不会做，只有在条件第一次变为真的时候才会开始渲染。相比之下hidden就简单的多，组件始终都会被渲染，只是简单的控制显示和隐藏，一般来说，wx：if 有更高的切换消耗，而hidden有更高的初始渲染消耗，你可以根据自己的需求来调用。列表渲染 -- wx:for下面我们就说说wx:for的用法，wx:for绑定一个数组，就可使用数组中各项数据重复渲染该组件，注意默认数组的当前项的下标变量名默认为index，数组当前项的变量名为item，，当然你也可以根据自己的需要来重新定义这两个名字，使用wx:for-item可以指定数组当前元素的变量名，wx:for-index可以指定数组当前下标的变量名，wx:for也可以嵌套，这个时候就需要改变默认框架给定义的名字了。下面是官方给出的事例代码：<view wx:for=\"{{items}}\"> {{index}}: {{item.message}}</view>Page({ data: { items: [{ message: 'foo', }, { message: 'bar' }] }})<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">   {{idx}}: {{itemName.message}}</view>模版WXML提供模版(template),可以在模版中定义代码片段,然后在不同的地方调用.微信小程序的模版可以用name来命名它的名字,在使用的时候用is来声明使用的模版,然后将模版所需要的data传入即可,下面我们用官方文档给的代码来看一下如何声明及调用模版.<!--  index: int  msg: string   time: string--><template name=\"msgItem\">   <view>     <text> {{index}}: {{msg}} </text>     <text> Time: {{time}} </text>   </view></template>上面这段代码可以看到模版的名字是\"msgItem\".<template is=\"msgItem\" data=\"{{...item}}\"/>在调用的时候使用方法如上,在is属性加上模版的名字即可.后面还有一个data属性,并且在里面还加入数据,下面我们就看一下下面这段代码.Page({ data: { item: { index: 0, msg: 'this is a template', time: '2016-09-15' } }})<template name=\"odd\">   <view> odd </view></template><template name=\"even\">   <view> even </view></template><block wx:for=\"{{[1, 2, 3, 4, 5]}}\">   <template is=\"{{item % 2 == 0 ? 'even' : 'odd'}}\"/></block>通过上面对条件渲染的介绍,我们可以看到在循环掉数组[1,2,3,4,5]之后item数组属性在三元运算中判断调用哪一个模版.在这儿再多说一句模版也有自己的作用域,只能使用data传入的数据,当然data传入的数据可以是你自己新建的数据,也可以是你在配置中写好的初始化数据.好了现在我们说完模版了,可能有的同学就该想了,我写好模版之后该如何调用它,如果他们是在一个页面那肯定没问题,但是这样的话可用性还是很差啊,如果我想把模版单独放在一个页面,在调用它的时候该怎么办啊?没关系,微信小程序早就考虑到了,那么我们接下来就说说引用.引用WXML提供两种引用方式import和include.接下来我们就先说说import这种方式,我们就结合代码来看,它调用在不同页面的模版消息如下:<!-- item.wxml --><template name=\"item\">   <text>{{text}}</text></template>在 index.wxml 中引用了 item.wxml，就可以使用item模板：<import src=\"item.wxml\"/><template is=\"item\" data=\"{{text: 'forbar'}}\"/>这里要注意一下,import引用也是有作用域这个概念存在的,它只会定义import目标文件中定义的template,而不会import目标文件import中的template.简而言之就是import只能引用template而不能引用import.上面说了import是如何引用的,那么我们接着看一下include是怎么引用的.include引用和import唯一不同点就是他的引用相当于复制,他会复制< template>里面的全部内容,但是不包含< template>,看一下代码相信你可以理解的更加明白.<!-- index.wxml --><include src=\"header.wxml\"/><view> body </view><include src=\"footer.wxml\"/><!-- header.wxml --><view> header </view><!-- footer.wxml --><view> footer </view>上面我们说的视图层这些方法已经可以构成一个静态的页面了,但我们现在是21世纪啊,一个没有人机交互的程序怎么能在这个世界生存下来了?在用户体验至上的今天,微信小程序不可能不考虑到这一点,接下来我们就说说视图层的事件方法.先来说说什么是事件,相信有的人看到这儿肯定是一脸懵逼,你这说的啥玩意儿,说的这么专业,我还不如看文档去.那么我们就说说什么是事件. 事件就是一种页面到逻辑层的通讯方式,比如说你的操作想得到机器的反馈,这时候就用到事件了.事件可以将用户的行为反馈到逻辑层进行处理. 说到这儿不禁又有一个问题,那他是怎么用的呢? 事件可以绑定到组件上,当触发事件,就会执行逻辑层对应的事件处理函数,当然为了更加方便人机交互,用户还可以携带额外的信息,如id,data等.可能有人看完刚才的一段就说了,好了,你刚才说的事件解释的差不多了,可是你为什么有冒出一个组件,这让我这么理解?既然说到组件了,我们就先简单的了解一下,在之后的组件板块再详说,先保证大家能看懂什么是事件就好了.为什么要有组件呢?组件是框架为了开发者进行快速的开发而设计的.那什么是组件呢? 组件是视图层的基本组成单元,在微信小程序中组件自带一些功能与微信风格的样式,一个组件通常包括开始标签和结束标签,属性是用来修饰这个组件,内容在两个标签之内.<tagname property=\"value\"> Content goes here ...</tagename>在这里需要注意一点,组件和属性都是小写,并且以\"-\"进行连接.简单的介绍一下组件,那我们继续说事件.事件分为冒泡事件和非冒泡事件,冒泡事件是当一个组件上的事件被触发后,该事件会向父节点传递,而非冒泡事件则不会.现在微信小程序给出的冒泡事件仅仅有6个(touchstart,touchmove, touchcancel,touchend,tap, longtap),下图是他们分别对应的触发条件.冒泡事件类型剩下的都属于非冒泡事件.接下来我们就说说事件怎么用?事件是通过事件绑定来实现的.它的写法是以key,value的形式来写的.key以bind 和catch 开头,然后跟上事件的类型. value 是一个字符串,需要在对应的page中定义同名的函数,不然当触发事件的时候会报错.(bind 事件绑定不会阻止冒泡事件向上冒泡,而catch 可以阻止冒泡事件向上冒泡).说完了如何进行事件绑定了,我们再说说,当事件触发是逻辑层的事件处理函数会收到什么? 事件处理函数会收到一个事件对象. 那么这个事件对象里面都有什么属性呢?? 里面的属性有(type, timeStamp, target, currentTarget, touches, detail),下面是他们的一些说明:事件对象属性type得到的是通用事件类型,例如tap. timeStamp是页面打开到事件触发所经过的毫秒数. target触发事件的源组件,它包括事件源组件的id,data-开头自定义属性的组成的集合(dataset),以及他在坐标系统中的偏移量. currentTarget 触发事件的当前事件,它包括的内容与target相同.其他的属性按照上面的说明简单了解即可,在这里我们说一下target和currentTarget中的dataset,我们知道在组件中可以定义数据,这些数据会通过事件传递给 SERVICE书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。用一段代码来说话相信大家就更清楚了.<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>\r\n\r\nPage({ \r\n  bindViewTap:function(event){ \r\n    event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法 \r\n    event.target.dataset.alphabeta == 2 // 大写会转为小写 \r\n  }\r\n})我不知道大家感觉怎么样,要是我自己刚开始看我写的这一大段内容,我感觉我就该骂娘了,不是说么NO图NO BB,下面我就给大家上代码,相信看完之后事件这一块基本上就明白了.//视图层的事件绑定<view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>//逻辑层的事件处理函数Page({ \r\n  tapName: function(event) { \r\n    console.log(event)\r\n }\r\n})//逻辑层的事件处理函数输出的信息//逻辑层的事件处理函数输出的信息\r\n{\r\n\"type\": \"tap\",\r\n\"timeStamp\": 1252,\r\n\"target\": { \r\n  \"id\": \"tapTest\", \r\n  \"offsetLeft\": 0, \r\n  \"offsetTop\": 0, \r\n  \"dataset\": { \"hi\": \"MINA\" }\r\n},\r\n\"currentTarget\": { \r\n  \"id\": \"tapTest\", \r\n  \"offsetLeft\": 0, \r\n  \"offsetTop\": 0, \r\n  \"dataset\": { \"hi\": \"MINA\" }\r\n},\r\n\"touches\": [{ \r\n  \"pageX\": 30, \r\n  \"pageY\": 12, \r\n  \"clientX\": 30,\r\n  \"clientY\": 12, \r\n  \"screenX\": 112, \"screenY\": 151\r\n}],\r\n\"detail\": { \"x\": 30, \"y\": 12}}到这儿WXML的页面结构就说完了,接着我们简单说说WXSS就基本说完了.在WXSS中引入了新的 尺寸单位rpx 它规定1rpx=0.5px = 1物理像素WXSS的样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束.剩下的内容基本上和css相差不大,有兴趣的可以看一下官方文档WXSS"}
{"title": "教你如何在微信小程序中使用 Hprose ", "author": "天下雪", "pub_time": "2016-10-19 18:20", "content": "微信小程序 SDK 刚刚出来，就已经有一堆入门教程了。然而并没有关于如何在微信小程序中进行网络通讯的教程，所以我们今天就来讲一下新鲜出炉的独门绝技——hprose 如何在微信小程序中实现通讯。\r\n首先下载微信小程序开发工具，之后安装。\r\n然后按照网上那一堆微信小程序 Hello World 教程创建一个小程序。\r\n接下来我们下载 hprose-html5 或者 hprose-js。推荐使用 hprose-html5 版本，这个版本更小，支持二进制数据传输，而且更快。\r\n可以用 git clone 下载，也可以只下载 dist 目录下的文件，以 hprose-html5 版本为例：\r\nhprose-html5.src.js 是源码版本 hprose-html5.js 是压缩版本\r\n这两个版本都可以用。调试阶段建议用源码版本。但不要使用 hprose-html5.min.js 版本，这个版本是压缩版本的，不支持在微信小程序中编译。\r\n之后，你可以把它们复制到你创建的那个微信小程序的 utils 目录下（复制其中一个就可以），然后将它改名为 hprose.js（这一步可选，只为后面引用的时候，名称统一）。\r\n接下来，打开 pages/index/index.js 文件。\r\n在开头加上：\r\nvar hprose = require('../../utils/hprose.js');\r\n然后在 onLoad 事件中加入以下代码：\r\nvar client = hprose.Client.create(\"http://www.hprose.com/example/\", [\"hello\"]);client.hello(\"world\", function(result) {  console.log(result);});\r\n总体看上去是这样的：\r\n//index.jsvar hprose = require('../../utils/hprose.js');//获取应用实例var app = getApp()Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //事件处理函数  bindViewTap: function() {    wx.navigateTo({      url: '../logs/logs'    })  },  onLoad: function () {    console.log('onLoad')    var client = hprose.Client.create(\"http://www.hprose.com/example/\", [\"hello\"]);    client.hello(\"world\", function(result) {      console.log(result);    });    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据      that.setData({        userInfo:userInfo      })    })  }})\r\n然后点编译，运行，如果你的网络没有问题的，你会在调试控制台中看到：\r\n这里写图片描述\r\n好了，就这么简单，接下来，你就可以用 hprose 来做微信小程序开发了。"}
{"title": "微信小程序开发工具安装指南及注意事项 ", "author": "天下雪", "pub_time": "2016-10-19 19:02", "content": "这两天闲来无事，也安装了 “微信折叠”的开发工具来玩一下。以下是一些小道消息及使用体验，过两天我会写一篇文章以开发者的角度来详细评价微信小程序:微信小程序不能开发游戏类、直播类功能，小程序每个人关注的上限是20个（还不确定，不过我相信这是真的，这次公布的API里并没有视频组件。微信太大，苹果要有所顾忌，但是微信也要做出相应的让步)微信目前有没有同苹果商谈好，还是个未知数，毕竟会对AppStore有一定的冲击。抛弃了大量的javascript组件后，这个生态体系变得相当的封闭，微信解释肯定是：为了更好的性能提升。那么我们拭目以待。小程序的入口是微信里的三级菜单，就是在“Tab栏发现里的游戏下面加入一个“小程序”。反正，这一栏里的购物和游戏我是从来没点进去过的。以腾讯的尿性，小程序同服务号一样，其关系链及重要功能的开放程度会因“人”而异。对，优质的接口只会开放给腾讯的儿子们（滴滴呀、京东呀）微信从来就是一眼不合就封杀，优步就是很好的案例。官方解释是优步涉嫌诱导，滴滴同样被禁过。利益面前还讲道理？反正我是不信的。腾讯的投资覆盖各个行业，一旦腾讯掌握了应用分发入口，给儿子们一些小小的甜头，应该不是什么大事儿吧。有人说AppStore也有很多限制，但至少苹果并没有像腾讯这样大量的投资消费级App，直接产生利益冲突的点并不多。话说回来，这点创业者是不用考虑的，暂时，你的产品和创意，在微信眼里还是个蝼蚁。。。你不用担心受到不公正的对待。如果真有一天你被微信封杀了，只要不是因为违规内容，那么你应该高兴，然后迅速炒作一波…….很多做Web的朋友尝试在小程序里写div、ul等标签，别试了，没效果，包括JQUERY在内的DOM操作库，小程序内是不能运行的。小程序本质是JS+ReactNative，对RN底层做了重构，已经和dom说拜拜了。 下面是详细的安装步骤。win10下测试通过以下是安装步骤：按操作系统下载相应开发工具版本 windows 64位 windows 32位 mac 小程序示例组件demo下载双击安装打开微信web开发者工具添加一个项目，如图填写项目信息 注意AppId这里选择“无AppId”,AppID只有内测用户才有，无AppId在目前有功能限制，比如不能发布项目到手机微信中预览。点击“添加项目”按钮后，将创建一个小程序项目, 工具已经为你创建了一个demo —– Hello World开发者工具功能区域介绍工具左侧分别有编辑、调试、项目调试区按钮，分别解释3个区域的作用.。编辑： 是你写代码的地方，左侧的文件目录是微信为你创建的一个项目基础骨架，你可以在这个骨架上编写自己的业务代码。当我们编写完代码后，点击编辑视图左下角的“编译”即可进行调试和运行（当点击“编译后”，工具视图会自动跳转到第二个“调试”视图）调试: 是你调试代码的地方。整个界面同Chrome的调试工具一模一样（应该是内嵌了WebKit内核），相信有Web开发经验的同学很快就能上手。F8 运行到下一个断点、F10 单步运行、Ctrl+/ 注释代码。解释一下“调试”视图下，顶部的六个Tab栏（Console、Sources、Network、Storage、AppData、Wxml）： Console： 工具的输出区域，在程序中调用 console.log(‘测试一下console’), 可在这里输出自定义调试信息。同时，这里也是工具遇到异常和发出警告的信息输出区域。见图：  Sources: 源代码显示区域，这里你可以打断点并调试代码。Sources Pannel 用于显示当前项目的脚本文件，同浏览器开发不同，微信小程序框架会对脚本文件进行编译的工作，所以在 Sources Pannel 中开发者看到的文件是经过处理之后的脚本文件，同编辑区域的代码有稍许的差异，比如开发者的代码都会被包裹在 define 函数中，并且对于 Page 代码，在尾部会有 require 的主动调用。  Network: 用于观察和显示 网络的request 和 socket 的请求情况   Storage: 如果你在程序中使用了 wx.setStorage 或者 wx.setStorageSync 后，在这里将会显示你的数据存储情况。是的，小程序支持本地缓存数据。   AppData: 用于显示当前项目当前时刻 appdata 具体数据。可以在这里管理应用程序中的各类变量（不同于Storage中的缓存变量，只有调用wx.setStorage 或者 wx.setStorageSync 的数据才会出现在Storage中）。在这，你可以随时修改变量，工具将把变量改变在左侧预览视图中实时显示。我们可以看到，AppData 以页面（pages/index/index）作为分组单位，每个页面只会显示自己的AppData，非常的清晰。 Wxml：将Wxml标签同预览界面实时关联，在这里可以看到真实的页面结构以及结构对应的 wxss 属性，同时可以通过修改对应 wxss 属性，在模拟器中实时看到修改的情况。通过调试模块左上角的选择器，还可以快速找到页面中组件对应的 wxml 代码。最后说下“项目”这个功能区块儿， 项目实际上是用来上传和预览项目的。微信要求所有发布的小程序都必须审核，所以需要在这里将小程序上传（应该是类似于AppStore，但肯定不是AppStore的发布模式，苹果应该不会允许。小程序目前同用户的接触方式还是未知数，而这恰恰是最重要的一块儿）。如果你没有被内测邀请，这里你是不可以上传和预览项目的，也不可以真机运行小程序，所以真正的体验相对于原生App还是未知数。目前阶段，你只能熟悉一下小程序的API，以便在公测后迅速拿出自己的产品，抢夺第一波红利。总体来说，小程序的大概开发模式和模型 已经暴露，其本质是JS+RN，很多人说JavaScript程序员的春天来了，其实小程序的体系和Web开发还是有很多区别的。微信言下之意是要抛弃你们熟悉的DOM采用他的组件体系，更熟悉这种组件式开发的不是传统的Web前端，而是iOS开发人员（更早点你可以追溯到Flex和SilverLight），我本人是不喜欢这种非JS原生的组件式开发的，自由度会受限。后续，我会持续更新小程序的开发例子和教程，尽快帮助大家上手开发业务和产品。你现在需要做的，就是静心想想，我应该开发一个什么样的产品？"}
{"title": "zhi_chao：小程序进阶实战进阶：豆瓣电影demo布局搭建 ", "author": "天下雪", "pub_time": "2016-10-20 10:44", "content": "我们创建起了小程序项目，并粗浅的了解了小程序的外部项目结构，了解了 js，wxml，wxss都最基本运用，现在我们在进行循序渐进的深入探究，如何制作真实项目。先看效果图： 分析步骤：1、讲头部的视图滑动，简单2、讲底部的导航栏，简单3、讲中间的内容显示，中等4、讲JS逻辑实现。复杂难度等级的划分只局限于本文，不联系实际开发。 1、头部视图滑动，实例图：  准备工作先做好，创建一个项目，把系统自带的都删了 只留外层目录，内层文件都删了。  然后在pages中添加一个movie目录作为首页，分别在创建，js  \\  wxml  \\  wxss. ,并在app.json中注册 好了，现在我们开始编写wxml与js文件，首先我们确定头部显示要用什么组件，先看官方文档中的swiper-view控件（滑块视图组件）就用它了 在文档中找到这段并代码复制到 wxml中去 （复制后别忘了 Ctrl+s 保存） 然后复制这段代码到 js 文件去  好了我们可以去调试页面看看变化，用鼠标可以滑动，但它的显示有瑕疵有留白，我们去wxml中做一点改动。 在wxml中把width和height 两个属性去掉 ，改为： style = \"width:100%\"  。  {{}}中的内容是什么，看后面注解。 现在我们在去js中，把视图改为自动跳转的。 仔细看注释！ 豁然开朗了吧，文档也理解了吧! 完成以上步骤后，一个滑动视图算是初步的做好了，以后要做深入也只是把视图改为动态获取图片，而不是像现在这样指定了静态的链接，是不正确的， 当然你也可以做一些稀奇古怪的滑动视图没人拦你。从这里我们可以发现微信小程序开发，给我们带来的方便与高效，只要摸清楚文档，一个程序还是挺容易搭建的。  2、底部导航栏：打开官方开发文档文档配置篇 把这段复杂过来，要注意我们要把路径改为刚刚创建的movie文件目录，然后去网上找一下log资源放到image文件中去.在文档配置篇中找一下iconPath和selectedIconPath看看他们是干嘛的！底部导航栏就完成了，看下面的代码也能不难。 完成后的效果：  现在开始进入下一个阶段，先看效果图  简单的分析下，一个图片控件image，在加一个文字控件text，接下来的排版就需要交给wxss和<view>进行配合搭建，而不是单纯的只使用image和text，使用<view包裹，在利用wxss进行编排在刚刚的，image目录中，放一张图片进去先，我放了 “我老婆的照片”MD美死了！！！ 然后在wxss中做一些准备 ，其实这步骤是不对的，但如果联系wxml边写边做wxss的样式，要截的图就多的离谱了，所以我想，直接给wxml和wxss写好的布局，让你自己去琢磨分析也有相同的效果，毕竟我已经给出很详细的注解了，不至于看晕。/** 占满全屏**/.content{height: 100%;}/** 将图片与文字左右分开 **/.movie{display: flex;flex-direction: row;}/** 设置图片大小 **/.pic image{width: 100px;height: 150px;}/** 设置与左边图片的间距**/.movie-info{padding-left: 20px ;}/** 文字大小与行高 **/.base-info{font-size: 12px;padding-top: 20px;line-height: 20px;}/** 分割线 **/.hr{height: 2px;width: 100%; border-top: wheat solid 1px;border-bottom: wheat solid 1px;opacity: 0.2;}wxml中的布局，就让您自己去打吧，不然学习就失去效果了，要注意的是我的<view> 是上下呼应的为了能让你看清楚，它的结束语句在哪里，占满全屏的view它的结束语句必须包裹所有内容。我把要讲的内容放在注解里了，写完保存直接去调试页面看效果。 粗略的布局总算是搭建好了，后面就是联系API获取数据，在js中做一些逻辑操作了。 以上归纳概述：<view> 用来做排版， 组件负责接收数据并显示。现在要开始编写JS文件了，这里就有点麻烦，毕竟代码量还挺多的，你可以先休息一会儿，把wxml和wxss先消化一下"}
{"title": "zhi_chao：小程序进阶实战进阶：豆瓣电影demoJS逻辑篇 ", "author": "天下雪", "pub_time": "2016-10-20 11:08", "content": "双大括号是{{}}用来JS和wxml绑定事件的，比如，数据更新，显示规则，等等的一些有规则有章法的操作。那么我们就需要引用这种机制，为我们的image和text控件做数据更新的操作。很好知道这点，后面的事情都交给JS去完成。现在开始，分析步骤，（前面三步为一体，第四步则分出来讲。）1、首先要有一个函数用来向网络发送请求这一步看官方文档发送请求2、关注文档中的三个关键字，url、header、success,url，就不多说了网络请求，不了解的必须先了解一下header，不熟悉HTTP协议的朋友，在看到文档中这个属性时一定会迷惑看的云里雾里的，他是将网页中的内容进行解析比如文档中的 header 方法中的代码：'Content-Type':'application/json' 是把内容解析为json格式的，如果把它换成'Content-Type':'application/xml' 那么它就会将网页的内容解析为xml格式的，现在你应该明白了，json是微信自己指定的文件格式，我们按照它的写法就可以了，so等会直接复制过来使用。success，读取数数据用的函数、（看文档时看他的类型Function）3、（这一步的操作对后面的理解有些许帮助）豆瓣电影API 我们分别要使用到他的 ， 正在热映 ，Top250 , 电影搜索，三个接口。https://api.douban.com/v2/movie/in_theaters 查看接口 以正在热映为列 由于此页面的内容太复杂，我们可以做一些简化打开此链接，按F12出现调试框，将页面中的所有内容复制，而后在调试框中输入 var a = 将复制的内容粘贴在等号后面，回车，然后输入 a 回车，现在此页面的内容就有条理了。4、有了以上步骤思路，最后要想到，数据的读取，以及数据格式处理（这里的格式化与header不同，我们是将数据格式化编排给用户看的）。so：我们需要两个函数，一个用来循环遍历读取网络数据，另一个则把数据格式化。由于这两个函数的也可以为后面top250的页面使用，所以我使用封装把他们俩封装起来供后面的逻辑使用。5、把数据在wxml中进行关联。有了这四步的思路，我们开始看JS代码的实现。（我怕你已经晕了！别急有了前面的步骤做铺垫我想你看起代码来会更得心应手。）由于前三步相对简单所以先从第四步的两个函数开始说 ：在Utils中创建subjectUtills.js (文件名不是固定的。)  接下来在 写第一个循环获取数据的函数。  现在来写数据格式的函数，由于代码有点多就想着给你节约点时间下面给出可复制的文字。// 获取数据并格式function provessSubject( subject ) {//电影名var title = subject.title;//导演信息var directors = subject.directors;var directorStr = \"\";for( var index in directors ) {directorStr = directorStr + directors[ index ].name + \" / \";}if( directorStr != \"\" ) {directorStr = directorStr.substring( 0, directorStr.length - 2 );}//演员信息var casts = subject.casts;var castStr = \"\";for( var index in casts ) {castStr = castStr + casts[ index ].name + \" / \";}if( castStr != \"\" ) {castStr = castStr.substring( 0, castStr.length - 2 );}//类型信息var genres = subject.genres;var genreStr = \"\";for( var index in genres ) {genreStr = genreStr + genres[ index ] + \" / \";}if( genreStr != \"\" ) {genreStr = genreStr.substring( 0, genreStr.length - 2 );}//发行的年份var year = subject.year;//将数据格式化var text = \"名称：\" + title + \"\\n导演:\" + directorStr + \"\\n演员:\" + castStr + \"\\n类型:\" + genreStr + \"\\n上映年份:\" + year + \"(中国大陆)\"//拿到格式化的数据subject.text = text;}模块化（封装） 最后不要忘记封装 完成了这两个函数，现在我们来写网络请求的逻辑代码 第五步，完成wxml中的数据关联。注意 {{item.images.medium}} 这串代码 和  {{item.text}} 后面细讲。这里添加了block循环和loading组件。 讲一下{{item.images.medium}} ， 而 {{item.text}}应该不用多讲就是我们格式化的数据。使用第三步的操作 你会得到这样的页面，看了之后你应该就不明觉厉了， 首页差不多就写好了现在看一下效果怎么样。 写到这里一个展示区差不多就写好了，后面还要继续深入。"}
{"title": "微信小程序把玩《五》：checkbox组件，form组件，input组件 ", "author": "天下雪", "pub_time": "2016-10-20 13:06", "content": "一：checkbox组件不得不吐糟下checkbox默认样式真是有点略丑！！！checkbox组件为一个多选框被放到checkbox-group组中，并在checkbox-group（只能包含checkbox）中设置监听事件。checkbox-group监听方法：checkbox多选属性：wxml<!--checkbox-group就是一个checkbox组 有个监听事件bindchange，监听数据选中和取消--><checkbox-group bindchange=\"listenCheckboxChange\"><!--这里用label显示内容，for循环写法 wx:for-items 默认item为每一项-->    <label style=\"display: flex;\"  wx:for-items=\"{{items}}\">    <!--value值和默认选中状态都是通过数据绑定在js中的-->        <checkbox value=\"{{item.name}}\" checked=\"{{item.checked}}\"/>{{item.value}}    </label></checkbox-group>jsPage({    /**     * 初始化数据     */  data:{    items: [        {name: 'JAVA', value: 'Android', checked: 'true'},        {name: 'Object-C', value: 'IOS'},        {name: 'JSX', value: 'ReactNative'},        {name: 'JS', value: 'wechat'},        {name: 'Python', value: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nxiaochengxu123\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发工具安装指南及注意事项 \n              微信小程序简易全攻略《一》开始构建与创建页面 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《六》：picker组件，radio组件，slider组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155865|b23faecf2c15bda848da65397d9c7d95|2';"}
{"title": "微信小程序简易全攻略《一》开始构建与创建页面 ", "author": "天下雪", "pub_time": "2016-10-20 14:23", "content": "一：开始构建最近微信小程序开始火起来了，虽然还没开放公测，但是开发工具，本地环境却是可以构建了废话不多说，直接进入正题；1. 首先下载工具https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1474632113_xQVCl&token=&lang=zh_CN点击上面的链接 找到小程序开发者工具 点击下载 对应版本，傻瓜式的安装不必细述2. 构建小程序安装完成后  双击 打开应用  打开微信并扫描 确认登录即可点击添加项目选择 无 AppID  -->  填写项目名称 -->  选择项目目录（没有的话可以先创建一个空文件夹） --> 点击 添加项目欧了  简单的 hello world 就创建好了二：创建页面好了 hello world 创建好了 ，咱开始写页面了，那么如何创建一个简单的页面呢，废话不多说，开始撸代码新建一个页面需要以下几步，1. 在pages 中添加一个目录（当然如果你觉得写在现有的目录里面就好 那这一步就省略啦）点击左侧的 编辑  -->  点中 pages 文件夹  -->   点击右上角的  +  号  --> 在下拉菜单中选择 目录  --> 弹出框中 填写目录 名称 （这里我们写了test）--> 点击 确定2. 新建一个wxml 文件选中 test  文件夹 --> 点击 右上角  + 号  --->  选择  wxml 类型 文件  --> 填入文件名  （注意 这里必须填写 后缀名 至少 我的版本是必须填入的）3. 编辑test.wxml 文件为了方便测试 我们随便 填写点内容进去[html] view plain copy<view class=\"container\">      <text>这是我的test页面哦哦！！！</text>  </view>  4. 创建test.js文件使用同样的方法在test 目录下创建一个 test.js 文件[javascript] view plain copy//test.js  //获取应用实例  var app = getApp()  Page({    data: {      userInfo: {}    },    onLoad: function () {      console.log('onLoad test');    }  })  5. 将test 页面加入 app.json在pages 属性中 加入一条 test 页面所在的目录 这里是相对路径 首部不必填写 /6. 在首页加入访问链接好了 上面路径也加好了 我们得加个入口 才能看到自己写的页面啊 ， 小程序的首页一般是默认显示 pages 属性中的第一条路径所指向的页面  ，如果我们不想破坏原有的 那么 我们直接找到首页  pages/index/index.wxml  添加一个链接[html] view plain copy<view class=\"btn-area\">     <navigator url=\"/pages/test/test\" hover-class=\"navigator-hover\">跳转test页面</navigator>   </view>  7. 访问一且准备就绪 ，点击左下角的 “编译”，出现如下 页面 然后 点击 “”跳转test页面“”哇哈哈，看到了没，你的页面做好了！！！（注意所有页面编辑后 请按 ctrl + s 保存键）"}
{"title": "微信小程序简易全攻略《二》设置页面标题与底部导航 ", "author": "天下雪", "pub_time": "2016-10-20 14:33", "content": "一：设置页面标题页面写好了，总感觉哪里不爽，对，就是那，每个页面的标题都一样，都是 Wechatcou 呀 真cou, 那咱就单独说说，如何设置 页面标题。设置页面标题 ，相当的简单，找到所在页面的目录，新建一个 json 文件，比如我们上一次建造的 test 页面我们  找到 pages/test/ 目录 新建一个 test.json 文件 加入如下代码{    \"navigationBarTitleText\": \"霸气侧漏\"  } view plain co效果如下：二：设置底部导航好了 小程序的头部标题 设置好了，我们来说说底部导航栏是如何实现的。我们先来看个效果图这里，我们添加了三个导航图标，因为我们有三个页面，微信小程序最多能加5个。那他们是怎么出现怎么着色的呢？两步就搞定！1. 图标准备阿里图标库  http://www.iconfont.cn/collections/show/29我们进入该网站，鼠标滑到一个喜欢的图标上面  点击下方的 下载按钮在弹出框中 选择了 俩个不同颜色的 图标  选择64px大小即可，我选择的是png  然后下载下来 起上别名 将上述起好名字的图标 保存到 小程序 项目目录中 新创建的 images 文件夹中，准备工作就做好了2. 更改配置文件我们找到项目根目录中的配置文件 app.json 加入如下配置信息 \"tabBar\": {    \"color\": \"#a9b7b7\",    \"selectedColor\": \"#11cd6e\",    \"borderStyle\":\"white\",    \"list\": [{      \"selectedIconPath\": \"images/111.png\",      \"iconPath\": \"images/11.png\",      \"pagePath\": \"pages/index/index\",      \"text\": \"首页\"    }, {      \"selectedIconPath\": \"images/221.png\",      \"iconPath\": \"images/22.png\",      \"pagePath\": \"pages/logs/logs\",      \"text\": \"日志\"    }, {      \"selectedIconPath\": \"images/331.png\",      \"iconPath\": \"images/33.png\",      \"pagePath\": \"pages/test/test\",      \"text\": \"开心测试\"    }]  },解释一下 对应的属性信息tabBar  指底部的 导航配置属性color  未选择时 底部导航文字的颜色selectedColor  选择时 底部导航文字的颜色borderStyle  底部导航边框的样色（注意 这里如果没有写入样式 会导致 导航框上边框会出现默认的浅灰色线条）list   导航配置数组selectedIconPath 选中时 图标路径iconPath 未选择时 图标路径pagePath 页面访问地址text  导航图标下方文字如果要改变更详细的样式 请参看https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabBar好了，保存 编译  就可以看到上面的效果了。"}
{"title": "微信小程序简易全攻略《三》创建轮播图与数据请求，表单的创建、提交、与接收 ... ", "author": "天下雪", "pub_time": "2016-10-20 15:04", "content": "一：创建轮播图应用中最常见的就是轮播图了，今儿个就讲讲微信小程序中轮播图的使用轮播图，不外乎俩个要素，跳转链接 和 图片地址1. 设置数据我在 pages/test/test.js中添加如下数据//test.js//获取应用实例var app = getApp()Page({  data: {      imgUrls: [       {          link:'/pages/index/index',          url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'        },{          link:'/pages/logs/logs',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'        },{          link:'/pages/test/test',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'        }     ],    indicatorDots: true,    autoplay: true,    interval: 5000,    duration: 1000,    userInfo: {}  },  onLoad: function () {    console.log('onLoad test');  }})其中 imgUrls 是我们轮播图中将要用到的 图片地址和 跳转链接indicatgorRots 是否出现焦点autoplay  是否自动播放interval  自动播放间隔时间duration 滑动动画时间更多样式编辑请参看文档  https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html?t=14750520542282. 部署到页面找到 文件 pages/test/test.wxml<swiper indicator-dots=\"{{indicatorDots}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">      <block wx:for=\"{{imgUrls}}\">        <swiper-item>           <navigator url=\"{{item.link}}\" hover-class=\"navigator-hover\">            <image src=\"{{item.url}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>           </navigator>         </swiper-item>      </block></swiper>注意： swiper 千万不要在外面  加上任何标签 例如 <view> 之类的 ，如果加了可能会导致轮播图出不来3. 添加页面样式创建文件 pages/test/test.wxss.slide-image{      width: 100%;  }  加上上面的样式可以使 轮播图的宽度达到100% 然后更漂亮点，当然可以根据自己的喜好罗！看效果二：数据请求 表单的创建 提交 与接收开始正题了，本节小小研究了下 微信小程序的表单创建与提交先看看效果1. 表单页面<view id=\"adduser\">    <form bindsubmit=\"formSubmit\" bindreset=\"formReset\">         <view class=\"section\">            <view class=\"section__title\">姓名:</view>            <view class='form-group'>                <input type=\"text\" class=\"input-text\" name=\"username\" placeholder=\"请输入姓名\" />            </view>            </view>        <view class=\"section section_gap\">            <view class=\"section__title\">年龄:</view>            <view class='form-group'>                <slider name=\"age\" show-value ></slider>            </view>            </view>        <view class=\"section section_gap\">            <view class=\"section__title\">性别:</view>            <view class='form-group'>                <radio-group name=\"gender\">                  <label><radio value=\"1\"/>男</label>                  <label><radio value=\"0\"/>女</label>                </radio-group>            </view>            </view>        <view class=\"section\">            <view class=\"section__title\">地区选择:</view>            <view class='form-group'>                <picker bindchange=\"bindPickerChange\" value=\"{{index}}\" range=\"{{array}}\">                    <view class=\"picker\">                        <input type=\"hidden\" disabled=\"true\" name=\"addr\" value=\"{{array[index]}}\"/>                    </view>                </picker>            </view>        </view>        <view class=\"section section_gap\">            <view class=\"section__title\">爱好:</view>            <view class='form-group'>                <checkbox-group name=\"hobby\">                    <label><checkbox value=\"羽毛球\"/>羽毛球</label>                    <label><checkbox value=\"游泳\"/>游泳</label>                </checkbox-group>            </view>        </view>                <view class=\"section section_gap\">            <view class=\"section__title\">是否显示:</view>            <view class='form-group'>                 <switch name=\"isshow\"/>            </view>        </view>        <view class=\"section btn-area\">            <button formType=\"submit\">提交</button>            <button formType=\"reset\">清空</button>        </view>    </form>     <!-- 黑框提示并消失 -->    <toast hidden=\"{{toast1Hidden}}\" bindchange=\"toast1Change\">        {{notice_str}}    </toast>    <!-- 确认框 及 提示框 -->    <view class=\"page__bd\">        <modal title=\"确认\" confirm-text=\"确定\" cancel-text=\"取消\" hidden=\"{{modalHidden}}\" mask bindconfirm=\"confirm_one\" bindcancel=\"cancel_one\">            确认提交么？        </modal>        <modal class=\"modal\" hidden=\"{{modalHidden2}}\" no-cancel bindconfirm=\"modalChange2\" bindcancel=\"modalChange2\">            <view> 提示 </view>            <view> 清空成功 </view>        </modal>    </view></view>    2. js 代码var app = getApp();Page({  data:{    // text:\"这是一个页面\"    array:[\"中国\",\"美国\",\"巴西\",\"日本\"],    toast1Hidden:true,    modalHidden: true,    modalHidden2: true,    notice_str: '',    index:0  },  toast1Change:function(e){    this.setData({toast1Hidden:true});  },  //弹出确认框  modalTap: function(e) {    this.setData({      modalHidden: false    })  },  confirm_one: function(e) {    console.log(e);    this.setData({      modalHidden: true,      toast1Hidden:false,      notice_str: '提交成功'    });  },  cancel_one: function(e) {    console.log(e);    this.setData({      modalHidden: true,      toast1Hidden:false,      notice_str: '取消成功'    });  },  //弹出提示框  modalTap2: function(e) {    this.setData({      modalHidden2: false    })  },  modalChange2: function(e) {    this.setData({      modalHidden2: true    })  },  bindPickerChange: function(e) {    console.log('picker发送选择改变，携带值为', e.detail.value)    this.setData({      index: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  },  formSubmit: function(e) {    var that = this;    var formData = e.detail.value;     wx.request({      url: 'http://test.com:8080/test/socket.php?msg=2',      data: formData,      header: {          'Content-Type': 'application/json'      },      success: function(res) {        console.log(res.data)        that.modalTap();      }    })  },  formReset: function() {    console.log('form发生了reset事件');    this.modalTap2();  }})3. 部分样式#adduser{    background: #f5f5f5;}.section__title{    float: left;    width:30%;}.form-group{    float: right;    width: 70%;}.section{    clear: both;    width:90%;    margin: 2rem auto;}.input-text{    border: 1px solid #ddd;}.button{    border: 1px solid #1aad19;    border-radius: 2px;}.picker{    padding: 13px;    background-color: #FFFFFF;}4. 服务器端<?phpvar_dump($_REQUEST);本节 集合了 表单  https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html?t=1476197486816数据请求 https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1476197484427提示框  https://mp.weixin.qq.com/debug/wxadoc/dev/component/toast.html?t=1476197486420确认和非确认框  https://mp.weixin.qq.com/debug/wxadoc/dev/component/modal.html?t=1476197489278以及相关表单 的信息 ， 之后将分解讲解 对应的小功能。"}
{"title": "微信小程序简易全攻略《四》模板条件列表渲染完成模拟公众号自动回复 ... ", "author": "天下雪", "pub_time": "2016-10-20 15:10", "content": "最近突发奇想，如果微信小程序不在微信公众号里了该如何使用 自动回复呢？先看下效果话不多说 直接上代码1.页面代码：<swiper indicator-dots=\"{{indicatorDots}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">      <block wx:for=\"{{imgUrls}}\">        <swiper-item>           <navigator url=\"{{item.link}}\" hover-class=\"navigator-hover\">            <image src=\"{{item.url}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>           </navigator>         </swiper-item>      </block></swiper> <block>    <input type=\"text\" class=\"input-text\" bindchange=\"setInputValue\"  placeholder=\"请输入你要咨询的内容\"/>    <button bindtap=\"getgetinputSEnd\" class=\"input-button\">发送</button></block><view class=\"chat-area\">        <view wx:for=\"{{msgs}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">        <view class=\"say-title\">            <block wx:if=\"{{idx%2 != 0}}\"><text class=\"red-font\">客服：</text></block>            <block wx:if=\"{{idx%2 == 0}}\"><text class=\"green-font\">你：</text></block>        </view>        <view class=\"say-content\">            <block wx:if=\"{{itemName.type == 'video'}}\">                <video src=\"{{itemName.msg}}\"></video>            </block>            <block wx:if=\"{{itemName.type == 'voice'}}\">                <audio src=\"{{itemName.msg}}\" controls loop></audio>            </block>            <block wx:if=\"{{itemName.type == 'image'}}\">                <image src=\"{{itemName.msg}}\"></image>            </block>            <block wx:if=\"{{itemName.type == 'text'}}\">                <text>{{itemName.msg}}</text>            </block>        </view>    </view></view>页面中 使用了 模板的 条件渲染 ：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1476197490824 列表渲染：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html?t=14761974929812. 样式代码.slide-image{    width: 100%;}.input-text{border:1px solid #abcdef;width:88%;background:#ddd;line-height:100%;text-indent: 0.5rem;margin:1rem auto;height:40px;}.input-button{    background:#48C23D;margin:0.5rem 5%;color:#fff;}.chat-area{    width: 90%;    margin:0.5rem 5%;    border:1px solid #ddd;    background:#eee;    font-size: 1rem;}.red-font{    color:#DC143C;}.green-font{    color:#48C23D;}.say-content{font-size:80%;width:80%;margin:0.5rem 5%;}3. js代码//test.js//获取应用实例var app = getApp();Page({  data: {      imgUrls: [       {          link:'/pages/index/index',          url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'        },{          link:'/pages/logs/logs',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'        },{          link:'/pages/test/test',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'        }     ],    indicatorDots: true,    autoplay: true,    interval: 5000,    duration: 1000,    msgs:[],    inputdata:'',    userInfo: {}  },  onLoad: function () {    console.log('onLoad test');    console.log(this.data.msgs);  },  getgetinputSEnd:function(){      var input = this.data.inputdata;      var that = this;      var msgs = that.data.msgs;       msgs.push({msg:input,'type':'text'});      //--------------------------------- 微信数据请求           wx.request({        url: 'http://test.com:8080/test/socket.php',        data: {          msg:input        },        header: {            'Content-Type': 'application/json'        },        success: function(res) {          msgs.push({msg:res.data.content,'type':res.data.msgType});          that.setData({msgs:msgs});          console.log(res.data)        }      })       },  setInputValue:function(e){      console.log(e.detail);      this.data.inputdata = e.detail.value;  }})4. 服务器端代码<?php$params = $_REQUEST;$msg = $params['msg'];$content = array();switch ($msg) {    case '1': \tcase '美女': \t\t$content['msgType'] = 'image'; \t\t$content['content'] = 'https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=ae4df4ec878ba61ec0eecf2f713497cc/43a7d933c895d143b233160576f082025aaf074a.jpg'; \t\tbreak; \tcase '2': \tcase '音乐': \t\t$content['msgType'] = 'voice'; \t\t$content['content'] = 'http://www.w3school.com.cn/i/song.mp3'; \t\tbreak; \tcase '3': \tcase '视频': \t\t$content['msgType'] = 'video'; \t\t$content['content'] = 'http://www.w3school.com.cn//i/movie.ogg'; \t\tbreak;\t \tcase '4': \tcase '笑话': \t\t$content['msgType'] = 'text'; \t\t$content['content'] = '一男子在闹市骑摩托撞昏了一个陌生的老汉! 男子惊吓的不知所措!围观群众越来越多!突然,该男抱住老汉,声泪俱下的喊道:“爹,你等着我,我这就去给...'; \t\tbreak;\t\t \tdefault: \t\t$content['msgType'] = 'text'; \t\t$content['content'] = '您发送的指令不在识别范围内： \t\t                       你可以选择  \t\t                         1 美女  \t\t                         2 音乐 \t\t                         3 视频 \t\t                         4 笑话 '; \t\tbreak; }  echo json_encode($content);"}
{"title": "微信小程序开发新手实战教程 ", "author": "天下雪", "pub_time": "2016-10-20 17:47", "content": "创建快捷项目app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。 app.json是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。App({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  },  onShow:function() {    console.log(\"show\");  },  onHide:function() {    console.log(\"hide\");  }})注意必须在 app.js 中注册App() ，不能注册多个。 onLaunch：程序初始化执行，且只执行一次。 onShow:程序启动，或从程序后台进入前台时执行。 onHide:程序从前台进入后台时执行。 可以添加任意函数到OBJECT中，使用this访问。底部导航 添加images目录，放入图片资源并添加主程序页面 添加底部导航tabBar{  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/main/main\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#dddddd\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  },  \"tabBar\":{    \"color\":\"#000\",    \"selectedColor\":\"#48c33c\",    \"borderStyle\":\"block\",    \"backgroundColor\":\"#ffffff\",    \"list\":[{      \"pagePath\":\"pages/index/index\",      \"iconPath\":\"images/footer/index.png\",      \"selectedIconPath\":\"images/footer/indexS.png\",      \"text\":\"首页\"    },    {      \"pagePath\":\"pages/logs/logs\",      \"iconPath\":\"images/footer/logs.png\",      \"selectedIconPath\":\"images/footer/logsS.png\",      \"text\":\"日志\"    },    {      \"pagePath\":\"pages/main/main\",      \"iconPath\":\"images/footer/main.png\",      \"selectedIconPath\":\"images/footer/mainS.png\",      \"text\":\"主程序\"    }    ]  }}color：文字默认颜色 selectedColor：文字选中颜色 borderStyle：上边框颜色（只支持black/white） backgroundColor：背景色 list：菜单列表list属性 pagePath：页面路径（需要在pages中初始化） iconPath：图片路径，大小限制40kb selectedIconPath：选中样式图片路径，大小限制40kb text：按钮文字数据绑定main.jsPage({\r\n  data:{\r\n    text:\"这是一个页面\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})12345678910111213141516171819201234567891011121314151617181920main.wxml<view>\r\n    <text>{{text}}</text>\r\n</view>123123view组件 flex-direction： row：横向排列；column：纵向排列 justify-content：flex-start：左对齐； flex-end：右对齐；center：居中；space-between：两端分散对齐；space-around：居中分散对齐 align-items：flex-start：垂直顶部；flex-end：垂直底部；center：垂直居中轮播    <swiper indicator-dots=\"true\" autoplay=\"true\" duration=\"1000\" bindchange=\"listenSwiper\" >\r\n        <swiper-item>\r\n            <view style=\"background: red; height: 150px\"></view>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <view style=\"background: green; height: 150px\"></view>\r\n        </swiper-item>\r\n            <swiper-item>\r\n            <view style=\"background: blue; height: 150px\"></view>\r\n        </swiper-item>    \r\n    </swiper>12345678910111234567891011属性名 类型 默认值 说明 indicator-dots Boolean false 是否显示面板指示点 autoplay Boolean false 是否自动切换 current Number 0 当前所在页面的 index interval Number 5000 自动切换时间间隔 duration Number 1000 滑动动画时长 bindchange EventHandle current 改变时会触发 change 事件，event.detail = {current: current} 注意：其中只可放置组件，其他节点会被自动删除。 仅可放置在组件中，宽高自动设置为100%。获取轮播改变事件listenSwiper:function(e) {\r\n    console.log(e)\r\n},123123值Object {target: Object, currentTarget: Object, type: \"change\", timeStamp: 35345, detail: Object}\r\ncurrentTarget\r\n:\r\nObject\r\ndetail\r\n:\r\nObject\r\ntarget\r\n:\r\nObject\r\ntimeStamp\r\n:\r\n35345\r\ntype\r\n:\r\n\"change\"\r\n__proto__\r\n:\r\nObject1234567891011121314151617181912345678910111213141516171819图标 icon type 有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear size 默认23px color 同css的color<!--成功图标-->    <icon type=\"success\" size=\"40\"/>    <!--安全成功标志图标-->    <icon type=\"safe_success\" size=\"40\"/>    <!--提示信息图标-->    <icon type=\"info\" size=\"40\"/>    <!--带圆的信息提示图标-->    <icon type=\"info_circle\" size=\"40\"/>    <!--不带圆的成功图标-->    <icon type=\"success_no_circle\" size=\"40\"/>    <!--带圆的成功图标-->    <icon type=\"success_circle\" size=\"40\"/>    <!--警告图标-->    <icon type=\"warn\" size=\"40\"/>    <!--带圆的等待图标-->    <icon type=\"waiting_circle\" size=\"40\"/>    <!--等待图标-->    <icon type=\"waiting\" size=\"40\"/>    <!--下载图标-->    <icon type=\"download\" size=\"40\"/>    <!--取消图标-->    <icon type=\"cancel\" size=\"40\"/>    <!--清除图标-->    <icon type=\"clear\" size=\"40\"/>    <!--改变颜色的success-->    <icon type=\"success\" size=\"40\" color=\"red\"/>进度条 percent Float 无 百分比0~100 show-info Boolean false 在进度条右侧显示百分比 stroke-width Number 6 进度条线的宽度，单位px color Color #09BB07 进度条颜色 active Boolean false 进度条从左往右的动画<progress percent=\"80\" show-info=\"true\" stroke-width=\"5\" color=\"red\" active=\"true\"/>按钮 button    <button type=\"defaule\" bindtap=\"clickButton\">Defalut</button>    <!--原始颜色，不可点击状态， 正在加载状态-->    <button type=\"primary\" disabled=\"true\" loading=\"true\">Primary</button>    <button type=\"warn\">warn</button>注：button-hover 默认为{background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}按钮点击事件  clickButton: function(e) {    console.log(e);  },CHECKBOX    <!--checkbox-group是checkbox的组，使用bindchange，监听数据选中和取消-->    <checkbox-group bindchange=\"listenCheckboxChange\">        <label style=\"display: flex;\"  wx:for-items=\"{{items}}\">            <checkbox value=\"{{item.name}}\" checked=\"{{item.checked}}\"/>{{item.value}}        </label>    </checkbox-group>绑定事件 绑定数据items: [        {          name: 'S',           value: 'S',           checked: 'true'        },        {          name: 'O',           value: 'O'        },        {          name: 'N',           value: 'N'        },        {          name: 'G',           value: 'G'        },        {          name: 'SONG',           value: 'SONG'        }    ]绑定监听事件  listenCheckboxChange:function(e) {      console.log(e);  },至此页面源代码（Git）：https://github.com/yz-mengxiangsong/wechatDemo.git"}
{"title": "秀杰实战教程系列《五》：实战课程之记账应用开发（续） ", "author": "天下雪", "pub_time": "2016-10-21 10:26", "content": "缘起：昨天官方开发有了更新v0.10.101100，Picker的mode属性已经支持date以及time（background-image的bug也修复），于是来更新此实例。目标：实现集成日期组件如图官方文档出处：https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html步骤，在item.wxml文件中增加一个picker组件，如下：如图从图中可以看出：1.日期后面是空白的，应该默认显示今天日期； 2.点击确定也没有显示到组件上，需要实现bindDateChange方法。于是我们需要在item.js文件中，声明一个data值date与wxml中的{{date}}绑定关联然后在onLoad中初始化字符串格式的日期值，详细说明见注释：经过如上处理，日期组件已经显示为当前日期如图处理到此，我们还需要修复一个逻辑错误，即组件的结束日期应该不超过当日，做法也很简单，只需要在wxml文件中对picker的日期属性end由2017-09-01改为{{date}}即可<picker mode=\"date\" value=\"{{date}}\" start=\"{{date}}\" end=\"2017-09-01\" bindchange=\"bindDateChange\">\r\n吐槽一下，官方的picker的还是有bug的，完全不听start与end使唤，仍可以选任意日期，暂时不去理会，代码就这么写着，什么时候开发工具修复了自然可以了，毕竟是现在还只是内测，就将就用着。接下来处理日期组件点击确认事件bindDateChange回到item.js文件声明一个bindDateChange方法，添加如下代码以写回data中的date值至此，已经实现集成日期picker组件。剩下的就是将它同之前的标题、类型、金额字段那样存在json再本地setStorage存储即可，这里不作赘述"}
{"title": "新手跳坑指南：小程序开发过程中遇到的各种坑 ", "author": "天下雪", "pub_time": "2016-10-21 11:06", "content": "1：wx.request 中 method:\"POST” 模式下，后台收到请求，但是data:{}数据全部消失，也就是发了一个空请求！！2：wx.uploadFile和wx.downloadFile 这两个基佬传说在真机有效，在IDE环境中无效~~反正我是没试通，后台没收到任何请求3：【问题】wx.request 中 method:\"POST” 模式下，后台收到请求，但是data:{}数据全部消失，也就是发了一个空请求！！     【解决】可以看下是不是设置了Content-Type='application/json'，我是设置了这个后发现微信也会自动加上'application/json'导致Content-Type变成了application/jsonapplication/json，注释掉自己设置的Content-Type='application/json'就正常了4：【问题】wx.uploadFile和wx.downloadFile 这两个基佬传说在真机有效，在IDE环境中无效~~反正我是没试通，后台没收到任何请求     【解决】开发工具更新前pc无效，手机可以；开发工具更新后pc可以，手机可以。5：【问题】canvas的图片绘制实例无效！！（就是下边这些）var context = wx.createContext()wx.chooseImage({success: function(res) {context.drawImage(res.tempFilePaths[0], 0, 0)wx.drawCanvas({canvasId: 1,actions: context.getActions()})}})6：【问题】分割线用1rpx的时候有时候有些分辨率不显示     【解决】将单位改成px就可以了7：小程序中无法使用图文混合的富文本，以前在网站后台编辑的文章详情和商品详情都无法直接在小程序中正常显示"}
{"title": "微信小程序登录态验证流程 ", "author": "天下雪", "pub_time": "2016-10-21 11:42", "content": "点击进入原地址小程序调用wx.login得到code.调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。用户数据的加解密通讯需要依赖会话密钥完成。小程序调用wx.getUserInfo得到rawData, signatrue, encryptData.小程序调用server获取token接口, 传入code, rawData, signature, encryptData.server调用微信提供的jsoncode2session接口获取openid, session_key, 调用失败应给予客户端反馈, 微信侧返回错误则可判断为恶意请求, 可以不返回. 微信文档链接这是一个 HTTP 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。接口地址：\"https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code\"server计算signature, 并与小程序传入的signature比较, 校验signature的合法性, 不匹配则返回signature不匹配的错误. 不匹配的场景可判断为恶意请求, 可以不返回. 微信文档链接通过调用接口（如 wx.getUserInfo）获取敏感数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )将 signature、rawData、以及用户登录态发送给开发者服务器，开发者在数据库中找到该用户对应的 session-key，使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的可信度。使用第4步返回的session_key解密encryptData, 将解得的信息与rawData中信息进行比较, 需要完全匹配, 解得的信息中也包括openid, 也需要与第4步返回的openid匹配. 解密失败或不匹配应该返回客户相应错误. 微信文档链接接口如果涉及敏感数据（如wx.getUserInfo当中的 openid ），接口的明文内容将不包含敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptData )进行对称解密。 解密算法如下：对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。对称解密的目标密文为 Base64_Decode(encryptData),对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节对称解密算法初始向量 iv = aeskey, 同样是16字节rawData格式:{\r\n    \"nickName\": \"Band\",\r\n    \"gender\": 1,\r\n    \"language\": \"zh_CN\",\r\n    \"city\": \"Guangzhou\",\r\n    \"province\": \"Guangdong\",\r\n    \"country\": \"CN\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0\"\r\n}\r\nencryptData解密之后格式:{\r\n    \"openId\": \"OPENID\",\r\n    \"nickName\": \"NICKNAME\",\r\n    \"gender\": 1,\r\n    \"city\": \"CITY\",\r\n    \"province\": \"PROVINCE\",\r\n    \"country\": \"COUNTRY\",\r\n    \"avatarUrl\": \"AVATARURL\",\r\n    \"unionId\": \"UNIONID\"\r\n}\r\n使用session_key作为密钥, 加密至少包括openid, timestamp, random(随机值), version(版本)的内容, 得到token. 加密算法可以参考微信对encryptData的加密算法. server应该缓存session_key, 缓存的过期时间不应该小于token的过期时间. 将openid, token返回给客户端.小程序每次业务请求都必须带上openid和token, server验证token的合法性: token能否被正常解密; 解密后的openid和传入的openid是否一致; 解密后可得到token的生成时间, token是否过期. 全部校验通过即可正常处理业务请求."}
{"title": "微信小程序和Android开发对比分析 ", "author": "天下雪", "pub_time": "2016-10-18 17:00", "content": "国庆节尾巴上花了一点时间读微信小程序的官方文档,在对比之前自己做得Android，有了下面的内容。这篇文章将围绕下面几个方面：从开发模式（过程）上对比Android和小程序，比较两种”模式”的异同从实现功能上对比，主要是看看微信小程序的局限自己的一些看法，微信的优势开发过程上的对比 在我看来,开发一款app，需要做的主要是界面布局以及交互处理,然后是后面的业务逻辑处理。虽然平台不同，但是任务都是趋同的。下面从这两个大的方面进行对比一下。小程序 微信把这个小程序框架称为“MINA”，并声称：MINA(MINA IS NOT APP) 是在微信中开发小程序的框架。MINA的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生APP体验的服务。MINA提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。 个人觉得第三点说得特别好。大概说清楚了开发者要干什么。大概就是以写Web的方式写好前端，然后通过双向数据绑定技术和业务端交互,业务端通过javascript代码实现业务处理,必要时调用微信接口完成一些处理。一些生命周期函数 这里所说的生命周期函数是指的整个应用以及每个页面的声明周期函数,在Android中，对应着App、Activity类，而在小程序中,对应着App和Page两个函数对象（注意,javascript是基于原型和构造器的，而Java是基于类的，所以这里就造成了一些写法的不同）。以App为例,下面是一个代码实例:App({\r\n  onLaunch: function () {\r\n    console.log('App Launch')\r\n  },\r\n  onShow: function () {\r\n    console.log('App Show')\r\n  },\r\n  onHide: function () {\r\n    console.log('App Hide')\r\n  }\r\n})12345678910111234567891011 每个小程序起起来时就会有一个App实例，同理每个页面打开也会有一个Page实例（这个链接打开往下滑还有生命周期函数的图解），我们只需要在这个实例中添加自己的逻辑即可,唯一不同的是这是在javascript这种语言上写的（java和javascript的区别就像是雷锋和雷峰塔，所以这里形式上的不同还是蛮大的）。视图层代码 前面说了，写视图层的体验有点像Web前端，主要是写多了Android，习惯性地会把界面的样式以及交互放在一块儿写（事实上就是你在xml上做的工作），而在Web端，需要html和css文件来共同完成。在小程序里面，对应的是WXML(WeiXin Markup Language)和WXSS(WeiXin Style Sheets)，注意虽然模式和web很像，但是在形式上算是微信自己开发的一套（所以你需要使用他们自己的标签）。具体来讲，你需要做两件事：在WXML中通过组件（微信所提供的标签）构建页面结构，并且在其中完成数据绑定和事件绑定在WXSS中完成样式的定义，用以控制WXML中组件的样式。WXSS具有CSS大部分特性,同时也有部分扩充。 基本上，视图层很像在写Web端。不过你也看到了，和Android比起来，限制因素在于微信给你提供了组件，然后你最多改改样式，更多的像自定义组件什么的就不可能了。逻辑层代码 不同于Android有一堆的组件（Activity、Service..）来支撑逻辑层，小程序就一个Page()函数(类似与App()函数，在框架里面填逻辑)，所以显得很简单。基本上，数据通过双向绑定进行传递和刷新的，然后在page内可以完成一些交互处理，更多的能力(访问网络、存储)是通过微信的API完成的，这些api以wx.开头，目前来看，不是太多，所以可以很快看完，当然也意味着其实可以完成的工作还着实有限，这个后面说。工程组织 整体来说,小程序的工程组织还是蛮清晰的,MINA程序包含一个描述整体程序的app和多个描述各自页面的page，一个MINA程序主体部分由三个文件组成，必须放在项目的根目录，是app.js,app.json,app.wxss，分别用作生命周期函数、配置文件和样式文件，一个MINA页面由四个文件组成，是.js,.wxml,.json,.wxss，分别用作生命周期函数、布局文件、配置文件和样式文件，他们需要通过同名且放在同名文件夹下（方便框架通过名字路由）。比起Android来，套路应该是固定而简单得多。Android 再回头看看Android开发，突然觉得可以玩的简直是太多了…下面简单描述一下，肯定是不全的。一些生命周期函数 App、Activity是肯定的，其实套路和小程序还是差不多的。只不过组织形式是类而不是函数对象。之前说了，这是因为Js和Java语言特性造成的。视图层代码 通常来讲，Android的界面在.xml文件中定义，其实仔细想想就会发现，在文件中，我们是同时定义了布局，和交互逻辑的，这是因为本质上这些.xml声明都是View类的子类，我们通过重写View的声明周期方法来完成了对齐的样式(onDraw以及LaoutParams)、以及交互的定义（各种on..listener）。所以在.xml中更像是对这些对象进行一系列实例化。至于双向数据绑定,Android也开始支持了逻辑层代码 这一层还是要复杂得多..放到后面对比来说吧。工程组织 …..不想说了，一方面写法多，一方面相对于小程序也蛮复杂的。功能上的对比 要怎么对比呢？读Android的开发文档我之前看了一个星期，而微信小程序的文档也就两三个小时，从体量上说就知道无意Android功能要强大的多。所以基本上小程序能做的以外就是不能做的，这句话听起来很废话，但事实上是因为微信给的API有限，所以你基本上能把自己需求列出来，查一下API是否给出，没给出的话基本上还是算了吧。下面我根据Android的APIguide（科学上网）来罗列下小程序的局限。自定义控件和布局 这个应该是最直观的一点，因为实际上你所使用的视图层是被微信进一步封装了的，小程序自定义控件还是蛮复杂的，因为MINA给出了绘图（但是只能在<canvas/>上作画）和动画（类似于Android中的属性动画）的功能，所以或许存在理论上的可能性。数据存储 这个要特别拿来说一下，官网原文是：每个微信小程序都可以有自己的本地缓存，可以通过wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。 注意： localStorage是永久存储的，但是我们不建议将关键信息全部存在localStorage，以防用户换设备的情况。 所以微信小程序使用的是缓存而非有一个自己的数据库，这里的缓存应该类似于android的SharedPreference之类的，用键值对存的。而且小程序只能对文件进行存的操作。所以说对于那种需要数据库的应用，小程序是不适合的。后台服务，多线程 Android中，Service是蛮重要的类，然后多线程与异步任务虽然复杂，但是能完成许多工作，但是小程序是不具有这种能力的，当然其实你可以看到你也是可以异步读写的…所以微信应该是只提供了部分功能的异步能力。对系统服务的获取 写到这里，主要是想到了之前应用需要闹钟模块，需要让系统定时通知应用以完成特定的事件。而小程序其实是封装在微信这个应用之内的应用，所以理论上它是可以获得系统服务的，但是，如果微信不给接口一切都白说，从API文档中可以看到，微信还是提供了位置、网络状态等系统信息的，不过像通知这些服务，是暂时没有的。与其他应用交互 这里的概念主要是对应Android的隐式意图和ContentProvider，这里Android提供了一种能力，让应用程序之间可以相互调用甚至相互操作数据（比如A打开B的音乐播放器，将A的网页内容保存到B的便签中..这里主要是场景可扩展），而微信中，这种能力被具体场景化了，比如你仍然可以调用相机拍照（微信调用隐式意图帮你实现），其他的场景你却无法实现，因为微信没有做这一层封装。内嵌网页 这一点不知道要不要说..因为微信小程序其实就是一种”内嵌网页”的解决方案？只不过使用了类似于hybrid的解决方案。性能优化 在Android中许多业务已经被MINA封装了（网络请求、websocket…）所以一方面你实现功能的成本降低了，另一方面这一部分优化的空间并不是那么大。开源库 因为我还是个Js的初学者，所以暂时不知道如何在微信小程序中使用轮子。但微信和web前端那一套还真不太一样，所以也应该没法直接使用一些开源库。（10.8更新,今天看到了LeanCloud已经可以支持js开发了..也说明了可行性）最后的总结 如前所说，如果说一般应用的容器(不知道这个比喻恰不恰当)是操作系统，那么小程序的容器则是操作系统下的一款应用，自然而然的，它本身就是某个应用下的一个子模块。而这个模块能有多少功能取决于微信写了多少接口。  另一方面，因为这个容器是微信，至少我们可以假设这些接口的跨平台特性，很可能我们调用的这些接口，会比我们自己写android调用系统接口更稳定，甚至依附于微信，我们可能少了诸如在某些手机系统中管理应用生命周期、避免程序被杀死的麻烦。  总之，我的感受是虽然功能有限，但是足够敏捷开发在需求能够被满足的情况下，尽量适用微信开发。"}
{"title": "半桶水技术分享《二》：js实现单选功能 ", "author": "天下雪", "pub_time": "2016-10-29 23:25", "content": "初次接触js弄了好长时间才出来效果，但是还是觉的不做梦完美，希望有更好的方式进行交流；实现效果如下：虽说这个小功能但是对于我这个新手来说还是有点难；具体代码如下：WXML：[html] view plain copy<span style=\"color:#333333;\"><view class=\"backgrout-bj\">      <view class=\"header\">          最多可增加4个功能入口      </view>      <view>          <block wx:for=\"{{model}}\">               <view class=\"model-list\" bindtap=\"selectClick\" id=\"{{index}}\">                   <view>                      <image class=\"middle-img\" src=\"{{item.image}}\"></image>                  </view>                   <view class=\"middle-title\">                      <view><text>{{item.title}}</text></view>                       <view class=\"middle-sub\"><text>{{item.sub_title}}</text></view>                    </view>                    <!--<view  hidden=\"{{item.selectImage}}\">                      <image src=\"../image/xuanze.png\" class=\"seletedImage\"></image>                    </view>-->                    <view  wx:if=\"{{item.selectImage==true}}\">                      <image src=\"../image/xuanze.png\" class=\"seletedImage\"></image>                    </view>              </view>                     </block>      </view>  </view></span>  从大的分科分为两个大块一个是上面的header  剩下的列表是另外一个部分，列表中又分为若干个小块，本打算写个模版，但是感觉这样更清晰 WXSS：[css] view plain copy.backgrout-bj{ &n"}
{"title": "半桶水技术分享《三》：wx:key理解 ", "author": "天下雪", "pub_time": "2016-10-29 23:29", "content": "个人感觉官方给出的例子不是很明确，官方解释如下：wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以两种形式提供字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。示例代码：<switch wx:for=\"{{objectArray}}\" wx:key=\"unique\" style=\"display: block;\"> {{item.id}} </switch>\r\n<button bindtap=\"switch\"> Switch </button>\r\n<button bindtap=\"addToFront\"> Add to the front </button>\r\n\r\n<switch wx:for=\"{{numberArray}}\" wx:key=\"*this\" style=\"display: block;\"> {{item}} </switch>\r\n<button bindtap=\"addNumberToFront\"> Add to the front </button>Page({\r\n  data: {\r\n    objectArray: [\r\n      {id: 5, unique: 'unique_5'},\r\n      {id: 4, unique: 'unique_4'},\r\n      {id: 3, unique: 'unique_3'},\r\n      {id: 2, unique: 'unique_2'},\r\n      {id: 1, unique: 'unique_1'},\r\n      {id: 0, unique: 'unique_0'},\r\n    ],\r\n    numberArray: [1, 2, 3, 4]\r\n  },\r\n  switch: function(e) {\r\n    const length = this.data.objectArray.length\r\n    for (let i = 0; i < length; ++i) {\r\n      const x = Math.floor(Math.random() * length)\r\n      const y = Math.floor(Math.random() * length)\r\n      const temp = this.data.objectArray[x]\r\n      this.data.objectArray[x] = this.data.objectArray[y]\r\n      this.data.objectArray[y] = temp\r\n    }\r\n    this.setData({\r\n      objectArray: this.data.objectArray\r\n    })\r\n  },\r\n  addToFront: function(e) {\r\n    const length = this.data.objectArray.length\r\n    this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)\r\n    this.setData({\r\n      objectArray: this.data.objectArray\r\n    })\r\n  },\r\n  addNumberToFront: function(e){\r\n    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)\r\n    this.setData({\r\n      numberArray: this.data.numberArray\r\n    })\r\n  }\r\n})这里写下个人的理解，有什么不对的地方希望大家指正：以<switch></switch>为例，如果没有wx:key，选中其中的某个按钮的时候，改变其顺序 或添加选项的时，选中的按钮时不回跟随 上个按钮改变顺序的，会一直在固定位子，如果如果有wx:key则相反，适用于列表或其他标签可以改变顺序或添加项目的情况"}
{"title": "微信小程序准备工作：微信开发实战《一》申请测试号 ", "author": "天下雪", "pub_time": "2016-10-29 23:41", "content": "最近微信发布了微信小程序内侧，各位程序员们是不是早就想一展身手，跃跃欲试。但是目前还没有完全开放，所以我们还是先看看微信公众相关的开发，做好准备，等待微信小程序全面开放，到时候期待各位程序员们可以开发出优秀的小程序。本系列实战文章为大家介绍微信开发的相关知识，包括公众号申请、接口开发等。并为程序员们提供微信开发开源代码。后期也会出一些教学视频，和大家一起交流学习。一、公众号开发准备：申请公众号如果你还没有想好公众号的名字、形式（订阅号、服务号），可以先申请一个测试号，用于开发入门阶段的学习。测试号开放的接口比较多，比较方便用于开发测试。如果你想现在就申请正式号，请一定要选择好订阅号还是服务号，相关的区别可以百度一下。最主要的区别是，订阅号每天可以群发1次消息，服务号每月可以群发4次。如果是个人申请，个人建议申请订阅号比较合适。1.1 如何申请测试号？测试号不分订阅号和服务号，包括了它们所有的接口功能。如何申请呢？首先你要有自己的微信号，通过微信号进行申请。访问链接http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login可以看到如下图片的界面：点击 登录 按钮，会弹出一个二维码，用手机微信扫一扫，即可看到如下界面：点击 确认登录 按钮，你的测试号就申请成功了！    测试号信息    接口配置信息    JS接口安全域名    测试号二维码    模板消息接口    体验接口权限表在电脑的网页中可以看到测试号的相关信息，包括：    包括appID 和 appsecret。开发号接入的时候会用到。    开发号接入时配置。    如果需要使用jssdk，这里需要配置。    公众号二维码。    如果你需要使用模板消息，这里可以配置很多。    测试号所具备的所有接口权限。1.2 开发者号部分接口权限一览在测试号页面可以看到 体验接口权限 一览表，以及每天使用频率的限制。接口很多，在此不详细介绍，如下图：二、 开发者接口文档上面图片的每个接口都有对应的文档，打开此链接可以了解详细介绍http://mp.weixin.qq.com/wiki/home/index.html三、公众号登录如果需要申请正式的公众号，打开此链接，即可实现注册和登录https://mp.weixin.qq.com/cgi-bin/loginpage登录成功之后，就看到了公众号所具备的部分功能菜单，如下图：结束语本篇文章简单介绍了如何申请测试号，下篇文章为大家介绍 微信公众平台接口调试工具"}
{"title": "微信小程序学习点滴《六》：保留小数(toFixed) 四舍五入 获取整数 string转int ... ", "author": "天下雪", "pub_time": "2016-10-29 23:58", "content": "1.保留小数点后几位小数.方法很简单.toFixed()即可.括号内的数字表示保留的位数.如果是整数,就会不上0特别注意:这方法返回的是String,我开始不知道,拿着返回值去做加法,折腾半个小时都是拼字符串,问了黄秀杰大神才知道搞错了.然后用parseInt()转换类型才拿到值.2.获取几位数 toPrecision()上图;第一组是获取四位数,第二组是获取六位"}
{"title": "微信小程序开发工具v0.10.102800-新增功能解析 ", "author": "天下雪", "pub_time": "2016-10-30 00:16", "content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注今天一早起来，发现小程序开发工具被更新到v0.10.102700版本了，随后不久又发布了v0.10.102800修复了点bug。这一次的两个发布新增加了不少api，本文试着向读者分析其中的一些api的用法，帮读者节省些工夫。 1、界面上的更新最主要的更新就是“实时刷新”功能。文件列表跟UI面板可以并排显示了，所以开发时就可以同时显示三个面板了（UI面板、文件面板、代码面板），如果不想看文件列表，可以把中间的这个面板收缩起来，点击这个面板左上角那个树形图标就可以了。当然，如果你不想显示UI面板，也可以把它隐藏起来，方法也是一样的，点击UI面板左上角的小图标就可以了。这个界面上的变化，主要是为了方便开发者，在代码修改的时候，查看实时UI变化。这个实时刷新的功能可能会比较占系统资源，开发者如果不需要这个功能可以把它关掉：在项目的设置里面，如上图，把这个选项前面的钩点掉就行。不过作者试了一下这个操作，居然点掉了还是会实时刷新，可能是工具的bug。 2、文件api（1）wx.getSavedFileList获取本地已保存的文件列表，之前有保存文件的接口，但我们看不到本地到底保存了哪些文件。这次的这个api正是用来解决这个问题的。（2）wx.getSavedFileInfo获取本地具体某个文件的文件信息。（3）wx.removeSavedFile移除本地存储的某个文件。以上三个接口，都只能操作wx.saveFile保存的文件，临时文件是取不到的。我们来写个示例代码测试一下上面三个api。// 从本地选取一个文件，临时存本地\r\nwx.chooseImage({\r\n     success:(res1)=>{\r\n          console.log(res1.tempFilePaths);\r\n          /* 这时wx.getSavedFileList还看不到，要先save */\r\n\r\n          // 保存\r\n          wx.saveFile({\r\n               tempFilePath: res1.tempFilePaths,\r\n               success: (res2)=>{\r\n                    var myFile = res2.savedFilePath;\r\n                    console.log(myFile);\r\n\r\n                    // 这时就可以查看了\r\n                    wx.getSavedFileList({\r\n                         success:(res3)=>{\r\n                              console.log(res3);\r\n                         }\r\n                    });\r\n\r\n                    // 上面的api是取得整个文件列表\r\n                    // 下面我们来取得具体某个文件\r\n                    wx.getSavedFileInfo({\r\n                         filePath: myFile,\r\n                         success: (res4)=>{\r\n                              console.log(res4);\r\n                         }\r\n                    });\r\n\r\n                    // 删除\r\n                    wx.removeSavedFile({\r\n                         filePath: myFile,\r\n                         success: (res)=>{\r\n                              console.log('删除成功: ' + res)\r\n                         }\r\n                    });\r\n               }\r\n          });\r\n     }\r\n});\r\n其中，wx.getSavedFileList返回内容：wx.getSavedFileInfo返回：{errMsg: \"getSavedFileInfo:ok\", size: 71466, createTime: 1477619293}wx.removeSavedFile返回：{errMsg: \"removeSavedFile:ok\"} （4）wx.openDocument新开一个页面，显示某个文档的内容，支持格式有：doc, xls, ppt, pdf, docx, xlsx, pptx这个功能比较强大。不过在工具上测试了下pdf文件，它是用系统默认的工具来打开pdf的。在手机上不知道是什么样。示例代码：wx.downloadFile({\r\n     url: 'http://www.jsongo.com/res/test.pdf',\r\n     success: (res)=> {\r\n          var filePath = res.tempFilePath;\r\n          wx.openDocument({\r\n              filePath: filePath,\r\n              success: function (res) {\r\n                     console.log(res);\r\n              }\r\n          });\r\n    }\r\n});\r\n返回的res内容是：{errMsg: \"openDocument:ok\"} 3、本地存储api（1）wx.removeStorage和wx.removeStorageSync这次终于有删除storage的功能了。之前我们是通过把value设置为null来模拟删除一个key-value对，这次的api更彻底，可以把key也删掉。同样的，也有同步（wx.removeStorage）和异步（wx.removeStorageSync）的方法。var mykey = 'test-key';\r\nwx.setStorage({\r\n     key: mykey,\r\n     data: 'hello',\r\n     success: ()=>{\r\n          setTimeout(()=> {\r\n               // 异步\r\n               wx.removeStorage({\r\n                    key: mykey,\r\n                    success: (res)=> {\r\n                         console.log(res.data);\r\n                    }\r\n               });\r\n               // 同步\r\n               // wx.removeStorageSync(mykey);\r\n          }, 5000);\r\n     }\r\n});\r\n （2）wx.getStorageInfo和wx.getStorageInfoSync获取storage的状态。我们知道storage的空间是有限的，但什么时候用完，什么时候剩下多少我们完全不知道。直到用完的时候，再存入就报错，这是一个很不正常的流程。这次添加的这个api，正好可以让我们在特定时机去检查一下storage，比如每次程序启动的时候，检查一下，如果快满了，那我们可以定一个策略去清理一部分。wx.getStorageInfo({\r\n     success: function(res) {\r\n          console.log(res.keys); // 所有的key\r\n          console.log(res.currentSize); // 当前已用空间\r\n          console.log(res.limitSize); // 当前项目可用的总空间\r\n     }\r\n});\r\n// 同步调用就更简单了\r\n// var res = wx.getStorageInfoSync();\r\n可以取到三部分的内容，一是本项目所有的key，一是当前已用空间，还有一个是当前项目可用的总空间。 4、交互反馈api这个更新非常方便，之前我们都是通过<toast>，<modal>，<loading>和<action-sheet>标签去定义这些交互，而且要自己去控制这些交互组件的显示和隐藏，而像toast的icon还不能改。这次的几个交互api给我们带来了很大的方便，原来的那四个标签全部都废弃了。（1）toast包含显示wx.showToast和隐藏wx.hideToast这两个api，之前的<toast>和<loading>现在都改用这两个函数来实现：wx.showToast({\r\n     title: '成功',\r\n     icon: 'success',\r\n     duration: 2000\r\n});\r\nsetTimeout(function(){\r\n     wx.hideToast()\r\n}, 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              小程序微信支付不完全接入指南 \n              微信小程序实例教程：实现tabs选项卡效果 \n            \n             \n            \n                  原作者: jsongo0   \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 5款微信小程序开发工具使用报告\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n开发小程序折叠面板2020-02-16小程序后端 egg 框架开发记录2020-02-16小程序对文件及后缀名解析2020-02-16写了一个小程序——无聊也是一种生产力2020-02-27小程序-日历签到2020-02-26微信小程序简易SEO优化2020-02-26玩转微信小程序的位置授权2020-02-27这次一定彻底弄懂DOM事件机制2020-02-28控制音频文件播放进度2020-02-28\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n考研政治2000题答题小程序2020-02-28同城小程序代码2020-01-09汽车养护2020-01-07微信答题小程序仿头脑王者源码2020-01-02微信小程序图书共享借阅全套模板2019-12-10行政后勤服务小程序2019-11-28微信小程序--蓝牙控制音乐播放小车2019-11-15微信小程序--颜色选择器2019-11-13求小程序源码2019-11-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155882|8c49c1dfad60de38898c80fe26e21d89|2';"}
{"title": "梦断难寻新手入门篇《一》：熟悉项目结构 ", "author": "天下雪", "pub_time": "2016-10-30 00:21", "content": "微信小程序创建之后会生成一个项目模板，如下图所示（基本如此，但并不局限于此）现在分别来说明一下每个文件及目录的意思app.js 程序的入口文件，必须存在。app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。app.jsonapp.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释 app.jsonapp.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 Pages（开发者自行创建）目录是你的页面目录，但不是一定需要叫PagesUtils （开发者自行创建）在本例中是工具类库目录，不是一定需要存在在开发过程中最好遵循以上目录结构，特别Pages，没个页面独立一个文件夹，因为每个页面有自己独立的样式或者Js。未来方便管理。 但是，如果有公共样式的存在，请写在app.wxss"}
{"title": "梦断难寻新手入门篇《二》：获取系统信息，地理位置，用户信息 ... ", "author": "天下雪", "pub_time": "2016-10-30 00:24", "content": "三个接口都是微信提供的。 index.js//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data:{\r\n    userinfo : {},\r\n    systemInfo:{},\r\n    location :{}\r\n  },\r\n  onShow:function(){\r\n    var that = this;\r\n    // 获取用户资料\r\n    wx.getUserInfo({\r\n      success:function(res){\r\n        that.setData({\r\n          userinfo:res.userInfo\r\n        });\r\n      }\r\n    });\r\n\r\n    // 获取系统资料\r\n    wx.getSystemInfo({\r\n      success:function(res){\r\n        that.setData({\r\n          systemInfo : res\r\n        });\r\n      }\r\n    });\r\n    // 获取位置信息\r\n    wx.getLocation({\r\n      success:function(res){\r\n        that.setData({\r\n          location:res\r\n        });\r\n      }\r\n    });\r\n  }\r\n})index.wxml  <view class=\"header\">\r\n    <image class=\"user-header\" src=\"{{userinfo.avatarUrl}}\"></image>\r\n    <text  >{{userinfo.province}}  {{userinfo.city}}</text>\r\n    <text >{{userinfo.nickName}}</text>\r\n  </view>\r\n  <view class=\"slice-line\"></view>\r\n  <view class=\"center\">\r\n    <text class=\"text\">系统信息</text>\r\n  </view>\r\n  <view class=\"info-box\">\r\n    <text class=\"info-text\">手机型号：{{systemInfo.model}}</text>\r\n    <text class=\"info-text\">设备像素比：{{systemInfo.pixelRatio}}</text>\r\n    <text class=\"info-text\">窗口宽度：{{systemInfo.windowWidth}}</text>\r\n    <text class=\"info-text\">窗口高度：{{systemInfo.windowHeight}}</text>\r\n    <text class=\"info-text\">微信设置的语言：{{systemInfo.language}}</text>\r\n    <text class=\"info-text\">微信版本号：{{systemInfo.version}}</text>\r\n  </view>\r\n  <view class=\"center\">\r\n    <text class=\"text\">位置信息</text>\r\n  </view>\r\n  <view class=\"slice-line\"></view>\r\n  <view class=\"info-box\">\r\n    <text class=\"info-text\">纬度：{{location.latitude}}</text>\r\n    <text class=\"info-text\">经度：{{location.longitude}}</text>\r\n    <text class=\"info-text\">速度：{{location.speed}}</text>\r\n    <text class=\"info-text\">位置精确度：{{location.accuracy}}</text>\r\n  </view>\r\n  <view style=\"margin-top:100rpx;width:100%;height:2rpx;\"></view>\r\n  \r\n 最后效果图 好了。文本介绍了三个接口的使用方式，具体怎么发挥，大家自行判断吧。 源码奉上下拉刷新，上拉加载更多.zip快递查询.zip系统-位置-用户信息.zip"}
{"title": "微信小程序实例教程：实现tabs选项卡效果 ", "author": "天下雪", "pub_time": "2016-10-30 00:31", "content": "最近微信应用号是炒的如火如荼，热门满满，但是也可以发现搜索关键词出来，各类网站出现的还都是微信的官方文档解释。正好赶上这个热潮，这几天先把小程序技术文档看了个遍，就直接着手写案例了。很多组件微信内部已经封装完了，正好发现没有tab选项卡效果，这两天正好研究了下。思路如下：1、首先点击导航的时候需要两个变量，一个存储当前点击样式类，一个是其它导航默认的样式类2、选项卡内容列表同样也需要两个变量，一个存储当前显示块，一个存储的是其它隐藏的默认块3、使用三目运算通过点击获取导航索引，根据索引判断是否添加当前类【备注，这里我将点击事件绑定在父级导航栏，通过target对象得到点击触发的事件对象属性】 请结合如下效果图：       接下来直接查看源码：demo.wxml：<view class=\"tab\">    <view class=\"tab-left\" bindtap=\"tabFun\">      <view class=\"{{tabArr.curHdIndex=='0'? 'active' : ''}}\" id=\"tab-hd01\" data-id=\"0\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='1'? 'active' : ''}}\" id=\"tab-hd02\" data-id=\"1\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='2'? 'active' : ''}}\" id=\"tab-hd03\" data-id=\"2\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='3'? 'active' : ''}}\" id=\"tab-hd04\" data-id=\"3\">tab-hd01</view>    </view>      <view class=\"tab-right\">      <view class=\"right-item {{tabArr.curBdIndex=='0'? 'active' : ''}}\">tab-bd01</view>      <view class=\"right-item {{tabArr.curBdIndex=='1'? 'active' : ''}}\">tab-bd02</view>      <view class=\"right-item {{tabArr.curBdIndex=='2'? 'active' : ''}}\">tab-bd03</view>      <view class=\"right-item {{tabArr.curBdIndex=='3'? 'active' : ''}}\">tab-bd04</view>    </view>  </view>  demo.js： Page( {    data: {      tabArr: {        curHdIndex: 0,        curBdIndex: 0      },    },    tabFun: function(e){      //获取触发事件组件的dataset属性      var _datasetId=e.target.dataset.id;      console.log(\"----\"+_datasetId+\"----\");      var _obj={};      _obj.curHdIndex=_datasetId;      _obj.curBdIndex=_datasetId;      this.setData({        tabArr: _obj      });    },    onLoad: function( options ) {      alert( \"------\" );    }  });  demo.wxss：.tab{      display: flex;      flex-direction: row;  }  .tab-left{      width: 200rpx;      line-height: 160%;      border-right: solid 1px gray;  }  .tab-left view{      border-bottom: solid 1px red;  }  .tab-left .active{      color: #f00;  }  .tab-right{      line-height: 160%;  }  .tab-right .right-item{      padding-left: 15rpx;      display: none;  }  .tab-right .right-item.active{      display: block;  }      最终演示效果如下： 以上仅是个人方案，如果有更好的方案，欢迎提出~"}
{"title": "一斤代码深入理解系列《一》：微信小程序事件机制 ", "author": "天下雪", "pub_time": "2016-10-31 10:47", "content": "事件机制是一种非常典型的通讯方式，可以在代码中的不同对象之间传递信息，也可以在应用的不同层面进行沟通协作。今天我们想看来一下微信小程序框架提供的事件处理机制。小程序官方文档对事件的定义是：- 事件是视图层到逻辑层的通信方式- 事件可以将用户的行为反馈到逻辑层进行处理- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。- 事件对象可以携带额外信息，如 id, dataset, touches。从这里我们可以看到，官方文档主要将事件用于小程序中针对用户交互行为的处理，即视图层(WXML)到逻辑层(Page)的通信，逻辑层收到这些用户行为事件后，可以进行业务处理，然后根据情况反馈或不反馈结果给用户。好，那我们今天就撇开事件的其他用法，专门就讲视图层和逻辑层之间的事件用法。总体上来说，小程序中的事件机制在工作原理上来讲，和HTML DOM的事件机制是一致的。在HTML中，我们可以通过在HTML元素上设置一个如onclick=\"clickHandler(event)\"的属性来绑定用户的页面点击事件处理函数。而在WXML中，我们为一个组件绑定一个事件处理函数，可以使用如下语法来完成：\r\n这里的bindtap就可以理解为将tap(点击)事件，绑定到一个名为tapName的事件处理函数上来进行处理。然后在相应的Page代码中，我们需要定义这个tapName函数：\r\n这样完成了一个简单的tap事件的处理。当我们在小程序的界面上去点击这个显示为Click me的view组件的时候，view组件捕获到这个tap动作，然后告诉Page中的tapName函数，要对这个动作进行处理，同时，它也为tapName函数提供了足够多的信息，也就是event对象，来帮助我们更好更精准的处理我们的业务逻辑。我们可以来看一下我们这个例子中的event对象里面包含了哪些内容：event\r\n这里我们可以看到，在event对象中，包含了事件的名称，事件目标对象的信息，以及事件发生的在界面上的位置信息等等。我们在组件上设置的data-hi属性的值，也在target中的dataset上被携带了过来，这是比较有用的，在实际开发中，我们可以利用这个特性，来传递更多视图层的信息到逻辑层进行处理。如果你有DOM编程的经验，你就会在这里想到，小程序里事件的冒泡和非冒泡是怎么处理的？如果你还不了解什么是事件冒泡，那我在这里解释一下：在HTML或者WXML这些基于XML的树形结构的界面布局方式中，元素与元素之间是有层级关系的，子级元素上触发的事件，可以向父级元素逐层向上传递，所以，父级元素上也可以捕获子级元素上的事件并进行逻辑处理。这种事件冒泡的机制，在实际的开发中也经常会用到，所以我们有必要来了解下在小程序中，是如何来使用冒泡事件的。WXML中分别提供了两种方式，用来绑定事件处理函数：1. 使用 bind 开头的事件绑定，这种绑定不会阻止冒泡事件向上冒泡2. 使用 catch 开头的事件绑定，这种绑定可以阻止冒泡事件向上冒泡直观起见，我们直接来看一个示例代码：index.wxml\r\nindex.wxss\r\n在这个示例代码中，有三个逐级嵌套的view元素，最里层的是content元素，最外层的为outer-container元素。最里层和最外层的元素上，使用了bind属性绑定了tap事件的处理函数，而中间的innner-container上，使用了catch属性进行tap事件绑定。然后，我们尝试在content上点击一下，可以看到这样的结果：点击content的结果\r\ncontent和inner-container元素的tap事件处理函数被执行了，而outer-container元素的没有被执行。这说明在点击content的过程中，产生的tap事件向父级元素传递，而作为content元素的父级元素inner-container, 它使用了能阻止事件冒泡的catch方式，所以它在捕获通过冒泡形式过来的子级元素事件并执行事件处理函数后，让该事件停止向上传递，因此同样是父级元素的outer-contaner，就不再能收到这个冒泡事件了。然后，来看一下，在不同层级的元素捕获的event对象，在数据方面有什么特点:我们可以看到，在content的tap事件处理函数中，event里面的target和currentTarget的id都是content。\r\n而在inner-container中的event对象里，target的id为content，而currentTarget的id是inner-content。\r\n由此我们可以知道，event对象中的target是事件产生的源头组件，而currentTarget则是当前捕获这个事件的组件。event对象中还包含其他一些有用的信息，如touches和changedTouches表示一个或多个手指在屏幕上的触摸位置和变动位置等信息，可以用来实现多点触摸的高级手势处理。最后，关于事件冒泡，有一点是值得注意一下的：在微信小程序中，并不是所有事件都是冒泡的，从官方文档了解到，<canvas>组件的触摸事件不可冒泡。"}
{"title": "一斤代码深入理解系列《二》：微信小程序样式机制 ", "author": "天下雪", "pub_time": "2016-10-31 10:50", "content": "之前，我已经介绍过在小程序开发中使用WXML来做界面布局，但是WXML只是一个界面的骨架。要让我们的小程序变得精致漂亮高大上起来，就需要一种为其添加样式的机制。小程序的开发框架采用了与Web开发中所使用的CSS（层叠样式表）几乎相同的一种机制，称作WXSS。WXSS用于描述WXML的组件样式，用于决定WXML的组件应该如何显示。为了适应广大的前端开发者，它被设计为支持CSS中大部分的特性（但是注意是大部分，还是有一些特性是不支持的），并且有一些自己的扩展和修改。比如引入了一种新的尺寸单位rpx，还有@import这种外联样式的导入机制（话说这个功能不是CSS里也有的么...）关于CSS，我就不在这里介绍它的用法了，这个内容实在有点多，还没学习过CSS的朋友可以自己找一下资料学习，我在这里主要想讲解一下WXSS和CSS之间的不同之处。样式的设置在WXML文件中，我们可以通过style和class属性为组件设置样式。不过由于WXML的数据绑定功能的存在，我们就可以动态的设置style和class的属性值了。比如：<view style=\"color:{{color}};padding:{{padding}};\">Hello</view><view class=\"message-{{type}}\">{{message}}</view>不过，我们要尽量避免使用style来设置组件的样式，最好将样式定义成样式规则放到样式文件中(.wxss)，然后通过class属性来设置。因为组件通过style接收动态样式，在运行时会进行解析，影响渲染性能。有限的选择器和CSS不一样，小程序的WXSS支持的选择器的类型有限，官方文档中明确列出说支持的，目前只有以下几种选择器：\r\n.class：类选择器，例如.error-msg，它会选择所有class=\"error-msg\"的组件\r\n#id：ID选择器，例如#my-container，它会选择id=\"my-container\"的组件\r\nelement：元素选择器，例如view，它会选择所有view组件\r\nelement, element：多选择器，例如view, button，它会选择所有view和button组件\r\n::after：例如view::after，它会在view组件后面插入内容\r\n::before：例如view::after，它会在view组件前面插入内容\r\n其实自己试了一些在CSS中可用，小程序官方没有声明在WXSS里支持的选择器，也是可以生效的。但是有些用了就会把微信web开发者工具给整崩溃掉，所以，还是不要在实际开发中使用这类没说支持的选择器了，虽然在有的场景下麻烦了点，但是以上支持了的选择器还是基本够用了。全局样式与局部样式WXSS中有全局样式与局部样式之分。定义在app.wxss文件中的样式为全局样式，将会对每一个页面起作用。而定义为page同名的wxss文件，则称为局部样式，只会针对对应的页面起作用，而且样式优先级比全局样式要高，可以覆盖全局样式。新的尺寸单位最后来说一下WXSS中新增和扩展的尺寸单位，对于做屏幕的自适应是非常有帮助的。\r\nrpx (responsive pixel，响应式px)，简单来说，就是不管什么尺寸的设备，总是认为屏幕宽度是750rpx\r\nrem (root em，根em)，也很简单，就是不管什么尺寸的设备，总是认为屏幕的宽度是20rem。\r\n所以rpx和rem之间的换算，就是：1rem = (750/20)rpx = 37.5rpx设计师的设计稿一般都是按照px来做单位的，那么在开发阶段，开发人员就需要在px和rpx之间进行换算，具体可以如下来计算：rpx = (屏幕实际宽度/750)px\r\npx = (750/屏幕实际宽度)rpx因此，如果设计师的设计是以iphone6屏幕尺寸为参照(iphone6的屏幕宽度为375px)，则：1rpx = (375/750)px = 0.5px\r\n1px = (750/375)rpx = 2rpx是不是很容易理解？好了，关于微信小程序样式WXSS的关键点内容，就讲解到这里，不对的地方欢迎指正。谢谢啦。"}
{"title": "梦断难寻新手入门篇《三》：下拉刷新，上拉加载更多 ", "author": "天下雪", "pub_time": "2016-10-31 11:50", "content": "本文记载了如何在微信小程序里面实现下拉刷新，上拉加载更多先开看一下界面  大致如此的界面吧。 这个Demo使用了微信的几个Api和事件，我先列出来。1.wx.request （获取远程服务器的数据，可以理解成$.ajax）2. scroll-view的两个事件   2.1 bindscrolltolower（滑到页面底部时）   2.2 bindscroll (页面滑动时)   2.3 bindscrolltoupper (滑倒页面顶部时)然后我们看代码，详细描述。index.jsvar url = \"http://www.imooc.com/course/ajaxlist\";\r\nvar page =0;\r\nvar page_size = 20;\r\nvar sort = \"last\";\r\nvar is_easy = 0;\r\nvar lange_id = 0;\r\nvar pos_id = 0;\r\nvar unlearn = 0;\r\n\r\n\r\n// 获取数据的方法，具体怎么获取列表数据大家自行发挥\r\nvar GetList = function(that){\r\n    that.setData({\r\n        hidden:false\r\n    });\r\n    wx.request({\r\n        url:url,\r\n        data:{\r\n            page : page,\r\n            page_size : page_size,\r\n            sort : sort,\r\n            is_easy : is_easy,\r\n            lange_id : lange_id,\r\n            pos_id : pos_id,\r\n            unlearn : unlearn\r\n        },\r\n        success:function(res){\r\n            //console.info(that.data.list);\r\n            var list = that.data.list;\r\n            for(var i = 0; i < res.data.list.length; i++){\r\n                list.push(res.data.list[i]);\r\n            }\r\n            that.setData({\r\n                list : list\r\n            });\r\n            page ++;\r\n            that.setData({\r\n                hidden:true\r\n            });\r\n        }\r\n    });\r\n}\r\nPage({\r\n  data:{\r\n    hidden:true,\r\n    list:[],\r\n    scrollTop : 0,\r\n    scrollHeight:0\r\n  },\r\n  onLoad:function(){\r\n    //   这里要非常注意，微信的scroll-view必须要设置高度才能监听滚动事件，所以，需要在页面的onLoad事件中给scroll-view的高度赋值\r\n      var that = this;\r\n      wx.getSystemInfo({\r\n          success:function(res){\r\n              console.info(res.windowHeight);\r\n              that.setData({\r\n                  scrollHeight:res.windowHeight\r\n              });\r\n          }\r\n      });\r\n  },\r\n  onShow:function(){\r\n    //   在页面展示之后先获取一次数据\r\n    var that = this;\r\n    GetList(that);\r\n  },\r\n  bindDownLoad:function(){\r\n    //   该方法绑定了页面滑动到底部的事件\r\n      var that = this;\r\n      GetList(that);\r\n  },\r\n  scroll:function(event){\r\n    //   该方法绑定了页面滚动时的事件，我这里记录了当前的position.y的值,为了请求数据之后把页面定位到这里来。\r\n     this.setData({\r\n         scrollTop : event.detail.scrollTop\r\n     });\r\n  },\r\n  refresh:function(event){\r\n    //   该方法绑定了页面滑动到顶部的事件，然后做上拉刷新\r\n      page = 0;\r\n      this.setData({\r\n          list : [],\r\n          scrollTop : 0\r\n      });\r\n      GetList(this)\r\n  }\r\n})index.wxml <view class=\"container\">\r\n    <scroll-view scroll-top=\"{{scrollTop}}\" scroll-y=\"true\" style=\"height:{{scrollHeight}}px;\" \r\n        class=\"list\" bindscrolltolower=\"bindDownLoad\" bindscroll=\"scroll\" bindscrolltoupper=\"refresh\">\r\n        <view class=\"item\" wx:for=\"{{list}}\">\r\n            <image class=\"img\" src=\"{{item.pic_url}}\"></image>\r\n            <view class=\"text\">\r\n                <text class=\"title\">{{item.name}}</text>\r\n                <text class=\"description\">{{item.short_description}}</text>\r\n            </view>\r\n        </view>\r\n    </scroll-view>\r\n    <view class=\"body-view\">\r\n        <loading hidden=\"{{hidden}}\" bindchange=\"loadingChange\">\r\n            加载中...\r\n        </loading>\r\n    </view>\r\n</view> 源码奉上 下拉刷新，上拉加载更多.zip"}
{"title": "微信小程序准备工作：微信开发实战《二》微信公众平台接口调试工具 ... ", "author": "天下雪", "pub_time": "2016-10-31 12:03", "content": "微信公众平台为公众号开发者提供了网页版的接口调试工具，开发者可以直接在网页中调用对应的接口，比如获取access_token接口，创建菜单接口，发送消息接口 等等。先看一下界面，访问：http://mp.weixin.qq.com/debug/可以看到如下界面：一、接口类型：因为微信公众号接口比较多，所以这里进行了分类，包括：基础支持、向用户发送消息、用户管理、自定义菜单、硬件接入api接口调试 等等；二、接口列表：指的是具体的接口；三、参数列表：调用接口需要的参数；一、获取access_token接口 的调用1.1，根据类型选择接口比如，此界面中调试的接口是 “获取access_token接口”，此接口主要用于调用其他接口前的验证，类似于钥匙。一般平台的接口都不会让开发者直接调用，那样既不安全也增加了平台接口的访问压力。所以平台都会在调用接口之前要求先获取“钥匙”，然后才让“进门”（调用接口）。1.2，填写参数下一步就是填写参数： appId 和 secret（appSecret）。上篇文章介绍了测试号的注册和登录，在测试号登录成功之后，就会发现appId和appSecret，如下图：1.3，调用调试接口将此appId和appSecret填写到参数对应的位置，然后点击 检查问题 按钮，就会获取返回的结果，如下图：这样就获取了 access_token 和 expires_in。access_token：访问其他接口之前的“钥匙”。我们先保存下来，一会演示调试“创建菜单接口”的时候再使用。expires_in：过期时间。开发者不可能每调用一次接口就要去获取一次access_token，这样既增加了微信接口服务器压力，也增加了开发者的工作量。所以为access_token设置了过期时间，单位是秒。开发者一般会将它先缓存在开发者服务器7200s，如果过期了再去获取，具体开发细节后面篇章再详细介绍。二、创建菜单接口刚刚介绍了 获取access_token接口 ，它就是“钥匙”，主要是为了调用其他接口做准备。下面介绍一下创建菜单接口。2.1，菜单json创建微信公众号菜单主要是通过json格式的字符串参数进行创建。菜单级别包括：一级菜单、二级菜单；类型包括：链接，消息，事件，调用摄像头，等等。具体可参考接口文档。简单起见，我们只创建一个链接菜单“我的菜单”，点击它可以打开百度网页，json如下：{     \"button\": [              {                    \"type\": \"view\",                     \"name\": \"我的菜单\",                     \"url\": \"http://www.baidu.com\",                     \"sub_button\": [ ]                }        ]}sub_button：是二级菜单，你也可以尝试将json写的复杂一些，不过要保证格式是正确的。如果有二级菜单，一级菜单就只有展现作用，打不开百度链接。2.2，填写参数，调用接口填写刚获取的 access_token 和 菜单json字符串参数；点击 检查问题 按钮，提示创建菜单成功。2.3，手机微信中查看测试号菜单效果效果如下图，点击 我的菜单 按钮，即可以打开百度网页。提示：如果你创建菜单后，提示创建成功，但是这里的菜单没有变化，可能是由于微信公众号菜单缓存引起的，可以先取消关注，然后再关注即可。结束语如果你已经成功的创建了菜单，也可以尝试调试其他类型的接口。下篇文章主要介绍 开发者公众号的基本原理"}
{"title": "微信小程序准备工作：微信开发实战《三》开发者公众号的交互原理 ... ", "author": "天下雪", "pub_time": "2016-10-31 12:08", "content": "通过前2篇文章，相信你已经对公众号有了基本的了解。从本篇文章开始，详细介绍如何进行公众号开发。本篇文章主要介绍公众号常用的消息交互，并配以流程图。主要目的是希望开发者们从宏观角度对开发者公众号有个清晰的认识，在后续各接口开发中有事半功倍的效果。题外话：在我们开发过程中，一般先有明确的目标，再形成清晰的流程逻辑，最后根据设计模式等理论落实代码细节。所以，最后无论使用哪种编程语言，都是一样的了。所以，高层等都是不写代码的...，如果有一天你也不写代码了，恭喜你高升了；或者还有一种可能：恭喜您，不再做码农了~一，微信服务器与开发者服务器交互显然的，如果公众号想成为开发者号，必须有自己的服务器，也就是说必须部署自己的独立应用。以Java开发为例，需要有对应web应用，且是80端口。服务器获取的方式很多，可以租（比如阿里、腾讯：收费），也可以使用新浪SAE（可免费，后面详细介绍）。前提是你要：有想法，有公众号，有码农！1.1，交互图我们以消息交互场景，讲解交互过程。就是粉丝给公众号发送了一条消息，公众号自动回复一条或多条消息。比如，你关注了公众号 程序员实战（coder10），想撩一下它，就发送了一条文本消息：hello，于是下面的事情就会发生了....1动作请求：就是你给coder10发送了 hello ；这时候微信平台服务器会接受到这条消息，并确定是公众号coder10的粉丝发送来的；2是否开发者公众号：在微信公众平台中可以开启开发者配置，如果没有配置，说明不是开发号，进入：3业务处理 ；如果配置为开发者号，那么进入：4包装转换；3业务处理：微信平台会根据coder10的 “自动回复”（微信平台菜单）中的设置，获取对应的回复素材，然后进行：8回复处理；4包装转换：微信平台会重新包装粉丝请求的动作，并转换为公众号开放接口报文的形式（XML格式），并转发给开发者服务器;5请求：微信平台会带着转换后的参数，发送http请求开发者服务器应用，也就是上文提到的web应用。所以web应用必须是公网的、开放的、80端口的应用。请求的URL就是公众号成为开发者号配置的时候，填写的URL、Token认证时候的URL（后面详细介绍）。6开发者根据自己的业务进行处理：现在就进入了码农们比较熟悉的领域了，无论你用什么技术或编程语言，只要提供对外的web应用就可以了。此web应用可以接受http请求，并获取参数，根据自己的业务逻辑处理后，包装转换回复数据，并返回数据给微信服务器：7回复；7回复：回复的数据格式依然是公众号开放接口规定的XML格式的报文。微信服务器接收到数据之后，进入：8回复处理；8回复处理：就是将要回复的内容转换处理，比如是菜单调用摄像头事件，还是地理位置事件，还是仅仅回复消息等等；coder10是回复消息。处理完成之后进行动作回复；9动作回复：这时，粉丝的微信中就会收到公众号的反馈！流程结束！"}
{"title": "微信小程序开发系列分析《三》websocket ", "author": "天下雪", "pub_time": "2016-10-31 12:21", "content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注为什么需要websocket？传统的实时交互的游戏，或服务器主动发送消息的行为（如推送服务），如果想做在微信上，可能你会使用轮询的方式进行，不过这太消耗资源，大量的请求也加重了服务器的负担，而且延迟问题比较严重。如果是自己开发的app，为了解决这些问题，很多团队会自建socket，使用tcp长链接、自定协议的方式与服务器进行相对实时的数据交互。有能力的团队，采用这种方式自然没什么大问题。不过小团队可能就要花费很多时间去调试，要解决很多难题，这个在成本上就划不来。H5引入了webSocket来解决网页端的长链接问题，而微信小程序也支持websocket。这是一个非常重要的特性，所以本系列的文章会专门拿出一篇来讨论websocket。webSocket本质上也是TCP连接，它提供全双工的数据传输。一方面可以避免轮询带来的连接频繁建立与断开的性能损耗，另一方面数据可以是比较实时的进行双向传输（因为是长链接），而且WebSocket允许跨域通信（这里有个潜在的跨域安全的问题，得靠服务端来解决）。目前除IE外的浏览器已经对webSocket支持得很好了，微信小程序再推一把之后，它会变得更加流行。我们来设计一个新的demo，一个比较有趣的小游戏，多人版扫雷，准确地讲，多人版挖黄金。后台代码：https://github.com/jsongo/mime-server前端代码：https://github.com/jsongo/wx-mime 游戏规则是这样的：把雷换成金子，挖到金子加一分，每人轮流一次（A挖完轮到B，B挖完A才能再点击），点中金子就算你的，也不会炸，游戏继续，直到把场上所有的金子都挖完游戏才结束。跟扫雷一样，数字也是表示周边有几个金子，然后用户根据场上已经翻出来的数字来猜哪一格可能有金子。这种交互的游戏难点在于，用户的点击操作都要传到服务器上，而且服务器要实时的推送到其它玩家的应用上。另外用户自己也要接收对方操作时实时传过来的数据，这样才不至于重复点中同一个格子。简单讲，就是你要上报操作给服务器，而服务器也要实时给你推消息。为了简化整个模型，我们规定玩家必须轮流来点击，玩家A点完后，才能轮到玩家B，玩家B操作完，玩家A才能点。我们分几步来实现这个功能。一、实现思路1、第一步，我们要先生成扫雷的地图场景这个算法比较简单，简述一下。随机取某行某列就可以定位一个格子，标记成金子（-1表示金子）。mimeCnt表示要生成的金子的数量，用同样的方式循环标记mimeCnt个随机格子。生成完后，再用一个循环去扫描这些-1的格子，把它周边的格子都加1，当然必须是非金子的格子才加1。代码放在这里。其中increaseArround用来把这格金子周边的格子都加1，实现也比较简单：执行genMimeArr()，随机生成结果如下：-1表示金子。看了下貌似没什么问题。接下去，我们就要接入webSocket了。（这个是js版本的，其实生成地图场景的工作是在后台生成，这个js版本只是一个演示，不过算法是一样的。）2、我们需要一个支持webSocket的服务端本例子中，我们使用python的tornado框架来实现（tornado提供了tornado.websocket模块）。当然读者也可以使用socket.io，专为webSocket设计的js语言的服务端，用起来非常简单，它也对不支持webSocket的浏览器提供了兼容（flash或comet实现）。笔者本人比较喜欢使用tornado，做了几年后台开发，使用最多的框架之一的就是它，NIO模型，而且非常轻量级，同样的rps，java可能需要700-800M的内存，tornado只要30-40M，所以在一台4G内存的机子上可以跑上百个tornado服务，而java，对不起，只能跑3个虚拟机。微服务的时代，这一点对小公司很重要。当然如果读者本人对java比较熟悉的话，也可以选择netty框架尝试一下。webSocket用tornado的另一个好处是，它可以在同一个服务（端口）上同时支持webSocket及http两种协议。tornado的官方demo代码中展示了怎么实现同时使用两种协议。在本游戏中，可以这么用：用户进入首页，用http协议去拉取当前的房间号及数据。因为首页是打开最多的，进了首页的用户不一定会玩游戏。所以首页还没必要建立webSocket链接，webSocket链接主要用来解决频繁请求及推送的操作。首页只有一个请求操作。选了房间号后，进去下一个游戏页面再开始建立webSocket链接。3、客户端使用微信小程序开发工具，直接连接是会报域名安全错误的，因为工具内部做了限制，对安全域名才会允许连接。所以同样的，这里我们也继续改下工具的源码，把相关的行改掉就行修改方式如下：找到asdebug.js的这一行，把它改成: if(false)即可。if (!i(r, \"webscoket\"))\r\n懒得修改的读者可以直接使用我破解过的IDE。 发起一个websocket链接的代码也比较简单：wx.connectSocket({\r\n    url: webSocketUrl,\r\n});\r\n在调用这个请求代码之前，先添加下事件监听，这样才知道有没有连接成功：wx.onSocketOpen(function(res){\r\n    console.log('websocket opened.');\r\n});\r\n连接失败的事件：wx.onSocketError(function(res){\r\n  console.log('websocket fail');\r\n})\r\n收到服务器的消息时触发的事件：wx.onSocketMessage(function(res){\r\n    console.log('received msg: ' + res.data);\r\n})\r\n当链接建立之后，发送消息的方法如下：wx.sendSocketMessage({\r\n    data:msg\r\n})\r\n消息发送由于建立链接是需要几次握手，需要一定的时间，所以在wx.connectSocket成功之前，如果直接wx.sendSocketMessage发送消息会报错，这里做一个兼容，如果连接还没建立成功，则用一个数组来保存要发送的信息；而链接第一次建立时，把数据遍历一遍，把消息拿出来一个个补发。这个逻辑我们封装成一个send方法，如下：function sendSocketMessage(msg) {\r\n    if (typeof(msg) === 'object') { // 只能发送string\r\n        msg = JSON.stringify(msg);\r\n    }\r\n    if (socketOpened) { // socketOpened变量在wx.onSocketOpen时设置为true\r\n        wx.sendSocketMessage({\r\n            data:msg\r\n        });\r\n    } else { // 发送的时候，链接还没建立\r\n        socketMsgQueue.push(msg);\r\n    }\r\n}\r\n二、demo功能解析1、首页entry为了简化模型，把重点放在webSocket上，我们把首页做成自己填写房间号的形式。读者如果自己有时间和能力的话，可以把首页做成一个房间列表，并显示每个房间有多少人在玩，只有一人的可以进去跟他玩。甚至后面还可以加上观"}
{"title": "TITF出品：微信小程序实用案例代码片段大全《二》 ", "author": "天下雪", "pub_time": "2016-10-27 15:41", "content": "一：使用checkbox显示多项选择框关键代码index.wxml 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6<checkbox-group bindchange=\"checkboxgroupBindchange\">  <checkbox value=\"checkbox1\">checkbox1</checkbox>  <checkbox value=\"checkbox2\">checkbox2</checkbox>  <checkbox value=\"checkbox3\">checkbox3</checkbox></checkbox-group><view>提示：{{text}}</view> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21\r\n 22\r\n 23\r\n 24Page({  data:{    // text:\"这是一个页面\"    text:''  },  checkboxgroupBindchange:function(e){    var temp1=e.detail.value    var temp2=''    console.log(temp1)    if(temp1.length!=0){      for(var i=0,len=temp1.length;i<len;i++){        temp2=temp2+temp1[i]+','      }      this.setData({        text:'您选择了：'+temp2      })    }else{      this.setData({        text:''      })    }      }}) 来自CODE的代码片二：使用radio显示单选项关键代码index.wxml 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6<radio-group bindchange=\"radiogroupBindchange\">  <radio value=\"radio1\">radio1</radio>  <radio value=\"radio2\">radio2</radio>  <radio value=\"radio3\">radio3</radio></radio-group><view>提示：{{text}}</view> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11Page({  data:{    // text:\"这是一个页面\"    text:''  },    radiogroupBindchange:function(e){    this.setData({      text:'您选择了'+e.detail.value    })  }}) 来自CODE的代码片三：实现button点击事件改变数据值关键代码index.wxml 1\r\n 2\r\n 3\r\n 4<button type=\"default\" bindtap=\"btn_default\">default类型按钮</button><button type=\"primary\" bindtap=\"btn_primary\">primary类型按钮</button><button type=\"warn\" bindtap=\"btn_warn\">warn类型按钮</button><view>提示：{{text}}</view> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21Page({  data:{    // text:\"这是一个页面\"    text:''  },  btn_default:function(){    this.setData({      text:'您单击了default按钮'    })  },  btn_primary:function(){    this.setData({      text:'您单击了primary按钮'    })  },  btn_warn:function(){    this.setData({      text:'您单击了warn按钮'    })  }}) 来自CODE的代码片四：使用modal组件弹出对话框关键代码1、index.wxml 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6<view>提示：{{tip}}</view><button type=\"default\" bindtap=\"showModal\">点击我弹出modal对话框</button><view>  <modal title=\"modal对话框\" hidden=\"{{modalHidden}}\" confirm-text=\"确定\" cancel-text=\"取消\"  bindconfirm=\"modalBindaconfirm\" bindcancel=\"modalBindcancel\">您好，我是modal对话框</modal></view> 来自CODE的代码片snippet_file_0.txt2、index.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21\r\n 22\r\n 23\r\n 24\r\n 25\r\n 26\r\n 27\r\n 28Page({  data:{    // text:\"这是一个页面\"    tip:'',    buttonDisabled:false,    modalHidden:true,    show:false  },  showModal:function(){    this.setData({      modalHidden:!this.data.modalHidden    })  },  modalBindaconfirm:function(){     this.setData({      modalHidden:!this.data.modalHidden,      show:!this.data.show,      tip:'您点击了【确认】按钮！',赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              TITF出品：微信小程序实用案例代码片段大全《一》 \n              TITF出品：微信小程序实用案例代码片段大全《三》 \n            \n             \n            \n                  原作者: TITF \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《一》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《三》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《四》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《五》：ES6新特性专辑 ...\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《六》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《七》\n                                    \n                  • TITF：点击按钮修改字体颜色/文字大小，动态修改标签的透明度，改变view标签的宽度和 ...\n                                    \n                  • TITF：tabBar的使用小技巧（附数据绑定一个对象到数组中，然后取值的一个注意点） ...\n                                    \n                  • 微信小程序中JavaScript代码书写习惯与命名规范建议\n                                    \n                  • 微信小程序实用功能代码分享\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155896|692bc4540272970527f4fa91b3170899|2';"}
{"title": "TITF出品：微信小程序实用案例代码片段大全《三》 ", "author": "天下雪", "pub_time": "2016-10-27 15:50", "content": "一：使用image组件显示图片关键代码1、index.wxml 1<image style=\"width: 300px; height: 300px; margin:10px;\" mode=\"scaleToFill\" src=\"{{imageSrc}}\"></image> 来自CODE的代码片snippet_file_0.txt2、index.js 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6Page({  data:{    // text:\"这是一个页面\"    imageSrc:'../../pages/image/img.png'  }}) 来自CODE的代码片二：使用video组件播放视频index.wxml 1<video src=\"http://www.w3school.com.cn//i/movie.mp4\" binderror=\"videoErrorCallback\"></video>赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              TITF出品：微信小程序实用案例代码片段大全《二》 \n              TITF出品：微信小程序实用案例代码片段大全《四》 \n            \n             \n            \n                  原作者: TITF \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《一》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《二》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《四》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《五》：ES6新特性专辑 ...\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《六》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《七》\n                                    \n                  • TITF：点击按钮修改字体颜色/文字大小，动态修改标签的透明度，改变view标签的宽度和 ...\n                                    \n                  • TITF：tabBar的使用小技巧（附数据绑定一个对象到数组中，然后取值的一个注意点） ...\n                                    \n                  • 微信小程序中JavaScript代码书写习惯与命名规范建议\n                                    \n                  • 微信小程序实用功能代码分享\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155897|de209af8735aea921cd06ab0f5126b38|2';"}
{"title": "TITF出品：微信小程序实用案例代码片段大全《四》 ", "author": "天下雪", "pub_time": "2016-10-27 16:14", "content": "一：使用画布组件绘制一个半径为50px的圆关键代码index.wxml 1<canvas style=\"width:300px; height:100px;\" canvas-id=\"canvasArc\"></canvas> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14Page({  onReady:function(){    // 页面渲染完成    var cxt_arc=wx.createContext();//创建并返回绘图上下文context对象。    cxt_arc.beginPath();//开始一个新的路径    cxt_arc.arc(100,50,50,0,2*Math.PI,true);//设置一个原点(100,50)，半径为为50的圆的路径到当前路径    cxt_arc.stroke();//对当前路径进行描边    cxt_arc.closePath();//关闭当前路径    wx.drawCanvas({      canvasId:'canvasArc',//画布标识，对应<canvas/>的cavas-id      actions:cxt_arc.getActions()//导出context绘制的直线并显示到页面    })  }})二：使用画布组件绘制一个会自动缩放的正方体关键代码index.wxml 1empty 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19Page({  onReady:function(e){    var cxt_scale = wx.createContext();//创建并返回绘图上下文context对象。    var scale=0;//默认缩放倍数为0，大于0为放大，小于0位缩小    setInterval(function(){ //无限循环定时函数       scale+=0.5;// 向缩小后放大      if(scale==10){//但放大位数为10倍时，设置放大倍数为1        scale=1      }      cxt_scale.scale(scale,scale)//对横纵坐标进行缩放      cxt_scale.rect(0,0,10,10)//边长为为10px的正方形      cxt_scale.stroke();//对当前路径进行描边      wx.drawCanvas({      canvasId:'canvasAutoScale',//画布标识，对应<canvas/>的cavas-id      actions:cxt_scale.getActions()//导出context绘制的直线并显示到页面    });    },200)      }}) 来自CODE的代码片三：使用画布组件绘制一条长度为230px的水平直线关键代码index.wxml 1empty 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14Page({  onReady:function(e){    var context = wx.createContext();//创建并返回绘图上下文context对象。    context.beginPath();//开始一个新的路径    context.moveTo(30,40);//路径的起点    context.lineTo(260,40);//路径的终点    context.stroke();//对当前路径进行描边    context.closePath();//关闭当前路径    wx.drawCanvas({//      canvasId:'canvasLine',//画布标识，对应<canvas/>的cavas-id      actions:context.getActions()//导出context绘制的直线并显示到页面    });  }}) 来自CODE的代码片四：使用画布组件绘制一个长200px，宽100px的长方形关键代码index.wxml 1<canvas style=\"width:300px;height:200px;\" canvas-id=\"canvasRect\"></canvas> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14Page({  onReady:function(){    // 页面渲染完成    var ctxt_rect=wx.createContext();//创建并返回绘图上下文context对象。    ctxt_rect.beginPath();//开始一个新的路径    ctxt_rect.rect(10,10,200,100);//添加一个长度为200px、宽度为为100px的矩形路径到当前路径    ctxt_rect.stroke();//对当前路径进行描边    ctxt_rect.closePath();//关闭当前路径    wx.drawCanvas({      canvasId:'canvasRect',//画布标识，对应<canvas/>的cavas-id      actions:ctxt_rect.getActions()//导出context绘制的矩形路径并显示到页面    })  }}) 来自CODE的代码片五：使用画布组件绘制一个会自动旋转的正方体关键代码index.wxml 1empty 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17Page({  onReady:function(e){    var cxt_rotate = wx.createContext();//创建并返回绘图上下文context对象。    var rotate=0;//默认旋转角度为为0    setInterval(function(){ //无限循环定时函数          cxt_rotate.translate(150,100);//设置坐标系坐标      rotate++;//旋转角度自增1      cxt_rotate.rotate(rotate*Math.PI/180)//设置旋转的角度      cxt_rotate.rect(0,0,50,50)//设置坐标(0,0)，相对于坐标系坐标，边长为为50px的正方形      cxt_rotate.stroke();//对当前路径进行描边      wx.drawCanvas({      canvasId:'canvasAutoRotate',//画布标识，对应<canvas/>的cavas-id      actions:cxt_rotate.getActions()//导出context绘制的直线并显示到页面    });    },1)      }}) 来自CODE的代码片六：使用画布组件绘制一个带阴影及下划线的文字关键代码index.wxml 1empty 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21Page({  onReady:function(){    // 页面渲染完成    var cxt_fillText = wx.createContext();//创建并返回绘图上下文context对象。    cxt_fillText.beginPath();//开始一个新的路径    cxt_fillText.setFontSize(60);//设置填充文本字体的大小    cxt_fillText.setLineWidth(6);//设置线条的宽度    cxt_fillText.setShadow(0,10,30,'#33ffff');//设置阴影    cxt_fillText.setStrokeStyle('#33ff66');//设置线条的样式    cxt_fillText.setFillStyle('#3300ff');//设置填充的样式    cxt_fillText.fillText(\"TITF\",50,100);//设置填充文本fillText()第一个值为显示的文本，第二个值为文本的x坐标，第三个值为文本的y坐标    cxt_fillText.moveTo(40,105);//设置线条的起始路径坐标    cxt_fillText.lineTo(180,105);//设置线条的终点路径坐标    cxt_fillText.stroke();//对当前路径进行描边    cxt_fillText.closePath();//关闭当前路径    wx.drawCanvas({      canvasId:'canvasFillText',//画布标识，对应<canvas/>的cavas-id      actions:cxt_fillText.getActions()//导出context绘制的直线并显示到页面    })  }}) 来自CODE的代码片"}
{"title": "TITF出品：微信小程序实用案例代码片段大全《五》：ES6新特性专辑 ... ", "author": "天下雪", "pub_time": "2016-10-27 16:24", "content": "一：通过增强对象字面量创建方法，省略function写法1、增强对象字面量简介在增强对象字面量中创建方法，可省略function关键字可以在增强对象字面量中定义原型，即继承某个增强对象字面量可以直接调用父类中的方法2、关键代码index.wxml 1<button type=\"default\" bindtap=\"enhanceObjectLiteral\">点击显示增强对象字面量效果</button> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16Page({  data:{    // text:\"这是一个页面\"  },  enhanceObjectLiteral:function(){    //通过对象字面量创建对象    var province={      //在该对象中创建一个方法，此处可以发现这种创建方式是不需要用到function      provinceName(provinceName){        console.log(provinceName);      }    }    //调用province对象中的provinceName方法，此时控制台显示出的是数据是“广州”    province.provinceName(\"广州\");  }}) 来自CODE的代码片二：字符串模板：美元符号$+大括号{}变量的写法1、字符串模板简介ES6新特性中的字符串模板允许使用英文字符抑音符号`（提示：这里我们不能将其理解为单引号）来创建字符串，并且在该字符串中可以包含都【美元符号+大括号】包裹的变量格式：console.log(`ES6新特性：${name}`)说明：格式中的name为变量名2、关键代码index.wxml 1<button type=\"default\" bindtap=\"stringTemplate\">点击我控制台输出字符串模块数据</button> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10Page({  data:{    // text:\"这是一个页面\"    stringTemplateTxt:''  },  stringTemplate:function(){    var stringTemplateTxt=\"字符串模板数据\"//定义一个变量并初始化值        console.log(`我是${stringTemplateTxt}`)//将stringTemplateTxt变量的值输出到控制台  }}) 来自CODE的代码片三：使用解构数组优化变量格式1、解构数组简介特点：通过解构数组，我们可以将多个值返回成为一个数组，并将数组中的值赋予到对应的变量名中。格式：[province,city]=['guangong','guangzhou']2、关键代码index.wxml 1\r\n 2\r\n 3<view>{{jiegouArray}}</view><view>{{jiegouDat}}</view><button type=\"default\" bindtap=\"jiegouBind\">点击我显示用数组解构后的数据</button> 来自CODE的代码片snippet_file_0.txt四：使用箭头操作符简化回调函数繁琐的编写过程1、类操作简介箭头操作符格式：inputs=>outputs；箭头操作符的出现是为了解决JavaScript中回调函数繁琐的编程步骤。2、关键代码index.wxml 1<button type=\"default\" bindtap=\"consoleLog\">点击实现控制台数据输出</button> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14Page({  data:{    // text:\"这是一个页面\"  },    consoleLog:function(){    var numArray=[0,1,2,3,4,5];    //es6新特性：箭头表示符写法    numArray.forEach(serialNum=>console.log('我是新特性显示出来的数据：'+serialNum));    //传统写法    numArray.forEach(function(serialNum){      console.log('我是传统写法显示出来的数据：'+serialNum);    })  }}) 来自CODE的代码片五：通过对类的操作来处理数据后显示在视图界面1、类操作简介关键字： class类的出现可以更加直观的将对象的创建和继承的代码显示在编程员前。2、关键代码index.wxml 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6<button type=\"default\" bindtap=\"showAreas\">点击我显示所有地区</button><view class=\"areas\">  <block wx:for-items=\"{{areas}}\">    <view class=\"area\">{{item}}</view>  </block></view> 来自CODE的代码片snippet_file_0.txtindex.js  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21\r\n 22\r\n 23\r\n 24\r\n 25\r\n 26\r\n 27\r\n 28\r\n 29\r\n 30\r\n 31\r\n 32\r\n 33var dat=[  {provice:'北京',city:'朝阳市'},  {provice:'上海',city:'虹口区'},  {provice:'广东',city:'广州市'},  {provice:'广东',city:'深圳市'},];class areaCls{  //构造函数  constructor(provice,city){    this.provice=provice;    this.city=city;  }  //实例方法  showAreaInfo(){    return '省（市）：'+this.provice+',市（区）'+this.city+'。'  }}var areas=[]for(var i=0,len=dat.length;i<len;i++){  //创建对象并调用实例方法，最后的实例方法中的值赋予到数据areas里面  areas[i]=new areaCls(dat[i].provice,dat[i].city).showAreaInfo();  }Page({  data:{    // text:\"这是一个页面\"    areas:[]  },    showAreas:function(){    this.setData({      areas:areas    })      }}) 来自CODE的代码片"}
{"title": "TITF出品：微信小程序实用案例代码片段大全《六》 ", "author": "天下雪", "pub_time": "2016-10-27 16:43", "content": "一：使用画布组件绘制一个半径为50px的圆关键代码index.wxml赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              TITF出品：微信小程序实用案例代码片段大全《五》：ES6新特性专辑 ... \n              微信小程序开发之画布canvas 饼状图 \n            \n             \n            \n                  原作者: FutrueJet \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《一》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《二》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《三》\n                                    \n                  • TITF出品：微信小程序实用案例代码片段大全《七》\n                                    \n                  • TITF：点击按钮修改字体颜色/文字大小，动态修改标签的透明度，改变view标签的宽度和 ...\n                                    \n                  • TITF：tabBar的使用小技巧（附数据绑定一个对象到数组中，然后取值的一个注意点） ...\n                                    \n                  • 微信小程序中JavaScript代码书写习惯与命名规范建议\n                                    \n                  • 微信小程序实用功能代码分享\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cShu171r', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1583155901|6de01967f329f86a04e3dcd0886b6f92|2';"}
{"title": "微信小程序开发之画布canvas 饼状图 ", "author": "天下雪", "pub_time": "2016-10-28 12:32", "content": "微信小程序开发的时候会遇到统计功能的开放.今天想做一个饼状图,群里有朋友造了轮子,我整理了一下,加了一些注释,分享出来.先说说canvas:1.微信里面canvas标签默认宽度300px、高度225px,可自行修改.2.同一页面中的 canvas-id 不可重复，如果使用一个已经出现过的 canvas-id，该 canvas 标签对应的画布将被隐藏并不再正常工作;不懂的可以看看文档.虽说并没有什么用.微信canvas文档老规矩,上图.代码:就两个文件一个wxml,一个js1.pie.js[javascript] view plain copyPage( {      onReady: function() {          // 页面渲染完成          //使用wx.createContext获取绘图上下文context          var context = wx.createContext();          // 画饼图          //    数据源          var array = [ 20, 30, 40, 50 ];          var colors = [ \"#ff0000\", \"#ffff00\", \"#0000ff\", \"#00ff00\" ];          var total = 0;          //    计算总量          for( var index = 0;index < array.length;index++ ) {              total += array[ index ];          }          //    定义圆心坐标          var point = { x: 100, y: 100 };          //    定义半径大小          var radius = 60;          /*    循环遍历所有的pie */          for( var i = 0;i < array.length;i++ ) {              context.beginPath();              //      起点弧度              var start = 0;              if( i > 0 ) {                  // 计算开始弧度是前几项的总和，即从之前的基础的上继续作画                  for( var j = 0;j < i;j++ ) {                      start += array[ j ] / total * 2 * Math.PI;                  }              }              console.log( \"i:\" + i );              console.log( \"start:\" + start );              //      1.先做第一个pie              //      2.画一条弧，并填充成三角饼pie，前2个参数确定圆心，第3参数为半径，第4参数起始旋转弧度数，第5参数本次扫过的弧度数，第6个参数为时针方向-false为顺时针              context.arc( point.x, point.y, radius, start, array[ i ] / total * 2 * Math.PI, false );              //      3.连线回圆心              context.lineTo( point.x, point.y );              //      4.填充样式              context.setFillStyle( colors[ i ] );              //      5.填充动作              context.fill();              context.closePath();          }          //调用wx.drawCanvas，通过canvasId指定在哪张画布上绘制，通过actions指定绘制行为          wx.drawCanvas( {              //指定canvasId,canvas 组件的唯一标识符              canvasId: 'mypie',              actions: context.getActions()          });      }  })  注释已经写好.看起来很方便.2.pie.wxml[html] view plain copy<!--通过canvas-id引入canvas-->  <canvas canvas-id=\"mypie\" style=\"width:200px;height:200px;\"></canvas>"}
{"title": "微信小程序把玩《十二》：Video API，Storage API，location API ", "author": "天下雪", "pub_time": "2016-10-28 13:31", "content": "一：Video API电脑端不能测试拍摄功能只能测试选择视频功能，好像只支持mp4格式，值得注意的是成功之后返回的临时文件路径是个列表tempFilePaths而不是tempFilePath文档写的有点问题。主要属性：wx.chooseVideo(object)成功之后返回参数wxml<button type=\"primary\" bindtap=\"listenerBtnOpenVideo\">打开视频</button>\r\n<!--默认视频组件是隐藏的-->\r\n<video src=\"{{videoSource}}\" hidden=\"{{videoHidden}}\" style=\"width: 100%; height: 100%\"/>123123jsPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    videoSource: '',\r\n    videoHidden: true\r\n  },\r\n\r\n listenerBtnOpenVideo: function() {\r\n     var that = this;\r\n     wx.chooseVideo({\r\n         //相机和相册\r\n         sourceType: ['album', 'camera'],\r\n         //录制视频最大时长\r\n         maxDuration: 60,\r\n         //摄像头\r\n         camera: ['front', 'back'],\r\n         //这里返回的是tempFilePaths并不是tempFilePath\r\n         success: function(res){\r\n           console.log(res.tempFilePaths[0])\r\n             that.setData({\r\n                 videoSource: res.tempFilePaths[0],\r\n                 videoHidden: false\r\n             })\r\n         },\r\n         fail: function(e) {\r\n           console.log(e)\r\n         }\r\n     })\r\n },\r\n\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})二：Storage API其实这个存储在新建Demo的时候就已经用到了就是存储就是那个logs日志，数据存储主要分为同步和异步异步存储方法：存数据 wx.setStorage(object) 相同key会覆盖，可写回调方法获取方法：wx.getStorage(object)清除方法：wx.clearStorage()里面可以写回调函数 成功，失败，完成同步存储方法：存数据 相同key会覆盖wx.setStorageSync(key,data)读数据wx.getStorageSync(key) 存储是指定的key清除数据wx.clearStorageSync() 不可写回调方法wxml<!--动态获取数据-->\r\n<text>{{storageContent}}</text>\r\n<!--存-->\r\n<button type=\"primary\" bindtap=\"listenerStorageSave\">storage存储信息会在text上显示</button>\r\n<!--取-->\r\n<button type=\"primary\" bindtap=\"listenerStorageGet\">获取storage存储的信息</button>\r\n<!--清-->\r\n<button type=\"warn\" bindtap=\"listenerStorageClear\">清楚异步存储数据</button>\r\n\r\n\r\n<text>{{storageSyncContent}}</text>\r\n<button type=\"primary\" bindtap=\"listenerStorageSyncSave\">storageSync存储信息会在text上显示</button>\r\n<button type=\"primary\" bindtap=\"listenerStorageSyncGet\">获取storageSync存储信息</button>\r\n<button type=\"warn\" bindtap=\"listenerStorageSyncClear\">清除同步存储数据</button>12345678910111213141234567891011121314jsPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    storageContent: '',\r\n    storageSyncContent: ''\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 异步存储\r\n   */\r\n  listenerStorageSave: function() {\r\n    //以键值对的形式存储 传进去的是个对象\r\n    wx.setStorage({\r\n      key: 'key',\r\n      data: '我是storeage异步存储的信息',\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 异步取信息\r\n   */\r\n  listenerStorageGet: function() {\r\n    var that = this;\r\n    wx.getStorage({\r\n      //获取数据的key\r\n      key: 'key',\r\n      success: function(res) {\r\n        console.log(res)\r\n        that.setData({\r\n          //\r\n          storageContent: res.data\r\n        })\r\n      },\r\n      /**\r\n       * 失败会调用\r\n       */\r\n      fail: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 清除数据\r\n   */\r\n  listenerStorageClear: function() {\r\n    var that = this;\r\n    wx.clearStorage({\r\n      success: function(res) {\r\n        that.setData({\r\n          storageContent: ''\r\n        })\r\n      }\r\n    })\r\n  },\r\n\r\n\r\n  /**\r\n   * 数据同步存储\r\n   */\r\n  listenerStorageSyncSave: function() {\r\n    wx.setStorageSync('key', '我是同步存储的数据')\r\n  },\r\n\r\n  /**\r\n   * 数据同步获取\r\n   */\r\n  listenerStorageSyncGet: function() {\r\n    // var that = this;\r\n    var value = wx.getStorageSync('key')\r\n    this.setData({\r\n      storageSyncContent: value\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 清除同步存储数据\r\n   */\r\n  listenerStorageSyncClear: function() {\r\n    wx.clearStorageSync()\r\n  },\r\n\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})三：location APIlocation API也就分这里分两种wx.getLocation(object)获取当前位置和wx.openLocation(object)通过经纬度打开内置地图。其中定位获取位置信息返回参数是有问题的speed，accuracy这两个是没有的。还有一个就是打开内置地图之后再返回会报一个错误(Page route错误—WAService.js:2 navigateBack 一个不存在的webviewId0)如果有知道的可告知，我找到解决方式也会补充下！主要属性：wx.getLocation(object)获取当前位置成功之后返回参数wx.openLocation(object)打开微信内置地图这里直接进入微信内置应用，当使用导航返回键时是内部写的外界无法干预所以WAService.js:2 navigateBack 一个不存在的webviewId0这个错估计也带等小程序修复吧！！wxml<button id=\"0\" type=\"primary\" bindtap=\"listenerBtnGetLocation\">定位当前位置并打开内置地图</button>11jsPage({\r\n  data:{\r\n    text:\"Page location\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n\r\n  /**\r\n   * 监听定位到当前位置\r\n   */\r\n  listenerBtnGetLocation: function() {\r\n    wx.getLocation({\r\n      //定位类型 wgs84, gcj02\r\n      type: 'gcj02',\r\n      success: function(res) {\r\n        console.log(res)\r\n        wx.openLocation({\r\n          //当前经纬度\r\n          latitude: res.latutude,\r\n          longitude: res.longitude,\r\n          //缩放级别默认28\r\n          scale: 28,\r\n          //位置名\r\n          name: '测试地址',\r\n          //详细地址\r\n          address: '火星路24号',\r\n          //成功打印信息\r\n          success: function(res) {\r\n            console.log(res)\r\n          },\r\n          //失败打印信息\r\n          fail: function(err) {\r\n            console.log(err)\r\n          },\r\n          //完成打印信息\r\n          complete: function(info){\r\n            console.log(info)\r\n          },\r\n        })\r\n\r\n      },\r\n      fail: function(err) {\r\n        console.log(err)\r\n      },\r\n      complete: function(info) {\r\n        console.log(info)\r\n      },\r\n    })\r\n  },\r\n\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})"}
{"title": "微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ... ", "author": "天下雪", "pub_time": "2016-10-28 13:39", "content": "一：获取设备信息 API获取设备信息这里分为四种，主要属性：网络信息wx.getNetWorkType, 系统信息wx.getSystemInfo,重力感应数据wx.onAccelerometerChange,罗盘数据wx.onCompassChangewxml<button type=\"primary\" bindtap=\"getNetWorkType\">获取网络类型</button>\r\n<button type=\"primary\" bindtap=\"getSystemInfo\">获取设备信息</button>\r\n<button type=\"primary\" bindtap=\"onAccelerometerChange\">监听重力感应数据</button>\r\n<button type=\"primary\" bindtap=\"onCompassChange\">监听罗盘数据</button>12341234jsPage({\r\n  data:{\r\n    text:\"Page system\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 获取当前网络状态\r\n   */\r\n  getNetWorkType: function() {\r\n    wx.getNetworkType({\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   *  获取系统信息\r\n   */\r\n  getSystemInfo: function() {\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   *  监听重力感应数据     \r\n   *      - 带on开头的都是监听接收一个callback\r\n   */\r\n  onAccelerometerChange: function() {\r\n    wx.onAccelerometerChange(function(res) {\r\n      console.log(res)\r\n    })\r\n  },\r\n    /**\r\n   *  监听罗盘数据\r\n   */\r\n  onCompassChange: function() {\r\n    wx.onCompassChange(function(res) {\r\n      console.log(res)\r\n    })\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})二：navigation API小程序也就提供这几个处理导航控制值得注意的是只能同时导航五个页面\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(51, 51, 51); font-family: 'microsoft yahei'; line-height: 26px; background-color: rgb(255, 255, 255);\">演示效果也看到了小程序也就提供这几个处理导航控制。值得注意的是只能同时导航五个页面主要属性：导航条一些方法wx.setNavigationBarTitle(object) 设置导航条的Title导航标题可以通过三种方式设置，第一种是通过全局配置名字统一，第二种就是在page中新建个json文件配置它会覆盖全局配置的title，第三种就是通过API设置。wx.showNavigationBarLoading()设置在导航条上显示Loading加载状态wx.hideNavigationBarLoading() 隐藏Loading加载状态导航视图的一些方法wx.navigateTo() 保留当前页面进行跳转，传参时就像拼接GET参数一样即可，代码中会有体现wx.redirectTo() 销毁当前页面进行跳转，wx.navigateBack() 返回上一个页面wxml<button type=\"primary\" bindtap=\"setNavigationBarTitle\">设置navigationBarTitle</button>\r\n<button type=\"primary\" bindtap=\"showNavigationBarLoading\">设置navigationBarLoading加载状态</button>\r\n<button type=\"primary\" bindtap=\"hiddenNavigationBarLoading\">隐藏navigationBarLoading加载状态</button>\r\n<button type=\"warn\" bindtap=\"navigateTo\"> 保留当前页跳转</button>\r\n<button type=\"warn\" bindtap=\"redirectTo\"> 不保留当前页面跳转</button>\r\n<button type=\"warn\" bindtap=\"navigateBack\">退回到上一个页面</button>123456123456json{\r\n    \"navigationBarTitleText\": \"我是通过json配置的title\"\r\n}123123js//导入另一个页面\r\nvar file = '../audio/audio'\r\nPage({\r\n  data:{\r\n    text:\"Page navigation\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 设置NavigationTitle\r\n   */\r\n  setNavigationBarTitle: function() {\r\n    wx.setNavigationBarTitle({\r\n      title: '我是通过API设置的NavigationBarTitle'\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 设置加载状态\r\n   */\r\n  showNavigationBarLoading: function() {\r\n    wx.showNavigationBarLoading()\r\n  },\r\n\r\n  /**\r\n   * 隐藏加载状态\r\n   */\r\n  hiddenNavigationBarLoading: function() {\r\n    wx.hideNavigationBarLoading()\r\n  },\r\n\r\n  /**\r\n   * 保留当前Page跳转\r\n   */\r\n  navigateTo: function() {\r\n    wx.navigateTo({\r\n      //传递参数方式向get请求拼接参数一样\r\n      url: file + '?phone=18939571&password=1992',\r\n      success: function(res) {\r\n        console.log(res)\r\n      },\r\n      fail: function(err) {\r\n        console.log(err)\r\n      }\r\n\r\n    })\r\n  },\r\n  /**\r\n   * 关闭当前页面进行跳转当前页面会销毁\r\n   */\r\n  redirectTo: function() {\r\n    wx.redirectTo({\r\n       //传递参数方式向get请求拼接参数一样\r\n      url: file + '?phone=189395719&password=1992'\r\n    })\r\n  },\r\n  /**\r\n   * 退回到上一个页面\r\n   */\r\n  navigateBack: function() {\r\n    wx.navigateBack()\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})三：animation API动画水还是比较深的，这里只是简单介绍下小程序中动画的一些属性和注意事项，做动画前一定要整理好思路将动画一步步分解，再进行组合！这里只做引入。wx.createAnimation(object)看官方介绍1.创建一个动画实例animation。调用实例的方法来描述动画。最后通过动画实例的export方法导出动画数据传递给组件的animation属性。2.调用动画操作方法后要调用 step() 来表示一组动画完成，可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。step 可以传入一个跟 wx.createAnimation() 一样的配置参数用于指定当前组动画的属性这还是比较好理解的比如第一条对应代码animation: this.animation.export() 第二条比如缩放动画，也就说是一组scale，scaleX, scaleY…为一缩放动画组的一个动画方法，缩放动画组和旋转动画组通过step()链接，按顺序执行。代码中体验吧！看效果反过来看会更容易理解主要属性：这里主要树下timingFunction和transformOrigintimingFunction 设置动画效果linear 默认为linear 动画一直较为均匀ease 开始时缓慢中间加速到快结束时减速ease-in 开始的时候缓慢ease-in-out 开始和结束时减速ease-out 结束时减速step-start 动画一开始就跳到 100% 直到动画持续时间结束 一闪而过step-end 保持 0% 的样式直到动画持续时间结束 一闪而过transformOrigin 设置动画的基点 默认%50 %50 0left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%动画组及动画方法样式：旋转：缩放：偏移：倾斜：矩阵变形：演示单个动画组效果wxml\r\n<view class=\"container\">\r\n  <view animation=\"{{animation}}\" class=\"view\">我在做动画</view>\r\n</view>\r\n<button type=\"primary\" bindtap=\"rotate\">旋转</button>1234512345jsPage({\r\n  data:{\r\n    text:\"Page animation\",\r\n    animation: ''\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //实例化一个动画\r\n    this.animation = wx.createAnimation({\r\n      // 动画持续时间，单位ms，默认值 400\r\n      duration: 1000, \r\n      /**\r\n       * http://cubic-bezier.com/#0,0,.58,1  \r\n       *  linear  动画一直较为均匀\r\n       *  ease    从匀速到加速在到匀速\r\n       *  ease-in 缓慢到匀速\r\n       *  ease-in-out 从缓慢到匀速再到缓慢\r\n       * \r\n       *  http://www.tuicool.com/articles/neqMVr\r\n       *  step-start 动画一开始就跳到 100% 直到动画持续时间结束 一闪而过\r\n       *  step-end   保持 0% 的样式直到动画持续时间结束        一闪而过\r\n       */\r\n      timingFunction: 'linear',\r\n      // 延迟多长时间开始\r\n      delay: 100,\r\n      /**\r\n       * 以什么为基点做动画  效果自己演示\r\n       * left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%\r\n       * top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%\r\n       */\r\n      transformOrigin: 'left top 0',\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 旋转\r\n   */\r\n  rotate: function() {\r\n    //顺时针旋转10度\r\n    //\r\n    this.animation.rotate(150).step()\r\n    this.setData({\r\n      //输出动画\r\n      animation: this.animation.export()\r\n    })\r\n  },\r\n\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263演示多个动画组效果这里我们只需要更改以下代码即可  /**\r\n   * 旋转\r\n   */\r\n  rotate: function() {\r\n    //两个动画组 一定要以step()结尾\r\n    /**\r\n     * 动画顺序 顺时针旋转150度>x,y 放大二倍>x，y平移10px>x,y顺时针倾斜>改变样式和设置宽度宽度\r\n     */\r\n    this.animation.rotate(150).step().scale(2).step().translate(10).step().skew(10).step().opacity(0.5).width(10).step({ducation: 8000})\r\n    this.setData({\r\n      //输出动画\r\n      animation: this.animation.export()\r\n    })\r\n  }"}
{"title": "微信小程序把玩《十四》：canvas API ", "author": "天下雪", "pub_time": "2016-10-28 13:41", "content": "绘图是每个移动应用必备的技术，基本上和Android，IOS，等移动开发都是相同的，创建个上下文，给你个画布再上画，官网给的小例子都比较全了自己去看吧，drawImage时没有反应不知道是BUG还是电脑不能测试待定，http://wxopen.notedown.cn/api/api-canvas.html屏幕就像是数学上的坐标轴，且在第四象限，以屏幕左上角为圆点，X轴向右为正向左为负，Y轴向下为正向上为负（这点和数学上相反的）以圆点为基点画个距离圆点上下50宽高100的矩形来演示canvas基本用法微信小程序这里提供了两个APIwx.createContext() 创建并返回绘图上下文context对象getActions 获取当前context上存储的绘图动作，对应wx.drawCanvas(object)中的actionsclearActions 清空当前的存储绘图动作wx.drawCanvas(object) 绘制canvasId 画布标识，传入的cavas-id，这里的标识可以为Number，也可以是Stringactions 绘图动作数组，由wx.createContext创建的context，调用getActions方法导出绘图动作数组。绘图中可以进行变形，绘制，路径，样式，这些个东西有点多官网有例子，这里通过一个例子引入wxml<!--画布\r\n  canvas-id 为画布标识，当绘制时通过canvas-id找到画布\r\n-->\r\n<canvas canvas-id=\"identify\"/>12341234jsPage({\r\n  data:{\r\n    text:\"Page canvas\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //第一步创建个上下文容器\r\n    var context = wx.createContext();\r\n\r\n    //第二步绘制这里我们绘制个矩形 \r\n    //x, y, widht, height\r\n    context.rect(50, 50, 100, 100);\r\n    //绘制的样式进行描边绘制，fill为填充位置\r\n    context.stroke();\r\n    /**\r\n     *  调用wx.drawCanvas，通过canvasId指定在哪张画布上绘制，通过actions指定绘制行为\r\n     * \r\n     *    注意convasId可以为数字表示也可以用字符串表示，就是一个绘制对象的标识，并且可以指定多个\r\n     *    actions 是从context上下文中获取的绘制行为，即为第二步操作\r\n     */\r\n\r\n    wx.drawCanvas({\r\n      //画布标识，传入<canvas/>的cavas-id\r\n      canvasId: 'identify',\r\n      //获取绘制行为， 就相当于你想做到菜context.getActions()就是食材\r\n      actions: context.getActions(),\r\n    })\r\n\r\n\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})"}
{"title": "小程序微信支付不完全接入指南 ", "author": "天下雪", "pub_time": "2016-10-28 13:51", "content": "微信支付在 2013 年发布，作为内测开发者一路走来，可以感觉到微信支付接口稳定程度、文档的准确性都有质的提升。围绕支付相关的场景也配备对应的接口。本次小程序的发布，随机附送了一个微信支付模块，该模块使用起来的情况如何，就由我来告诉你吧。业务流抛开小程序的微信支付模块，我们总览微信支付的一些基本情况。微信支付有以下支付模式:微信客户端内的网页支付 (JSAPI)扫码支付 (PC 端，移动支付终端)刷卡支付 (支付终端扫描)app 支付 (iOS, Android)各种支付交互流程可通过微信文档进行查看，在此不赘述。支付发起所有支付方式都需要通过 『统一下单』的 API 来进行获取一个支付凭证，在内测以及刚发布的微信支付，是没有『统一下单』的概念，HTML 5 应用发起支付可以直接通过前端构造参数来进行发起。此时微信支付开发者很容易就造成支付凭证泄露等安全问题。为此，微信支付将其流程做了优化，在所有支付场景中插入『统一下单』，推荐开发者在后端完成支付参数的构建等行为。该优化带来以下好处:尽可能让开发者不犯低级错误，造成财务损失。简化构造支付参数的复杂度，所有支付方式可共享一个支付后端接口通过『统一下单』获取到相对应 prepay_id 或者 code_url 等参数，即可通过各种支付模式的 SDK 来进行微信支付的发起。支付结果接收微信支付发起完成后，微信还需要提供一个通知系统，以便及时让应用知道用户已经完成支付，可以进行下一步的业务操作。通知方式为一个 POST 请求，payload 为支付的状态信息，以及支付订单信息。注意必须对通知参数进行签名验证，以确保安全。进行签名验证时，除去签名字段，一般参数名为: sign，不需要参与签名外，其余所有接收到的参数均需要参与签名。周边接口通过 『支付发起』，『支付结果接收』，即可完成一个简单的微信支付系统。当然，微信还提供一下接口:查询订单取消订单申请退款查询退款下载对账单具体使用可以参考微信文档，根据自身业务情况适当的进行采用。绊脚石嗯，没错，我们吃了一次螃蟹，小程序刚内测，我们就决定使用微信支付模块，毕竟我们要实现的是一个电商应用 (电商没支付算什么嘛。开发过程中，我们掉了一些坑。支付凭证小程序的微信支付需要单独去申请，因为小程序是有独立的 appid，不能使用以前的支付账户，即使是全网发布也不能，因为小程序不是一个 HTML 5 应用。签名方式MD5! MD5! MD5!微信公众文档有很多 SHA1, MD5 的签名要求，微信支付相关的签名，暂时暂时暂时都是使用 MD5。小程序端在发起微信支付的时候是通过以下方式来进行发起:按照微信文档签名的要求，参与签名的字段应该为timeStampnonceStrpackagesignTypeok，按照签名算法得到的签名，去发起支付，居然提示失败了，经过与微信对接人员沟通后，参与签名的字段还需要加上 appid, 哦，不对，是 appId（请严重区分驼峰命名的大小写）。对这样的结果我表示不服，随即我翻阅了微信支付所有文档，终于在微信 JSSDK 的文档中找到一行备注。备注：prepay_id 通过微信支付统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的 appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr, package, signType。怪我咯(黑人问号) 点我去取笑!timestamp 类型小程序端发起微信支付的方式已经贴在上面了，但没那么简单，继续贴文档说明。timeStamp DateInt 时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间文档告诉我们 timeStamp 应该带着 int 类型传入。我们前端的同学照做了，然后就过来骂我。你们后端参数是不是有问题!!! 提示 timeStamp 不存在了都经过排查，传入的 timeStamp 的值类型应该为 String结尾语总体上小程序接入微信支付还是比较简单的，没有过多复杂的设置，如果之前开发过微信支付后端的开发者，还可以复用同一个支付模块。文档的编写不严谨，使得开发舒爽度严重被削减。相信随着时间推进，文档会慢慢完善，毕竟以前也是这么过来的。"}
{"title": "微信小程序组件默认样式优先级 bug 解析 ", "author": "天下雪", "pub_time": "2016-10-28 13:54", "content": "在当前版本（iOS 客户端 6.3.27，开发工具 0.10.101400）中，微信小程序在 wxss 中存在一个优先级导致的 bug。官方文档中提到可以使用标签选择器，控制同一类组件的样式。如：使用 input 标签选择器控制<input/> 的默认样式此处存在一个比较明显的 bug，小程序中的组件大部分都是有默认的样式的，例如 image 组件就存在四个默认样式，其中一个默认样式为 display: inline-block。如果试图使用上述的标签选择器设置 image 的 display 属性，会发现并没有生效。而通过开发者工具可以查看到，设置没有生效的原因是 image 组件默认的样式优先级高于我们通过标签选择器设置的样式。经过测试，基本上所有组件的默认样式的优先级都会高于通过标签选择器设置的样式，而 class 选择器和 id 选择器的优先级还是高于默认样式。因此，目前如果想改变组件默认的样式，不能标签选择器直接设置，而是应该给需要改变默认样式的组件赋予同样的 class，再通过此 class 来改变默认样式。这个优先级的 bug，除了上述的所有组件默认样式的问题之外，针对某些特殊组件，如 button，还有更进一步的问题。button 组件可以分别设置 size、type 和 plain 三种属性，从而显示不同的按钮样式。测试中发现，如果着三种属性使用了非默认值之外的值，例如 type=“primary”，除了 button 组件默认的样式之外，type 为 primary 的 button 还会有额外的两个默认样式color: #FFFFFF 和 background-color: #1AAD19。此时如果通过 class 选择器设置 color 为其它值，会发现并没有生效。同样，通过开发者工具可以看到，type 为 primary 时的 button 的两个“额外”默认样式的优先级高于 class 选择器。因此在此种情况下，只能通过 id 选择器才能改变上述的两个“额外”默认样式。此外，有一点值得提醒的是。实际开发（真机及模拟器）中会发现目前 wxss 中是可以使用级联选择器的，及类似.parent .child { width: 100%; }由此则衍生出来一个比较优雅的解决上述 bug 的方法：修改 container 下 所有 image 组件的默认样式.container image { display: block; }改变 button[type=”primary”] 的“额外”默认样式.container .btn { color: red; }由此也可猜测上述 bug 出现的原因，可能是由于小程序的组件默认样式的实现过程中使用了类似标签选择器和类选择器，但没有控制好优先级导致。但是，请注意：不要使用此方法！不要使用此方法！不要使用此方法！官方文档中明确说明样式表不支持级联选择器不推荐使用官方文档中明确表明不能使用的方法。目前小程序还是处于内测阶段，此方法还能使用，只是官方的疏忽，很有可能此方法会突然无法使用。此外根据微信小程序内测群中的消息：目前还能用级联选择器是由于还没有过滤掉级联选择器。而级联选择有可能会破坏掉基础组件的一些样式，因此后续有时间了就会加上过滤。推荐使用 BEM，同时，后续也可能会加上不会破坏基础组件的级联方法，不过此需求的优先级会低一些。"}
{"title": "微信小程序之运维小项目 ", "author": "天下雪", "pub_time": "2016-10-28 15:13", "content": "自从微信推出小程序以来，现在业界炒的非常的火，具说叫微信小程序是因为某公司不让叫应用号，我在朋友圈也看过pony的和张小龙朋友圈关于名字的讨论截图，不知道是真是假，反正名字是定了，叫啥无所谓，还是知道它是干啥的比较重要， 像网上说什么新风口了，原生APP以后没活路了等相关文章喜欢的可以多看看， 我们今天不会在产品层面上去介绍小程序，因为我们是搞运维的，所以我还是在运维层面怎么使用小程序， 今天我们用实际例子来讲解和普及小小程序如何使用，来实现类似IP138的功能，输入IP可以查看IP的详细信息，包括归属，地点等，我们先看下完成后的效果：基本功能就是做一个IP查询的页面，输入ip，能够查询IP的详细信息，后台调用的淘宝的IP库，OK，界面和功能就是这样了，比较简单，接下来我们来介绍小程序的基本概念和使用。第一步，先下载微信小程序开发者工具，这个是必须的，因为只能在这个工具里去调试你的代码，但写代码不一定要在这个工具里去写，在Sublime 里写也可以，但调试你必须在这工具里，关于怎么下怎么装这我就不多说了，如果这步都没搞定我觉得往下看也没啥意义了，当然是开个玩笑，如果有问题的，可以给我留言。安装后，第一次运行需要用微信扫描，来识别开发者，然后添加项目，微信开发者工具可以帮你生成一个简单的demo项目，生成项目后如图： 我们先看app.js、app.json、app.wxss 这三个，其中app.js 是小程序的脚本代码,可以定义全局变量， 指定小程序的生命周期函数（onLaunch，onShow，onHide，其它），app.json文件是配置文件，主要配置小程序的页面，所有的页面设置都要写在这个文件里app.wxss 是公共样式表文件。除了这些文件，我们还有两个目录，这2个目录展示的是index 页面和 logs 页面，每个目录下如果完整的情况下都会有4个文件：如上图所示，现在每个目录下分别是index.js、index.wxml、index.wxss，其中.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件（非必须），.wxss 后缀的是样式表文件（非必须），.wxml 后缀的文件是页面结构文件。以上就是小程序的基本概念了，了解了这些，就可以开始我们的小项目开发了。首先我们先写index.wxml。代码如下： 因为界面我加了一部分样式，所以要写index.wxss样式文件，代码如下： 有了这些只是个壳子，输入IP点击查询时没有效果的， 因为我们还需要从后台获取数据，现在开始写我们的index.js文件，因为js文件内容比较多，我们分开介绍，先说下下初始化部分，刚开始都是空，然后是我们的核心函数，先判断IP是否为空，如果是就提示IP不能为空，如果有IP，就调用wx.request发请求,将获得的数据然后通过setData来赋值，如网络有问题，就报网络请求失败，代码如下：最后，查询完后需要重新输入，当用户点重置时清空所有的内容，包括刚获取的值，代码如下：完成以上代码就可以在开发者工具里调试下了，如果都正常，这个小项目就算完成了，等微信开发公测的时候就可以传到微信小程序市场里，然后每个人就可以下载去使用了。关于小程序的内容我就介绍到这里，我这里就算是抛砖引玉了，喜欢的小伙伴可以帮忙转发下，让更多的小伙伴可以学习到新的知识，另外因为小程序是非常新的东西，想更深入了解的可以去看小程序的官方文档。"}
{"title": "最新微信小程序开发工具破解v0.10.102800 ", "author": "天下雪", "pub_time": "2016-10-29 00:54", "content": "项目地址：https://github.com/jsongo/weApp-ide 项目下载：weApp-ide-master.zip最新版本v0.10.102800的破解文件，欢迎试用。这一次的更新很大，主要变化摘录如下：A 增加 四个文件管理 API wx.getSavedFileList、wx.getSavedFileInfo、wx.removeSavedFile、wx.openDocument 详情A 增加 四个数据管理 API wx.removeStorage、wx.removeStorageSync、wx.getStorageInfo、wx.getStorageInfoSync 详情A 新增 四个交互反馈 API wx.showToast、wx.showModal、wx.hideModal、wx.showActionSheet 详情A 新增 选择地理位置 API wx.chooseLocation 详情A 新增 获取图片信息 API wx.getImageInfo 详情A 新增 两个设备 API wx.getSystemInfoSync、wx.makePhoneCall 详情A 新增 绘图 API wx.canvasToTempFilePath 详情A 新增 音频媒体 API wx.createAudioContext 详情A 新增 开放能力 API wx.checkSession 详情A 新增 wx.navigateBack delta 参数，支持多层级返回 详情A 新增 wx.sendSocketMessage、wx.onSocketMessage 支持收发 ArrayBuffer 数据类型A 新增 getCurrentPages() 方法， 获取页面栈 详情A 新增 Page.onReachBottom() 方法，监听页面到达底部 详情A 新增 事件对象增加 changedTouches 列表，反应手指触摸位置的变化 详情A 新增 <textarea/> 组件 详情A 新增 <canvas/> 多点触摸 详情A 新增 <canvas/> disable-scroll 属性 详情A 新增 <image/> bindload 事件返回图片宽高 详情A 新增 <text/> 嵌套 <text/> 功能 详情A 新增 <video/> controls autoplay 属性 详情A 新增 <video/> 支持设置弹幕、发送弹幕 详情A 新增 <video/> 播放类事件和接口 详情A 新增 WXML wx:key 支持，提升列表渲染时性能 详情A 新增 WXML 关键字、数据路径计算 详情U 新增 app.json tabBar 属性 position 用于指定显示位置 详情F 修复 wx.navigateTo api 超过 5 个页面，调用失败无返回的问题U 修复 <navigator/> 设置 display: flex 失效的问题F 修复 <input/> text-align:center、text-align:right 不支持的问题F 修复 <input/> 聚焦时异常的问题F 修复 <image/> base64 图片显示的问题F 修复 动态节点更新导致表单组件重置问题F 修复 使用 rpx 单位部分手机出现边框显示不全的问题F 修复 不同页面中相同的 canvas-id 共享同一个绘图上下文的问题F 修复 page 里面的属性对象内的 function 失效的问题F 修复 wx.drawCanvas 在 canvas 宽高为 0 的情况下画不出来的问题F 修复 wx.request header 设置 'Content-Type' 异常的问题D 即将移除 App.prototype.getCurrentPage 详情D 即将移除组件： <toast/> <loading/> <action-sheet/> <modal/>D 即将移除 <audio/> action 属性1可以分析它的源码学习这套框架破解方式：把相应的文件做个替换就行。当前文件可破解版本：v0.10.102800mac上：找到开发工具的程序，右击“显示包内容”：Resources/app.nw/app/dist/components/create/createstep.jsResources/app.nw/app/dist/stores/projectStores.jsResources/app.nw/app/dist/weapp/appservice/asdebug.jsResources/app.nw/app/dist/common/assdk/storageSdk.jswindow上：安装完后，一般是放在这个目录里：C:\\Program Files (x86)\\Tencent\\微信web开发者工具找到相应文件再替换：package.nw/app/dist/components/create/createstep.jspackage.nw/app/dist/stores/projectStores.jspackage.nw/app/dist/weapp/appservice/asdebug.js破解的时候，把整个代码大概浏览了一遍，自己折腾了下。（因为之前写过react + flux的代码，所以对这个项目的结构非常熟悉。）主要的修改，如果你有兴趣可以浏览下：1、asdebug.js修改（1）搜索“域名”两个字，找到类似域名校验出错等字眼的那一个function 把整个function内部的内容都注释掉，直接return true;这个主要是为了去掉安全域名的限制（2）搜索“URL 域名不合法，请在 mp 后台配置后，重启项目继续测试” 跟上面一样，把前面if改成if(false)这个修改主要是为了去掉websocket的安全名限制（3）搜索“__wxConfig.isTourist”，把它改成false这个修改是为了去掉游客身份。2、projectStores.js（1）搜索“setProjectConfig: function” 这个函数的定义把“i = e.isTourist”（不一定是i和e，不同的js格式化工具可能会有不一样的结果）这一小段注释掉，把下方的第一个if(i) { ... }整块注释掉。这一个用来判断是否是游客身份，是的话直接返回。但我们不想只是游客身份，所以这里我们不能让它返回，整个注释掉就行了。（2）在上面这个函数从上往下找try catch，把找到的第一个整块注释掉 然后把它下方的第一个if改成if(true)，if里的第一行var赋值语句的等号后面直接改成{Setting: {MaxLocalstorageSize: 10}}，因为在dist/common/assdk/storageSdk.js里有对这个值的引用，如果这里没有设置这个MaxLocalstorageSize的话，wx.setStorage会保存失败，wx.setStorageSync会报错。另外这里设置成if(true)是因为我们在创建项目时随便填appid，所以网络请求返回肯定是error，这里的JSON.parse结果在if里是通不过的。我们把这一整段注释掉，不去管网络返回的error。进if后会在本地存储新建项目的信息。这个地方的修改比较复杂，截图如下：3、createstep.js（1）搜索“当前开发者未绑定此 appid”把第一个if及周边的东西都注释掉，只执行下一个if。这个地方是创建的时候，返回用户信息的地方，上面说过我们创建时返回的肯定是error，所以这里自然也拿不到用户信息，反而是一个用户appId错误提示，所以这里我们动点手脚，把这个判断都注释掉，让它只执行用户信息返回的成功代码，同时我们创建一个假的用户信息object。这个修改比较复杂，截图如下：网络请求的接口，微信做了一些安全限制，要破解才能给任意地址发请求。websocket的接口也是一样。本项目的破解文件已经解决了这些问题。另外，创建出来的demo项目中，调用wx.login是不能成功的，所以改了demo的代码，在app.js里直接给globalData.userInfo赋值即可。init: function() {\r\n  this.globalData.userInfo = {\r\n    \"nickName\": \"jason\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/icSHGibMIMB82jDEHibGFA1s6dhwMibWrQAPeRvT2w2y2rpZVM5l3BftVEr3rTgX4fXDlznnMmZY0zYtgkfFw7L3o9r0tTblGTxB/0\",\r\n    \"gender\": 1,\r\n    \"province\": \"广东\",\r\n    \"city\": \"深圳\",\r\n    \"country\": \"中国\",\r\n  };\r\n},\r\n然后在onLaunch里调用一下init()就ok几个问题说明MaxRequestConcurrent报错的问题这个在本项目的破解文件里已经直接覆盖了，不会报这个错了。（修改：asdebug.js里，搜MaxRequestConcurrent，很简单，直接把它设置成固定数字即可）页面切换时会出现route错误的问题这个可能是开发工作自身的bug，用一段时间后就会这样，目前还没发现原因，不过解决这个问题很简单，关掉，重新再开就好了。Failed to load resource: net::ERR_NAME_NOT_RESOLVED这个问题gavinkwoe的项目中也说明了，主要是由于代理导致的，打开ide，菜单上选“动作”->“设置”，选直连就行"}
{"title": "微信小程序二三级菜单（navigateTo传递数据的应用） ", "author": "天下雪", "pub_time": "2016-10-29 01:03", "content": "今早来之后稍微写了下今天的工作目标然后就是自己犯蠢到现在的过程，所幸最后还是走回了正轨，记录一下我在过程中的内心弹幕，并把最后结果记录一下微信小程序-估价系统-车辆品牌款式等-三级菜单车标省份-城市-二级菜单（二三级菜单首先考虑使用微信小程序的数据缓存，但在不刷新的情况下缓存数据永远是上一次保存的。今天更新了微信小程序开发工具版本，发现写了数据缓存的代码之后后面的跳转语句不能执行无法跳转。打算放弃数据缓存的方式，想到另一种是在数组中加上跳转的目标地址然后直接跳过去，这样的弊端在于需要加上许多的页面比如一个省下的城市页面几十个省要几十个页面，忽然灵光一闪，考虑是否可以跳转中携带数据？马上进行尝试。！！！！我的天，我之前看官方文档都是睡觉去了吗。。。navigateTo的url里是可以带参数的，我没看到！！！！！！！！！！！！！！！！就算没看到以前写过的js都是做梦去了吗！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！我成功了，喜极而泣。）最终代码：toCity:function(e){    var index=e.currentTarget.dataset.hi;    var arr=this.data.provinceList[index].city;     wx.navigateTo({         url:\"../city/city?cityList=\"+arr     })   }跳转的时候url链接里把要传的数据加上就可以，我想传的数据是数组arr在跳转目标的js文件里用以下代码获得数据Page({    onLoad:function(options){        this.setData({            cityList:options.cityList.split(\",\")        })    }})因为直接用options.cityList得到的是字符串我用split转换成了数组。完美有木有。/(ㄒoㄒ)/~~所以当初为什么没有仔细看官方文档效果图如下，点山东跳转到山东的城市"}
{"title": "半桶水技术分享：微信小程序实现跳转传参 ", "author": "天下雪", "pub_time": "2016-10-29 23:20", "content": "刚接触微信小程序，多里面的语法和属性还不怎么聊解，如有不多的地方希望各位大神多多指教。今天来说下微信小程序怎么跳转和传参，话不多说直接上代码。实现的功能是给列表增加点击功能传参到下一页；    代码如下：<import src=\"../WXtemplate/headerTemplate.wxml\"/>  <view>      <!--滚动图-->      <view>       <swiper  indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoPlay}}\" interval=\"{{intervalTime}}\" duration=\"{{Time}}\">          <block wx:for=\"{{imageURl}}\">              <swiper-item>                   <image src=\"{{item}}\" class=\"imagePX\"></image>              </swiper-item>          </block>      </swiper>      </view>      <!--功能按钮-->      <view class=\"section-bg\">          <block wx:for=\"{{buttonNum}}\">           <!--模版-->              <template is=\"buttonList\" data=\"{{item}}\"/>              <!--<view class=\"section-item\">            <image class=\"section-img\" src=\"{{item.image}}\"></image>              <text class=\"section-text\">{{item.text}}</text>          </view>-->          </block>      </view>      <!--资讯列表-->      <view>          <block wx:for=\"{{listNum}}\">              <template is=\"newList\" data=\"{{item,index}}\"/>          </block>      </view>   </view>  其中<template is=\"buttonList\" data=\"{{item}}\"/> 为模版代码如下<template name=\"buttonList\">       <view class=\"section-item\">            <image class=\"section-img\" src=\"{{item.image}}\" bindtap=\"buttonClick\"></image>              <text class=\"section-text\">{{item.text}}</text>          </view>  </template>  <!--list-->  <template name=\"newList\">       <view class=\"section-list\" bindtap=\"listClick\" id=\"{{index}}\">          <view>              <image class=\"list-img\" src=\"{{item.image}}\"></image>          </view>           <view class=\"section-textt\">               <view class=\"title\"><text>{{item.title}}</text></view>               <view class=\"subTitle\"><text>{{item.subTitle}}</text></view>          </view>      </view>  </template>  这里只为下面的列表增加了点击方法点击列表js代码listClick:function(event){      console.log(event);     var p = event.currentTarget.id      wx.navigateTo({url:'/pages/xiangqing/xiangqing?id=上一页的参数'})    }  其中wx.navigateTo({url:'/pages/xiangqing/xiangqing?id=上一页的参数'}) 为跳转方法，id为需要传的参数 如果参数为动态参数代码如下： <pre name=\"code\" class=\"javascript\"> listClick:function(event){        console.log(event);       var p = event.currentTarget.id        wx.navigateTo({url:'/pages/xiangqing/xiangqing?id='+p})      } 其中p为上面为每一行设置的id值在下一页取值代码如下：<pre name=\"code\" class=\"javascript\">  data:{      // text:\"这是一个页面\"      title:''    },    onLoad:function(options){      // 页面初始化 options为页面跳转所带来的参数    this.setData({      title:options.id    })  然后在页面上显示代码如下：<pre name=\"code\" class=\"html\"><view>{{title}}</view> 最终实现效果："}
{"title": "微信小程序实践心得：实现tabs选项卡效果，location API接口，audio组件 ... ", "author": "天下雪", "pub_time": "2016-10-18 18:00", "content": "一：实现tabs选项卡效果      最近微信应用号是炒的如火如荼，热门满满，但是也可以发现搜索关键词出来，各类网站出现的还都是微信的官方文档解释。正好赶上这个热潮，这几天先把小程序技术文档看了个遍，就直接着手写案例了。很多组件微信内部已经封装完了，正好发现没有tab选项卡效果，这两天正好研究了下。思路如下： 1、首先点击导航的时候需要两个变量，一个存储当前点击样式类，一个是其它导航默认的样式类2、选项卡内容列表同样也需要两个变量，一个存储当前显示块，一个存储的是其它隐藏的默认块3、使用三目运算通过点击获取导航索引，根据索引判断是否添加当前类【备注，这里我将点击事件绑定在父级导航栏，通过target对象得到点击触发的事件对象属性】请结合如下效果图：      接下来直接查看源码：demo.wxml：<view class=\"tab\">    <view class=\"tab-left\" bindtap=\"tabFun\">      <view class=\"{{tabArr.curHdIndex=='0'? 'active' : ''}}\" id=\"tab-hd01\" data-id=\"0\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='1'? 'active' : ''}}\" id=\"tab-hd02\" data-id=\"1\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='2'? 'active' : ''}}\" id=\"tab-hd03\" data-id=\"2\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='3'? 'active' : ''}}\" id=\"tab-hd04\" data-id=\"3\">tab-hd01</view>    </view>      <view class=\"tab-right\">      <view class=\"right-item {{tabArr.curBdIndex=='0'? 'active' : ''}}\">tab-bd01</view>      <view class=\"right-item {{tabArr.curBdIndex=='1'? 'active' : ''}}\">tab-bd02</view>      <view class=\"right-item {{tabArr.curBdIndex=='2'? 'active' : ''}}\">tab-bd03</view>      <view class=\"right-item {{tabArr.curBdIndex=='3'? 'active' : ''}}\">tab-bd04</view>    </view>  </view>  demo.js：Page( {    data: {      tabArr: {        curHdIndex: 0,        curBdIndex: 0      },    },    tabFun: function(e){      //获取触发事件组件的dataset属性      var _datasetId=e.target.dataset.id;      console.log(\"----\"+_datasetId+\"----\");      var _obj={};      _obj.curHdIndex=_datasetId;      _obj.curBdIndex=_datasetId;      this.setData({        tabArr: _obj      });    },    onLoad: function( options ) {      alert( \"------\" );    }  });  demo.wxss：.tab{      display: flex;      flex-direction: row;  }  .tab-left{      width: 200rpx;      line-height: 160%;      border-right: solid 1px gray;  }  .tab-left view{      border-bottom: solid 1px red;  }  .tab-left .active{      color: #f00;  }  .tab-right{      line-height: 160%;  }  .tab-right .right-item{      padding-left: 15rpx;      display: none;  }  .tab-right .right-item.active{      display: block;  }      最终演示效果如下：二：location API接口微信小程序的位置接口共有两个：1、wx.getLocation(OBJECT)获取当前的地理位置、速度。2、wx.openLocation(OBJECT) 使用微信内置地图查看位置然后，根据object参数说明，结合module模块化重写了下两个接口在暴露出来引用，让项目更加灵活管理。具体代码如下：location.js：：/**   * 获取当前的地理位置、速度。   * 1、fType：         默认为 wgs84 返回 gps 坐标，gcj02 返回可用于wx.openLocation的坐标     选填   * 2、cbSuccessFun： 接口调用成功的回调函数，返回内容详见返回参数说明。 必填   * 3、cbFailFun：    接口调用失败的回调函数 选填   * 4、cbCompleteFun：接口调用结束的回调函数（调用成功、失败都会执行） 选填   */  function getLocationFun(fType, cbSuccessFun, cbFailFun, cbCompleteFun){      var getObj={};      getObj.type=\"wgs84\";      if(fType){          getObj.type=fType;      }      getObj.success=function(res){          var _res=res;          if(cbSuccessFun){              cbSuccessFun(_res);          }      }      getObj.fail=function(res){          if(cbFailFun){              cbFailFun();          }else{              console.log(\"getLocation fail:\"+res.errMsg);          }      }      getObj.complete=function(res){          if(cbCompleteFun){              cbCompleteFun();          }      }      wx.getLocation(getObj);  }    /**   * 使用微信内置地图查看位置   * 1、latitude：     纬度，范围为-90~90，负数表示南纬 必填   * 2、longitude：    经度，范围为-180~180，负数表示西经 必填   * 3、scale：        缩放比例，范围1~28，默认为28 选填   * 4、name：         位置名 选填   * 5、address：      地址的详细说明 选填   * 6、cbSuccessFun： 接口调用成功的回调函数 选填   * 7、cbFailFun：    接口调用失败的回调函数 选填   * 8、cbCompleteFun：接口调用结束的回调函数（调用成功、失败都会执行） 选填   */  function openLocationFun(latitude, longitude, scale, name, address, cbSuccessFun, cbFailFun, cbCompleteFun){      var openObj={};      openObj.latitude=latitude;      openObj.longitude=longitude;      openObj.scale=15;      if(scale>0 && scale<29){          openObj.scale=scale;      }      if(name){          openObj.name=name;      }      if(address){          openObj.address=address;      }      openObj.success=function(res){          if(cbSuccessFun){              cbSuccessFun();          }      }      openObj.fail=function(res){          if(cbFailFun){              cbFailFun();          }else{              console.log(\"openLocation fail:\"+res.errMsg);          }      }      openObj.complete=function(res){          if(cbCompleteFun){              cbCompleteFun();          }      }      wx.openLocation(openObj);  }    module.exports={      getLocationFun: getLocationFun,      openLocationFun: openLocationFun  }  demo.js：：var comm = require( \"../../common/common.js\" );  var location=require('../../common/location.js');  Page( {    data: {      uploadImgUrls: [],      title: \"\"    },    getlocation: function( e ) {      location.getLocationFun(        'gcj02',         function(cb){          console.log(cb);          var _latitude=cb.latitude;          var _longitude=cb.longitude;          location.openLocationFun(            _latitude,            _longitude,            null,            \"厦门观音山\",            \"厦门观音山匹克大厦\",            null,            null,            null          )        }      )    },    onLoad: function( options ) {      var _title = \"ddd\";      if( options.title ) {        _title = options.title;      }      this.setData( {        title: _title      })      console.log(\"load\")      console.log( comm.formatDateFun( new Date(), 1 ) );    },    onShow:function(e){      console.log(\"show\");    },    onHide: function(e){      console.log(\"hide\");    },    onUnload:function(e){      console.log(\"unload\");    }    // onReady: function(){    //   wx.setNavigationBarTitle({    //     title: this.data.title    //   });    // }  })  经调试发现getLocation接口的type不管是传递wgs84还是gcj02返回的参数都是只有经纬度，并没有文档上提到的速度和位置的精确度两个参数然后我在点击“去这里”页面跳转后，发现每次都是提示定位失败，不晓得是不是因为web开发工具的原因。而且好像经纬度有差距，和本人实际距离不一致。还有定义了name和address两个参数并没有发现有啥变化，最后比较严重的问题是我点击返回后提示page route错误，再次点击按钮，提示错误了，不能点击。不知道什么原因？要怎么解决！目前针对这个接口学习到这里，后续有其他发现或者解决办法在来更新。=====================================================================================今天，微信发布新版本了【最新版本 0.10.101100】，对于位置接口也有进一步的更新，1、打开地图接口在返回不会提示page route错误了2、wx.openLocation接口传递自定义的name和address参数后，可以在地图描述框，显示出来了，不过经纬度依然不够准确。点击“去这里”依然是定位失败。  三：audio组件发现的几个问题      这个只测试了action的method=play的情况下，其它的方法我有稍微改变了下src和action方法，发现只要一切换其它action方法和src歌曲后，歌曲都是未开播状态，所以应该不会出现什么问题。主要是play的情况下有几个小问题需要注意下！先上官方源码：wxml：<!-- 循环播放 -->  <audio poster=\"{{poster}}\" name=\"{{name}}\" author=\"{{author}}\" src=\"{{src}}\" action=\"{{action}}\" controls loop></audio>  <button type=\"primary\" bindtap=\"audioPlay\">播放</button>  js：Page({    data: {      poster: 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000',      name: '此时此刻',      author: '许巍',      src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46',    },    audioPlay: function () {       this.setData({         action: {           method: 'play'         }       })    },    onLoad: function(options){      }  })  以上是官方源码，执行都正常，但是我做了如下测试：1、action的赋值方式this.setData({        'action.method': 'play'      })  我修改成这种赋值方式也能正常开启播放，如果我在page的data里面预先创建action对象，虽然值有被正常修改过来，但是音乐就是无法一开启就播放，需要按f5刷新下页面。完整测试代码如下：Page({    data: {      poster: 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000',      name: '此时此刻',      author: '许巍',      src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46',      action:      {        method: 'pause'      }    },    audioPlay: function () {      this.setData({        'action.method': 'play'//在data里面先定义action，这种赋值方式有效但是播放无效，需要再次刷新页面      })    })  2、更改了src曲目后在开启播放状态this.setData({        src: \"../audio/files/AlexGoot&KurtSchneider&Eppic-SeeYouAgain.aac\",         action: {           method: 'play'         }      })  我修改了src的曲目，发现不管有没有在data里面预先定义action对象都是能修改状态值，但是音乐就是无法播放，需要点击两次按钮，或者f5刷新下页面才有效。最后发现修改src和action分开设定就能正常播放了。完整代码如下：Page({    data: {      poster: 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000',      name: '此时此刻',      author: '许巍',      src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46',      action:      {        method: 'pause'      }    },    audioPlay: function () {      this.setData({        src: \"../audio/files/AlexGoot&KurtSchneider&Eppic-SeeYouAgain.aac\",      })       this.setData({         action: {           method: 'play'//需要分开设置         }       })    })  或者下面这种方式也可以：[plain] view plainPage({    data: {      poster: 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000',      name: '此时此刻',      author: '许巍',      src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46',      },    audioPlay: function () {      this.setData({        src: \"../audio/files/AlexGoot&KurtSchneider&Eppic-SeeYouAgain.aac\",      })      this.setData({        'action.method': 'play'//data没有定义action，使用这种赋值方式      })    })  总结以上两种方案：1、初始化data不设定action，可以使用\"action.method\": \"play\"修改状态2、修改src曲目的时候不管有没有初始化设定action，修改action的状态都要分开设定"}
